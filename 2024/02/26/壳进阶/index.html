<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="壳进阶"><meta name="keywords" content="Reverse,Bin"><meta name="author" content="Second_BC,undefined"><meta name="copyright" content="Second_BC"><title>壳进阶【Second_BC の BloG】</title><link rel="stylesheet" href="/SecondBC/css/fan.css"><link rel="stylesheet" href="/SecondBC/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/SecondBC/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/SecondBC/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/SecondBC/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/SecondBC/atom.xml" title="Second_BC の BloG" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B3%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">壳的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0shellcode%E5%88%B0PE"><span class="toc-number">2.</span> <span class="toc-text">添加shellcode到PE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%A3%B3"><span class="toc-number">3.</span> <span class="toc-text">加壳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%A3%B3%E4%BB%A3%E7%A0%81%E5%86%99%E5%85%A5%E5%87%86%E5%A4%87"><span class="toc-number">3.1.</span> <span class="toc-text">为壳代码写入准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%8E%9F%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86"><span class="toc-number">3.2.</span> <span class="toc-text">对原程序编码加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C%E5%A3%B3%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.</span> <span class="toc-text">制作壳代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8API"><span class="toc-number">3.3.1.</span> <span class="toc-text">动态调用API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="toc-number">3.4.</span> <span class="toc-text">修复重定位表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">重定位表结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E5%BC%80%E5%A7%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">修复开始</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%9F%BA%E5%9D%80%E9%97%AE%E9%A2%98"><span class="toc-number">3.4.3.</span> <span class="toc-text">动态基址问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-number">3.5.</span> <span class="toc-text">加密导入表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%B1%E5%A3%B3"><span class="toc-number">4.</span> <span class="toc-text">脱壳</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/SecondBC/ss.jpg"></div><div class="author-info-name">Second_BC</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/" target="_blank">GitHub<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="mailto:1" target="_blank">E-Mail<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color1"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/SecondBC/archives"><span class="pull-top">日志</span><span class="pull-bottom">38</span></a><a class="author-info-articles-tags article-meta" href="/SecondBC/tags"><span class="pull-top">标签</span><span class="pull-bottom">10</span></a><a class="author-info-articles-categories article-meta" href="/SecondBC/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/SecondBC">首页</a><a class="menu-item" href="/SecondBC/archives">归档</a><a class="menu-item" href="/SecondBC/categories">分类</a><a class="menu-item" href="/SecondBC/tags">标签</a><a class="menu-item" href="/SecondBC/about">关于</a></nav><div class="right-info"><a class="title-name" href="/SecondBC/">Second_BC の BloG</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">壳进阶</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2024-02-26 | 更新于 2024-04-13</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Bin/">Bin</a></div></div></div><div class="main-content"><h2 id="壳的原理"><a href="#壳的原理" class="headerlink" title="壳的原理"></a>壳的原理</h2><p>PE文件到运行时经过的几步重要步骤：</p>
<ul>
<li>将硬盘中的PE文件复制到内存中；</li>
<li>按内存对齐值对齐；</li>
<li>加载dll等模块；</li>
<li>修复IAT，重定位表；</li>
<li>进入OEP（Original Entry Point）开始执行</li>
</ul>
<p>壳的原理则是修改OEP （可选PE头） 指向自身代码的地址，执行完后返回真正的OEP；</p>
<p>壳位于PE文件所处位置需要是可执行区段内，如.text；</p>
<p>计算OEP偏移地址用于jmp指令返回公式：</p>
<p>jmp E9 xxxxxxxx = OEP - 此指令下一指令地址</p>
<h2 id="添加shellcode到PE"><a href="#添加shellcode到PE" class="headerlink" title="添加shellcode到PE"></a>添加shellcode到PE</h2><p>使用010editor：</p>
<ol>
<li>添加一个空白区段在PE末尾 （1000h同时满足文件内存对齐）；</li>
<li>添加一个区段头；</li>
<li>修正新加区段的属性（通过最后一个区段头开始以及大小计算新加区段的各属性）；</li>
<li>修改 numberofsections （PE头）；</li>
<li>修改 sizeofimage （可选PE头）；</li>
<li>将shellcode粘贴于新区段处；</li>
<li>修改OEP于shellcode处；</li>
</ol>
<p>如果遇到区段头无空余部分问题，可将PE头和区段头之间内容平移向上覆盖掉DOS存根，并且改掉 lfanew 偏移，之后可添加；</p>
<p>亦或者直接扩大最后一个区段，并修改属性；</p>
<p>或者合并区段：</p>
<ol>
<li>读取PE文件模拟内存对齐对每个区段进行拉伸（防止其他区段合并后偏移错误）；</li>
<li>只保留第一个区段头信息，其他填充0；</li>
<li>修改第一个区段头属性；</li>
<li>修改numberofsections；</li>
<li>将更改后的PE文件保存为新文件；</li>
</ol>
<p>这样做会导致原文件扩大，但在内存中的大小不会改变，此时有足够的空间塞入壳代码；</p>
<h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><h3 id="为壳代码写入准备"><a href="#为壳代码写入准备" class="headerlink" title="为壳代码写入准备"></a>为壳代码写入准备</h3><p>如之前插入区段的方式与思路用代码操作PE，此时创建一个叫MyShell的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyShell</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* fileBuff;</span><br><span class="line">	DWORD fileSize;</span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader;</span><br><span class="line">	PIMAGE_FILE_HEADER pFileHeader;</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER pOptionHeader;</span><br><span class="line">	PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyShell</span>();</span><br><span class="line">	~<span class="built_in">MyShell</span>();</span><br><span class="line">	<span class="function">BOOL <span class="title">LoadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">SaveFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">InitFileInfo</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">BOOL <span class="title">InsertSection</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sectionName, DWORD codeSize, <span class="keyword">char</span>* codeBuff, DWORD dwCharateristics)</span></span>;</span><br><span class="line">	<span class="function">DWORD <span class="title">GetAlignSize</span><span class="params">(DWORD realSize, DWORD alignSize)</span></span>;</span><br><span class="line">    <span class="function">BOOL <span class="title">EncodeSections</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DWORD <span class="title">GetOep</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetOep</span><span class="params">(DWORD OEP)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>第一步，读取文件并创建buffer保存PE镜像；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyShell::LoadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//打开文件</span></span><br><span class="line">	HANDLE hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_READ, <span class="number">0</span>, <span class="number">0</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//获取镜像</span></span><br><span class="line">	fileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="number">0</span>);</span><br><span class="line">	fileBuff = <span class="keyword">new</span> <span class="keyword">char</span>[fileSize] &#123;&#125;;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ReadFile</span>(hFile, fileBuff, fileSize, <span class="number">0</span>, <span class="number">0</span>) == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;文件获取失败！&quot;</span>, <span class="string">&quot;异常&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">InitFileInfo</span>();</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第二步，解析PE（各个头）；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于 fileBuff 镜像</span></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::InitFileInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pDosHeader = (PIMAGE_DOS_HEADER)fileBuff;</span><br><span class="line">	pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + fileBuff);</span><br><span class="line">	pFileHeader = &amp;(pNtHeader-&gt;FileHeader);</span><br><span class="line">	pOptionHeader = &amp;(pNtHeader-&gt;OptionalHeader);</span><br><span class="line">	pSectionHeader = (PIMAGE_SECTION_HEADER)(pFileHeader-&gt;SizeOfOptionalHeader + (DWORD)pOptionHeader);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第三步，插入区段和区段头，设置属性并修改PE某些字段；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyShell::InsertSection</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sectionName, DWORD codeSize, <span class="keyword">char</span>* codeBuff, DWORD dwCharateristics)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//判断节区头是否剩下两个头的空位</span></span><br><span class="line">	DWORD SectionCount = pFileHeader-&gt;NumberOfSections;</span><br><span class="line">	DWORD EndOfSectionHeader = (DWORD)pSectionHeader + SectionCount * IMAGE_SIZEOF_SECTION_HEADER;</span><br><span class="line">	DWORD BeginOfSection = (DWORD)fileBuff + pOptionHeader-&gt;SizeOfHeaders;</span><br><span class="line">	<span class="keyword">if</span> (BeginOfSection - EndOfSectionHeader &lt; IMAGE_SIZEOF_SECTION_HEADER * <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;插入失败，节区头大小不足！&quot;</span>, <span class="string">&quot;异常&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取新PE文件大小并建立新buff存放新PE</span></span><br><span class="line">	DWORD newFileSize = <span class="built_in">GetAlignSize</span>(fileSize + codeSize, pOptionHeader-&gt;FileAlignment);</span><br><span class="line">	<span class="keyword">char</span>* newFileBuff = <span class="keyword">new</span> <span class="keyword">char</span>[newFileSize] &#123;&#125;;</span><br><span class="line">	<span class="built_in">memcpy_s</span>(newFileBuff, newFileSize, fileBuff, fileSize);</span><br><span class="line">	fileSize = newFileSize;</span><br><span class="line">	<span class="keyword">delete</span>[] fileBuff;</span><br><span class="line">	fileBuff = newFileBuff;</span><br><span class="line">	<span class="built_in">InitFileInfo</span>();</span><br><span class="line">	<span class="comment">//新增区段添加区段头并添加属性:名字，内存大小，文件大小，内存地址，文件偏移，权限</span></span><br><span class="line">	PIMAGE_SECTION_HEADER lastSectionHeader = pSectionHeader + (SectionCount - <span class="number">1</span>);</span><br><span class="line">	PIMAGE_SECTION_HEADER newSectionHeader = lastSectionHeader + <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">strcpy_s</span>((<span class="keyword">char</span> *)newSectionHeader-&gt;Name, <span class="number">8</span>, sectionName);</span><br><span class="line">	newSectionHeader-&gt;Misc.VirtualSize = <span class="built_in">GetAlignSize</span>(codeSize, pOptionHeader-&gt;SectionAlignment);</span><br><span class="line">	newSectionHeader-&gt;SizeOfRawData = <span class="built_in">GetAlignSize</span>(codeSize, pOptionHeader-&gt;FileAlignment);</span><br><span class="line">	newSectionHeader-&gt;VirtualAddress = lastSectionHeader-&gt;VirtualAddress + <span class="built_in">GetAlignSize</span>(lastSectionHeader-&gt;Misc.VirtualSize, pOptionHeader-&gt;SectionAlignment);</span><br><span class="line">	newSectionHeader-&gt;PointerToRawData = lastSectionHeader-&gt;PointerToRawData + lastSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">	newSectionHeader-&gt;Characteristics = dwCharateristics;</span><br><span class="line">	newSectionHeader-&gt;PointerToLinenumbers = <span class="number">0</span>;</span><br><span class="line">	newSectionHeader-&gt;PointerToRelocations = <span class="number">0</span>;</span><br><span class="line">	newSectionHeader-&gt;NumberOfLinenumbers = <span class="number">0</span>;</span><br><span class="line">	newSectionHeader-&gt;NumberOfRelocations = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//修改numberofsections以及sizeofimage</span></span><br><span class="line">	pFileHeader-&gt;NumberOfSections++;</span><br><span class="line">	pOptionHeader-&gt;SizeOfImage += <span class="built_in">GetAlignSize</span>(codeSize, pOptionHeader-&gt;SectionAlignment);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加shellcode</span></span><br><span class="line">	<span class="keyword">char</span>* sectionBuff = newSectionHeader-&gt;PointerToRawData + fileBuff;</span><br><span class="line">	<span class="built_in">memcpy</span>(sectionBuff, codeBuff, codeSize);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存对齐</span></span><br><span class="line"><span class="function">DWORD <span class="title">MyShell::GetAlignSize</span><span class="params">(DWORD realSize, DWORD alignSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (realSize % alignSize == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> realSize;</span><br><span class="line">	<span class="keyword">return</span> (realSize / alignSize + <span class="number">1</span>) * alignSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第四步，保存文件；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyShell::SaveFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_WRITE, <span class="number">0</span>, <span class="number">0</span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WriteFile</span>(hFile, fileBuff, fileSize, <span class="number">0</span>, <span class="number">0</span>) == FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;保存文件失败！&quot;</span>, <span class="string">&quot;异常&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，用代码实现了之前用010手动粘贴shellcode之前的所有步骤；</p>
<h3 id="对原程序编码加密"><a href="#对原程序编码加密" class="headerlink" title="对原程序编码加密"></a>对原程序编码加密</h3><p>加壳难度逐级递进，此时先考虑对.text段的加密，因为.data段有IAT表等东西需要处理；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyShell::EncodeSections</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> key = <span class="number">0xBC</span>;</span><br><span class="line">	<span class="keyword">char</span>* pData = pSectionHeader-&gt;PointerToRawData + fileBuff;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pSectionHeader-&gt;SizeOfRawData; i++)</span><br><span class="line">		pData[i] ^= key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="制作壳代码"><a href="#制作壳代码" class="headerlink" title="制作壳代码"></a>制作壳代码</h3><p>之前写的壳代码是需要手动从ida里扣的，这里的壳代码写在dll文件里，使用link命令合并区段只剩代码段，此时第一节区便是需要的shellcode；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码段数据段合并</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/merge:.data=.text&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/merge:.rdata=.text&quot;</span>)</span></span><br><span class="line"><span class="comment">//设置属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/section:.text,RWE&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>壳代码的特点：</p>
<ul>
<li>拥有解密功能；</li>
<li>拥有保护功能；</li>
</ul>
<p>难点：</p>
<ul>
<li>壳代码是后期写入文件里，系统无法修复壳代码的iat，需要动态调用API；</li>
<li>壳代码如果有全局变量，会涉及到重定位，需要修复壳的重定位表；</li>
</ul>
<p>其具体构造如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">Code</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//保存寄存器环境</span></span><br><span class="line">	__asm pushad</span><br><span class="line">	<span class="comment">//实现逻辑</span></span><br><span class="line">	<span class="built_in">GetAPI</span>();</span><br><span class="line">	<span class="built_in">DecodeSections</span>();</span><br><span class="line">	<span class="built_in">MyCode</span>();</span><br><span class="line">	<span class="comment">//恢复寄存器环境并跳入真正OEP</span></span><br><span class="line">	__asm popad</span><br><span class="line">	__asm jmp g_OepInfo.oldOEP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原OEP以及新OEP的传递需要用到dll的结构体导出，以便exe和dll交换OEP信息，其结构体如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OEPINFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD newOEP;</span><br><span class="line">	DWORD oldOEP;</span><br><span class="line">&#125;OEPINFO, * POEPINFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) OEPINFO g_OepInfo;</span><br><span class="line"></span><br><span class="line">OEPINFO g_OepInfo = &#123; (DWORD)Code &#125;;</span><br></pre></td></tr></table></figure>

<p>在之前的MyShell类里给出了OEP的set和get方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">MyShell::GetOep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pOptionHeader-&gt;AddressOfEntryPoint + pOptionHeader-&gt;ImageBase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入的OEP实际上为Code函数距离其节区开始的偏移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyShell::SetOep</span><span class="params">(DWORD OEP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD SectionCount = pFileHeader-&gt;NumberOfSections;</span><br><span class="line">	PIMAGE_SECTION_HEADER pLastSectionHeader = pSectionHeader + (SectionCount - <span class="number">1</span>);</span><br><span class="line">	pOptionHeader-&gt;AddressOfEntryPoint = pLastSectionHeader-&gt;VirtualAddress + OEP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="动态调用API"><a href="#动态调用API" class="headerlink" title="动态调用API"></a>动态调用API</h4><p>首先是GetAPI的实现，如何动态获取API地址呢，在上一篇ShellCode中说明了需要利用PEB来获取kernel32的基址从而找到LoadLibrary以获取所有可使用的API；</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取kernel32或者kernelbase</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetEssentialModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD dwBase = <span class="number">0</span>;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax, dword ptr fs : [<span class="number">0x30</span>]</span><br><span class="line">		mov eax, [eax + <span class="number">0xc</span>]</span><br><span class="line">		mov eax, [eax + <span class="number">0x1c</span>]</span><br><span class="line">		mov eax, [eax]</span><br><span class="line">		mov eax, [eax + <span class="number">0x8</span>]</span><br><span class="line">		mov dwBase, eax</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dwBase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据导出表寻址函数</span></span><br><span class="line"><span class="function">DWORD <span class="title">MyGetProcAddress</span><span class="params">(DWORD hModule, LPCSTR funcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取NT头</span></span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + (DWORD)hModule);</span><br><span class="line">	<span class="comment">//获取导出表</span></span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY exportTable = (PIMAGE_EXPORT_DIRECTORY)((pNtHeader-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress) + (DWORD)hModule);</span><br><span class="line">	<span class="comment">//名称表，序号表，地址表</span></span><br><span class="line">	DWORD* nameTable = (DWORD*)(exportTable-&gt;AddressOfNames + (DWORD)hModule);</span><br><span class="line">	WORD* oridinalTable = (WORD*)(exportTable-&gt;AddressOfNameOrdinals + (DWORD)hModule);</span><br><span class="line">	DWORD* addressTable = (DWORD*)(exportTable-&gt;AddressOfFunctions + (DWORD)hModule);</span><br><span class="line">	<span class="comment">//获取函数地址</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exportTable-&gt;NumberOfNames; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取函数名</span></span><br><span class="line">		<span class="keyword">char</span>* name = (<span class="keyword">char</span>*)(nameTable[i] + (DWORD)hModule);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, funcName))</span><br><span class="line">			<span class="keyword">return</span> addressTable[oridinalTable[i]] + (DWORD)hModule;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取之后所要用到的API</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetAPI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD kernelBase = <span class="built_in">GetEssentialModule</span>();</span><br><span class="line">	<span class="comment">//获取LoadlibraryEx</span></span><br><span class="line">	g_MyLoadLibraryExA = (MyLoadLibraryExA)<span class="built_in">MyGetProcAddress</span>(kernelBase, <span class="string">&quot;LoadLibraryExA&quot;</span>);</span><br><span class="line">	<span class="comment">//动态加载kernel32.dll</span></span><br><span class="line">	HMODULE kernel32Base = <span class="built_in">g_MyLoadLibraryExA</span>(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	g_MyGetProcAddress = (MYGetProcAddress)<span class="built_in">MyGetProcAddress</span>((DWORD)kernel32Base, <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line">	g_MyGetModuleHandleA = (MyGetModuleHandleA)<span class="built_in">g_MyGetProcAddress</span>(kernel32Base, <span class="string">&quot;GetModuleHandleA&quot;</span>);</span><br><span class="line">	g_MyVirtualProtect = (MyVirtualProtect)<span class="built_in">g_MyGetProcAddress</span>(kernel32Base, <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">	HMODULE user32Base = <span class="built_in">g_MyLoadLibraryExA</span>(<span class="string">&quot;user32.dll&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	g_MyMessageBoxA = (MyMessageBoxA)<span class="built_in">g_MyGetProcAddress</span>(user32Base, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对以上使用到的全局变量定义为如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span> <span class="params">(WINAPI * MyLoadLibraryExA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCSTR lpLibFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD dwFlags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MyLoadLibraryExA g_MyLoadLibraryExA = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span> <span class="params">(WINAPI * MYGetProcAddress)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCSTR  lpProcName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MYGetProcAddress g_MyGetProcAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span> <span class="params">(WINAPI * MyGetModuleHandleA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCSTR lpModuleName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MyGetModuleHandleA g_MyGetModuleHandleA = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(WINAPI * MyVirtualProtect)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD  flNewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">	PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MyVirtualProtect g_MyVirtualProtect = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI * MyMessageBoxA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND   hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">	UINT   uType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MyMessageBoxA g_MyMessageBoxA = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>之后，在解密部分实现里，就可以使用API来操作数据了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DecodeSections</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> key = <span class="number">0xBC</span>;</span><br><span class="line">	<span class="comment">//写入后，得到exe的镜像基址，并获取其节区</span></span><br><span class="line">	HMODULE hModule = <span class="built_in">g_MyGetModuleHandleA</span>(<span class="number">0</span>);</span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + (DWORD)hModule);</span><br><span class="line">	PIMAGE_SECTION_HEADER pSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNtHeader);</span><br><span class="line">	<span class="keyword">char</span>* sectionBuff = (<span class="keyword">char</span> *)(pSectionHeader-&gt;VirtualAddress + (DWORD)hModule);</span><br><span class="line">	<span class="comment">//解密</span></span><br><span class="line">	DWORD oldProtect;</span><br><span class="line">	<span class="built_in">g_MyVirtualProtect</span>(sectionBuff, pSectionHeader-&gt;SizeOfRawData, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pSectionHeader-&gt;SizeOfRawData; i++)</span><br><span class="line">		sectionBuff[i] ^= key;</span><br><span class="line">	<span class="built_in">g_MyVirtualProtect</span>(sectionBuff, pSectionHeader-&gt;SizeOfRawData, oldProtect, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">g_MyMessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;壳代码执行！&quot;</span>, <span class="string">&quot;提示&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时便有了dll文件，在之前的MyShell类的main函数中做出如下拼装：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHARACTERISTICS 0xE00000E0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OEPINFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD newOEP;</span><br><span class="line">	DWORD oldOEP;</span><br><span class="line">&#125;OEPINFO, * POEPINFO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyShell myShell;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nUsage: %s + ./file_you_want_pack\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>* path = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//载入目标exe并对节区加密</span></span><br><span class="line">	myShell.<span class="built_in">LoadFile</span>(path);</span><br><span class="line">	myShell.<span class="built_in">EncodeSections</span>();</span><br><span class="line">    <span class="comment">//载入上面编写好的dll文件</span></span><br><span class="line">	HMODULE hModule = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ShellCode.dll&quot;</span>);</span><br><span class="line">    <span class="comment">//获取OEP信息结构</span></span><br><span class="line">	POEPINFO pOepInfo = (POEPINFO)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;g_OepInfo&quot;</span>);</span><br><span class="line">	pOepInfo-&gt;oldOEP = myShell.<span class="built_in">GetOep</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取dll的节区位置，这是需要的shellcode</span></span><br><span class="line">	PIMAGE_DOS_HEADER pDllDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">	PIMAGE_NT_HEADERS pDllNtHeader = (PIMAGE_NT_HEADERS)(pDllDosHeader-&gt;e_lfanew + (DWORD)hModule);</span><br><span class="line">	PIMAGE_SECTION_HEADER pDllSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pDllNtHeader);</span><br><span class="line">	<span class="keyword">char</span>* buff = (<span class="keyword">char</span>*)(pDllSectionHeader-&gt;VirtualAddress + (DWORD)hModule);</span><br><span class="line">    <span class="comment">//将shellcode“粘贴”进目标exe文件</span></span><br><span class="line">	myShell.<span class="built_in">InsertSection</span>(<span class="string">&quot;BcShell&quot;</span>, pDllSectionHeader-&gt;Misc.VirtualSize, buff, CHARACTERISTICS);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//设置新的OEP指向</span></span><br><span class="line">	myShell.<span class="built_in">SetOep</span>(pOepInfo-&gt;newOEP - (DWORD)hModule - pDllSectionHeader-&gt;VirtualAddress);</span><br><span class="line">	</span><br><span class="line">	myShell.<span class="built_in">SaveFile</span>(path);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此一个加壳项目就 “完成” 了；</p>
<p>但这里任然保留了一个难点还没攻克：重定位表，在shellcode里编写的对全局变量引用的地址和在写入目标exe后所对应的地址是有问题的；</p>
<h3 id="修复重定位表"><a href="#修复重定位表" class="headerlink" title="修复重定位表"></a>修复重定位表</h3><h4 id="重定位表结构"><a href="#重定位表结构" class="headerlink" title="重定位表结构"></a>重定位表结构</h4><p>重定位表记录编译之前立即数地址所对应内容的位置，用于编译期间修复立即数，防止基址变化引起的立即数定位错误（类似于IAT在编译期间会修复原本指向名称为准确的地址）；</p>
<p>其位于datadirectory[5]；</p>
<p>重定位表中只有两个字段：VirtualAddress，SizeOfBlock，都为DWORD类型；</p>
<p>一个程序可能有多张重定位表；</p>
<p>其结构如下图所示：</p>
<p><img src="https://s2.loli.net/2023/07/17/pVgn2Zfrb5d9Ay1.png" alt="relocate"></p>
<p>其中sizeofblock为整个结构的大小（DWORD区域和WORD区域）；</p>
<p>virtualaddress存放的内容一般为0x1000的整数倍；</p>
<p>word类型区域存放数据加上virtualaddress的数据则是某个立即数的准确rva；</p>
<p>这些rva转换为va之后，<strong>存的是立即数</strong>，而不是立即数对应的变量值；</p>
<p>举例：</p>
<p>重定位表上的偏移带过去，内存中存的是 “全局变量的地址”a ，因为挪动让a发生变化，所以修复的是a，计算a在fileBuff镜像中的位置，给填入原先的重定位表的每个偏移存放的地址处，就完成了修复；</p>
<p>word类型区域存放数据：<code>0001 0000 0000 0000</code> ，高4位用于标识：0011为有效，其他位才是用来加virtualaddress的数据；</p>
<p>关于0x1000是对于4KB内存页的对齐，节省内存空间才这么设计的上述结构；</p>
<h4 id="修复开始"><a href="#修复开始" class="headerlink" title="修复开始"></a>修复开始</h4><p>对于将要修复的重定位表是针对于注入后的壳代码而言的，通过一个共同点：立即数地址对节区的<strong>偏移不变</strong>；</p>
<p>思路</p>
<ul>
<li>从dll中拿到原本的重定位表里的所有rva，利用这个rva和节区rva计算不变的相对偏移offset；</li>
<li>通过offset再拿到镜像中这些立即数的存放PA地址，此时也就得到了立即数；</li>
<li>再用同样的方法用立即数获取对应变量在镜像中新的立即数地址，并利用得到的PA地址来替换这些立即数；</li>
</ul>
<p>对MyShell类新增函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复插入后壳代码的个别立即数</span></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::RepairRelocate</span><span class="params">(DWORD imageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取dll重定位表</span></span><br><span class="line">	PIMAGE_DOS_HEADER pDllDosHeader = (PIMAGE_DOS_HEADER)imageBase;</span><br><span class="line">	PIMAGE_NT_HEADERS pDllNtHeader = (PIMAGE_NT_HEADERS)(pDllDosHeader-&gt;e_lfanew + imageBase);</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER pDllOptionHeader = &amp;(pDllNtHeader-&gt;OptionalHeader);</span><br><span class="line">	PIMAGE_BASE_RELOCATION pDllRelocate = (PIMAGE_BASE_RELOCATION)(pDllOptionHeader-&gt;DataDirectory[<span class="number">5</span>].VirtualAddress + imageBase);</span><br><span class="line">	PIMAGE_SECTION_HEADER pDllSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pDllNtHeader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历重定位表</span></span><br><span class="line">	<span class="keyword">while</span> (pDllRelocate-&gt;SizeOfBlock)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//取word类型个数</span></span><br><span class="line">		DWORD reCount = (pDllRelocate-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">char</span>* begin = (<span class="keyword">char</span> *)pDllRelocate + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历每个小数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; reCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			WORD* pRelocRva = (WORD*)begin;</span><br><span class="line">			<span class="comment">//有效位判断</span></span><br><span class="line">			<span class="keyword">if</span> ((*pRelocRva &amp; <span class="number">0x3000</span>) == <span class="number">0x3000</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//取DLL内立即数rva</span></span><br><span class="line">				DWORD relocRva = (*pRelocRva &amp; <span class="number">0xfff</span>) + pDllRelocate-&gt;VirtualAddress;</span><br><span class="line">				<span class="comment">//计算offset</span></span><br><span class="line">				DWORD offset = relocRva - pDllSectionHeader-&gt;VirtualAddress;</span><br><span class="line">				<span class="comment">//计算镜像中立即数地址</span></span><br><span class="line">				DWORD SectionCount = pFileHeader-&gt;NumberOfSections;</span><br><span class="line">				PIMAGE_SECTION_HEADER pLastSectionHeader = pSectionHeader + (SectionCount - <span class="number">1</span>);</span><br><span class="line">				DWORD destAddr = offset +(DWORD)(fileBuff + pLastSectionHeader-&gt;PointerToRawData);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//计算变量相对节区offset</span></span><br><span class="line">				offset = (*(DWORD*)destAddr - imageBase) - pDllSectionHeader-&gt;VirtualAddress;</span><br><span class="line">				<span class="comment">//计算变量于镜像内新VA并修改</span></span><br><span class="line">				DWORD aimVA = offset + (pLastSectionHeader-&gt;VirtualAddress + pOptionHeader-&gt;ImageBase);</span><br><span class="line">				*(DWORD*)destAddr = aimVA;</span><br><span class="line">			&#125;</span><br><span class="line">			begin += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pDllRelocate = (PIMAGE_BASE_RELOCATION)(pDllRelocate-&gt;SizeOfBlock + (DWORD)pDllRelocate);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上实现的加壳项目只适用于32位且固定基址的程序；</p>
<p>固定基址的原因：全局变量的VA计算用到了dll的imagebase，OEP的提取也用到了imagebase；</p>
<h4 id="动态基址问题"><a href="#动态基址问题" class="headerlink" title="动态基址问题"></a>动态基址问题</h4><p>思路是将dll的重定位表也扔到加壳程序里，利用操作系统对壳代码修复重定位表；</p>
<p>此时壳代码可以畅通无阻地运行，则可以在壳代码中动态的获取程序基址计算OEP，修复原程序重定位表；</p>
<p>思路：</p>
<ul>
<li>塞入dll壳代码与重定位表；</li>
<li>修复壳代码对应固定基址时立即数；</li>
<li>修复重定位表（重定位表的virtualAddress相对加壳程序而言）；</li>
<li>修改加壳程序datadirectory[5]字段；</li>
<li>修复原程序重定位表；</li>
</ul>
<p>步骤一，更改了main中对insertSection的输入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//获取OEP信息结构</span></span><br><span class="line">	POEPINFO pOepInfo = (POEPINFO)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;g_OepInfo&quot;</span>);</span><br><span class="line">	pOepInfo-&gt;oldOEP = myShell.<span class="built_in">GetOep</span>();</span><br><span class="line">------</span><br><span class="line">    </span><br><span class="line"><span class="comment">//保存旧重定位表信息</span></span><br><span class="line">	DWORD oldRelocSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> * oldReloc = myShell.<span class="built_in">SaveOldReloc</span>(&amp;oldRelocSize);</span><br><span class="line">	<span class="comment">//保存PE文件名</span></span><br><span class="line">	PPENAME PeName = (PPENAME)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;g_PeName&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy_s</span>(PeName-&gt;name, path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取dll的节区位置，这是需要的shellcode</span></span><br><span class="line">	PIMAGE_DOS_HEADER pDllDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">	PIMAGE_NT_HEADERS pDllNtHeader = (PIMAGE_NT_HEADERS)(pDllDosHeader-&gt;e_lfanew + (DWORD)hModule);</span><br><span class="line">	PIMAGE_SECTION_HEADER pDllSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pDllNtHeader);</span><br><span class="line">	<span class="keyword">char</span>* buff = (<span class="keyword">char</span>*)(pDllSectionHeader-&gt;VirtualAddress + (DWORD)hModule);</span><br><span class="line">	<span class="comment">//获取导入表</span></span><br><span class="line">	myShell.<span class="built_in">GetImportTable</span>();</span><br><span class="line">	<span class="comment">//获取dll重定位表</span></span><br><span class="line">	<span class="keyword">char</span>* pDllRelocate = (<span class="keyword">char</span> *)(pDllNtHeader-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].VirtualAddress + (DWORD)hModule);</span><br><span class="line">	<span class="comment">//计算插入Buff</span></span><br><span class="line">	DWORD finalSize = oldRelocSize + pDllSectionHeader-&gt;Misc.VirtualSize + pDllNtHeader-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size + myShell.<span class="built_in">GetImportTableSize</span>();</span><br><span class="line">	<span class="keyword">char</span>* finalBuff = <span class="keyword">new</span> <span class="keyword">char</span>[finalSize];</span><br><span class="line">	<span class="keyword">char</span>* p = finalBuff;</span><br><span class="line">	<span class="built_in">memcpy</span>(p, buff, pDllSectionHeader-&gt;Misc.VirtualSize);</span><br><span class="line">	p += pDllSectionHeader-&gt;Misc.VirtualSize;</span><br><span class="line">	<span class="keyword">if</span> (oldReloc)</span><br><span class="line">		<span class="built_in">memcpy</span>(p, oldReloc, oldRelocSize);</span><br><span class="line">	p += oldRelocSize;</span><br><span class="line">	<span class="built_in">memcpy</span>(p, pDllRelocate, pDllNtHeader-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size);</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">	<span class="comment">//将shellcode以及dll重定位表“粘贴”进目标exe文件</span></span><br><span class="line">	<span class="keyword">char</span>* sectionBuff = myShell.<span class="built_in">InsertSection</span>(<span class="string">&quot;BcShell&quot;</span>, finalSize, finalBuff, CHARACTERISTICS);</span><br><span class="line">	<span class="keyword">delete</span>[] finalBuff;</span><br></pre></td></tr></table></figure>

<p>虚线内为更改部分，这使得插入的节区大小可以满足shellcode以及重定位表和原程序自己导入表和原重定位表的大小；</p>
<p>对于新增加的函数：SaveOldReloc（）和 GetImportTable()，前者有以下说明，后者放在下一个小标题讲解；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">MyShell::SaveOldReloc</span><span class="params">(DWORD * size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*size = pOptionHeader-&gt;DataDirectory[<span class="number">5</span>].Size;</span><br><span class="line">	<span class="keyword">char</span>* reloc = <span class="built_in">Rva2Foa</span>(pOptionHeader-&gt;DataDirectory[<span class="number">5</span>].VirtualAddress) + fileBuff;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> reloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于要修改加壳程序的datadirectory[5]字段，所以要先把原来的保存起来，以修复原程序的重定位表；</p>
<p>步骤二三四由之前的 RepairRelocate() 函数修改而来，首先对类定义了一些成员和方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">DWORD inRelocSize;</span><br><span class="line">PIMAGE_BASE_RELOCATION inRelocTable;</span><br><span class="line">------</span><br><span class="line">    </span><br><span class="line"><span class="function">DWORD <span class="title">MyShell::Foa2Rva</span><span class="params">(DWORD foa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD rva = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (PIMAGE_SECTION_HEADER p = pSectionHeader; p-&gt;Name != <span class="literal">NULL</span>; p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (foa &gt;= p-&gt;PointerToRawData &amp;&amp; foa &lt; p-&gt;PointerToRawData + p-&gt;SizeOfRawData)</span><br><span class="line">		&#123;</span><br><span class="line">			rva = foa + p-&gt;VirtualAddress - p-&gt;PointerToRawData;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rva;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">MyShell::Rva2Foa</span><span class="params">(DWORD rva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD foa = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (PIMAGE_SECTION_HEADER p = pSectionHeader; p-&gt;Name != <span class="literal">NULL</span>; p++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (rva &gt;= p-&gt;VirtualAddress &amp;&amp; rva &lt; p-&gt;VirtualAddress + p-&gt;Misc.VirtualSize)</span><br><span class="line">		&#123;</span><br><span class="line">			foa = rva - p-&gt;VirtualAddress + p-&gt;PointerToRawData;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> foa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::GetInRelocTable</span><span class="params">(<span class="keyword">char</span>* sectionBuff, DWORD offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	inRelocTable = (PIMAGE_BASE_RELOCATION)(sectionBuff + offset);</span><br><span class="line">	PIMAGE_BASE_RELOCATION pInR = inRelocTable;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pInR-&gt;SizeOfBlock)</span><br><span class="line">	&#123;</span><br><span class="line">		inRelocSize++;</span><br><span class="line">		pInR++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后的</span></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::RepairRelocate</span><span class="params">(DWORD imageBase, <span class="keyword">char</span>* sectionBuff,DWORD offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//获取dll重定位表</span></span><br><span class="line">	PIMAGE_DOS_HEADER pDllDosHeader = (PIMAGE_DOS_HEADER)imageBase;</span><br><span class="line">	PIMAGE_NT_HEADERS pDllNtHeader = (PIMAGE_NT_HEADERS)(pDllDosHeader-&gt;e_lfanew + imageBase);</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER pDllOptionHeader = &amp;(pDllNtHeader-&gt;OptionalHeader);</span><br><span class="line">	PIMAGE_BASE_RELOCATION pDllRelocate = (PIMAGE_BASE_RELOCATION)(pDllOptionHeader-&gt;DataDirectory[<span class="number">5</span>].VirtualAddress + imageBase);</span><br><span class="line">	PIMAGE_SECTION_HEADER pDllSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pDllNtHeader);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//shellcode段RVA</span></span><br><span class="line">	DWORD shellCodeRVA = <span class="built_in">Foa2Rva</span>(sectionBuff - fileBuff);</span><br><span class="line">	PIMAGE_BASE_RELOCATION pInR = inRelocTable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历重定位表</span></span><br><span class="line">	<span class="keyword">while</span> (pDllRelocate-&gt;SizeOfBlock)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//取word类型个数</span></span><br><span class="line">		DWORD reCount = (pDllRelocate-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">char</span>* begin = (<span class="keyword">char</span> *)pDllRelocate + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历每个小数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; reCount; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			WORD* pRelocRva = (WORD*)begin;</span><br><span class="line">			<span class="comment">//有效位判断</span></span><br><span class="line">			<span class="keyword">if</span> ((*pRelocRva &amp; <span class="number">0x3000</span>) == <span class="number">0x3000</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//取DLL内立即数rva</span></span><br><span class="line">				DWORD relocRva = (*pRelocRva &amp; <span class="number">0xfff</span>) + pDllRelocate-&gt;VirtualAddress;</span><br><span class="line">				<span class="comment">//计算offset</span></span><br><span class="line">				DWORD offset = relocRva - pDllSectionHeader-&gt;VirtualAddress;</span><br><span class="line">				<span class="comment">//计算镜像中立即数地址</span></span><br><span class="line">				DWORD SectionCount = pFileHeader-&gt;NumberOfSections;</span><br><span class="line">				PIMAGE_SECTION_HEADER pLastSectionHeader = pSectionHeader + (SectionCount - <span class="number">1</span>);</span><br><span class="line">				DWORD destAddr = offset +(DWORD)(fileBuff + pLastSectionHeader-&gt;PointerToRawData);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//计算变量相对节区offset</span></span><br><span class="line">				offset = (*(DWORD*)destAddr - imageBase) - pDllSectionHeader-&gt;VirtualAddress;</span><br><span class="line">				<span class="comment">//计算变量于镜像内新VA并修改</span></span><br><span class="line">				DWORD aimVA = offset + (pLastSectionHeader-&gt;VirtualAddress + pOptionHeader-&gt;ImageBase);</span><br><span class="line">				*(DWORD*)destAddr = aimVA;</span><br><span class="line">			&#125;</span><br><span class="line">			begin += <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//修复壳代码重定位表</span></span><br><span class="line">		pInR-&gt;VirtualAddress = pDllRelocate-&gt;VirtualAddress - pDllSectionHeader-&gt;VirtualAddress + shellCodeRVA;</span><br><span class="line">		pDllRelocate = (PIMAGE_BASE_RELOCATION)(pDllRelocate-&gt;SizeOfBlock + (DWORD)pDllRelocate);</span><br><span class="line">		pInR++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//修改目标data目录指向注入重定位表</span></span><br><span class="line">	DWORD ss = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">SaveOldReloc</span>(&amp;ss);</span><br><span class="line">	DWORD tableNewRva = <span class="built_in">Foa2Rva</span>((DWORD)sectionBuff + offset - (DWORD)fileBuff - ss);</span><br><span class="line">	pOptionHeader-&gt;DataDirectory[<span class="number">5</span>].VirtualAddress = tableNewRva;</span><br><span class="line">	pOptionHeader-&gt;DataDirectory[<span class="number">5</span>].Size += pDllOptionHeader-&gt;DataDirectory[<span class="number">5</span>].Size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤五，实则已经实现，在步骤一将两张重定位表顺序插入shellcode之后，且在上面的代码中最后几段将导入表size更改为了两个size叠加；</p>
<p>用这个方法可以绕过动态基质，但是这个架构写出的壳有个bug，导致原程序加壳后变成固定基址了…虽然可以正常跑….</p>
<h3 id="加密导入表"><a href="#加密导入表" class="headerlink" title="加密导入表"></a>加密导入表</h3><p>此步骤针对于程序安全性质而言；</p>
<p>针对加壳程序的导入表加密，对API进行保护；</p>
<p>步骤：</p>
<ul>
<li>转移导入表进新区段，并抹掉原导入表（填充00，并将datadirectory[1]指向一个假表）；</li>
<li>对API名称加密；</li>
<li>对新导入表加密；</li>
<li>于壳代码中解密并手动模拟导入表的修复（使用对应dll的导出表）；</li>
</ul>
<p>此处只给出了转移导入表部分的代码，对于后期加密部分可参考上一篇 Windows_ShellCode；</p>
<p>当此处实现后，因为可以由代码自己修复导入表和重定位表，则原程序的.idata段和.reloc段就随便乱改都没问题了；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增字段</span></span><br><span class="line">DWORD importTableSize;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportTable;</span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">MyShell::GetImportTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(<span class="built_in">Rva2Foa</span>(pOptionHeader-&gt;DataDirectory[<span class="number">1</span>].VirtualAddress) + (DWORD)fileBuff);</span><br><span class="line">	<span class="keyword">for</span> (PIMAGE_IMPORT_DESCRIPTOR p = pImportTable; p-&gt;Name != <span class="literal">NULL</span>; p++)</span><br><span class="line">		importTableSize++;</span><br><span class="line">	importTableSize++;</span><br><span class="line">	importTableSize *= <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_IMPORT_DESCRIPTOR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">char</span> *)pImportTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::MoveImportTable</span><span class="params">(<span class="keyword">char</span>* sectionBuff, DWORD offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_IMPORT_DESCRIPTOR newImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(sectionBuff + offset);</span><br><span class="line">	<span class="comment">//移动到指定区段偏移位置</span></span><br><span class="line">	<span class="built_in">memcpy</span>(newImportTable, pImportTable, importTableSize);</span><br><span class="line">	<span class="built_in">memset</span>(pImportTable, <span class="number">0x00</span>, importTableSize);</span><br><span class="line">	pImportTable = newImportTable;</span><br><span class="line">	<span class="comment">//修改datadirectory对应rva</span></span><br><span class="line">	pOptionHeader-&gt;DataDirectory[<span class="number">1</span>].VirtualAddress = <span class="built_in">Foa2Rva</span>((DWORD)newImportTable - (DWORD)fileBuff);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">MyShell::GetImportTableSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> importTableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加密这里有个坑，按dll遍历函数名称填地址的时候，kernel32和kernelbase里有ntdll的函数引用，但是又有同名函数干扰，要想办法将对应dll的API地址填充正确，解决方法是判断导入表名称是否为kernel32或者kernelbase，如果是则多循环一次，多循环的一次dll则加载ntdll；</p>
<p>完成所有内容（包括加密导入表的所有步骤）的加壳项目：</p>
<p>关于加壳dll需要添加一个名字结构数组来传递模块名称，否则GetModuleHandle(0)是进程基址；</p>
<p>（ BUG 肯定是有的（ 缺陷是支持32位且节区头需要空闲 （</p>
<h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>脱壳手段于之前基础篇大部分都提及;</p>
<p>此外，esp定律一般是哄骗小学生的，大部分时候都用不到；</p>
<p>但基础篇尚未提及一点，在dump之后的文件虽然是可以查看其源码的，但如果需要动调，是无法实现的；</p>
<p>此时要让dump的程序能运行，则需要修复其导入表，因为此时导入表dump出的是实打实的地址，需要利用地址反找函数符号，重新构建导入表结构；</p>
<p>修复导入表一般用脚本完成，脚本实现思路如上述所示；</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Second_BC</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://secondbc.github.io/SecondBC/2024/02/26/%E5%A3%B3%E8%BF%9B%E9%98%B6/">https://secondbc.github.io/SecondBC/2024/02/26/%E5%A3%B3%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://secondbc.github.io/SecondBC">Second_BC の BloG</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2024/02/26/Xss-labs-DOM/"><i class="fas fa-angle-left">&nbsp;</i><span>Xss-labs-DOM</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2024/02/26/SQL%E6%B3%A8%E5%85%A5-sqlilabs/"><span>SQL注入-sqlilabs</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2022 ～ 2024 By Second_BC</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/copy.js"></script><!--script(src=url)--></body></html>