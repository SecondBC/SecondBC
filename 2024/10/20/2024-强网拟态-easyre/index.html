<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="2024-强网拟态-easyre"><meta name="keywords" content="Reverse"><meta name="author" content="Second_BC,undefined"><meta name="copyright" content="Second_BC"><title>2024-强网拟态-easyre【Second_BC の BloG】</title><link rel="stylesheet" href="/SecondBC/css/fan.css"><link rel="stylesheet" href="/SecondBC/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/SecondBC/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/SecondBC/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/SecondBC/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/SecondBC/atom.xml" title="Second_BC の BloG" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/SecondBC/ss.jpg"></div><div class="author-info-name">Second_BC</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/" target="_blank">GitHub<i class="icon-dot bg-color0"></i></a><a class="links-button button-hover" href="mailto:1" target="_blank">E-Mail<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color6"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/SecondBC/archives"><span class="pull-top">日志</span><span class="pull-bottom">38</span></a><a class="author-info-articles-tags article-meta" href="/SecondBC/tags"><span class="pull-top">标签</span><span class="pull-bottom">10</span></a><a class="author-info-articles-categories article-meta" href="/SecondBC/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/SecondBC">首页</a><a class="menu-item" href="/SecondBC/archives">归档</a><a class="menu-item" href="/SecondBC/categories">分类</a><a class="menu-item" href="/SecondBC/tags">标签</a><a class="menu-item" href="/SecondBC/about">关于</a></nav><div class="right-info"><a class="title-name" href="/SecondBC/">Second_BC の BloG</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">2024-强网拟态-easyre</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2024-10-20 | 更新于 2024-10-20</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/WriteUp/">WriteUp</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a></div></div></div><div class="main-content"><p>题目附件：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1qEbEZ_xdS33hOiExvLR7ng?pwd=3457">https://pan.baidu.com/s/1qEbEZ_xdS33hOiExvLR7ng?pwd=3457</a></p>
<p>一个exe程序，直接拖到ida里，发现没有main，很混乱，直接猜测上了自解密 + 混淆花指令；</p>
<p>根本看不到伪代码，硬啃汇编罢；</p>
<p><img src="https://s2.loli.net/2024/10/19/VeTkXKylxUfrWqR.png" alt="image.png"></p>
<p>不打算修，太多了，直接调，函数列表搜索scan，可以拿到库函数：</p>
<p><code>?scan_optional_field_width@?$format_string_parser@D@__crt_stdio_input@@AEAA_NXZ</code></p>
<p>在这个函数里打上断点，可以在输入内容的时候断下，然后一层一层的往上层函数断点测试：</p>
<p>可以找到最终的scanf调用实际上使用了下面这个函数：</p>
<p><code>??$?RV_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_@@AEAV_lambda_9a20e10065b92b5193c3597a66cba9d4_@@V_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_@@@?$__crt_seh_guarded_call@H@@QEAAH$$QEAV_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_@@AEAV_lambda_9a20e10065b92b5193c3597a66cba9d4_@@$$QEAV_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_@@@Z_1</code></p>
<p>也是一个库函数，接着这个函数往下走，可以走到一个神奇的地方，我称之为中转站，也是找到虚拟机的特征，操作码一类的东西：</p>
<p><img src="https://s2.loli.net/2024/10/19/h69QaCwx1WGSEv3.png" alt="image.png"></p>
<p>这个rax实际上就是一个操作码，每次都有不同的功能，在前几次调试测试会发现，第一次调用call之后，就会打印wrong flag；</p>
<p>而当rip在这个地方的时候往栈上看，能发现我们输入的内容：</p>
<p><img src="https://s2.loli.net/2024/10/19/guGxCEmTjIkatDB.png" alt="image.png"></p>
<p>对着我们输入的地址按x查看引用能找到一个地方，调过去能发现这是在到中转站之前就会执行的，再次调试能够知道实际上是在调用strlen函数，它将strlen给到rax，然后call rax，过了中转站之后第一次call就会打印wrong flag：</p>
<p><img src="https://s2.loli.net/2024/10/19/jc6D9WgYsKzfvA3.png" alt="image.png"></p>
<p>对着strlen再继续跟下去会得知flag长度是56；</p>
<p>如果长度是正确的，第一次call完之后，剩下的call就开始循环了，貌似在操作输入的字符串；</p>
<p>通过每三次call，可以发现它是一个动作，每三次rdx都会加2，当加到70h之后变成新的循环；</p>
<p>实际上也就是以56为一个循环，一共要循环两次，但是调试的时候发现第一次循环没有对输入的内容做修改，而第二次循环会对输入的内容替换为用7F去减去它本身的值（通过观察栈上的值）；</p>
<p>这56长度的循环结束之后，会有一个短循环，一共call 26次，第25次就会输出wrong flag，第26次进入结束程序；</p>
<p>通过调试可以发现，这26次里面，在对输入的内容进行分组加密，每8字节为一组，应该是电码本模式，因为56个a加密的东西分组的很明显：</p>
<p><img src="https://s2.loli.net/2024/10/19/cXvBj8Ps3hnSLfd.png" alt="image.png"></p>
<p>对8个字节的分组加密部分也是3次call为一个动作，一共执行21次，把7个分组都加密完，剩下的4次call很可能就是用来进行判断的；</p>
<p>跟踪剩下的call可以发现很难看，很多都是没用的跳转，所以结合着打上内存断点，可以找到如下内容：</p>
<p><img src="https://s2.loli.net/2024/10/20/mPKyVRCYDH13l4J.png" alt="WTJ4QTO33P_YL308F_A~_CJ.png"></p>
<p><img src="https://s2.loli.net/2024/10/19/VXWgaQypjDBuNCT.png" alt="image.png"></p>
<p>它会依次获取加密后的输入数据，以及比较数据？这个比较数据每次都在变化，然后进行比较，通过调试改值，可以一路改下去，然后就能够使得程序输出right flag的字符串，打到这个时候其实已经就很有信心能出了；</p>
<p>为什么直接引用outandin地方的地址不能直接x获取到这些被引用的地方呢？</p>
<p>是因为这个混淆做了一个表，它每次要获取地址的时候，都是用代码段上的立即数去加或者减这个表里的无意义的数据，得到一个可用的地址，这样就防止了地址引用的查询，但是还是逃不过内存断点；</p>
<p>使用如下ida的python脚本进行更改比对值且输出比较内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ea=get_reg_value(<span class="string">&quot;r8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ea))</span><br><span class="line">set_reg_value(ea, <span class="string">&quot;rdx&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对打印的内容进行整理拿到如下比较hex：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BE <span class="number">44</span> 7B 02 BA <span class="number">95</span> 4B 8C E3 A8 F1 <span class="number">90</span> FB CD A4 3C 2F EE 9E <span class="number">68</span> <span class="number">79</span> AA 6D ED <span class="number">85</span> B0 <span class="number">77</span> 2F <span class="number">27</span> 3F <span class="number">41</span> FF 1F C1 CF <span class="number">43</span> AA <span class="number">00</span> AC FA <span class="number">71</span> <span class="number">43</span> <span class="number">57</span> 09 <span class="number">51</span> BA F7 B2 <span class="number">67</span> <span class="number">96</span> <span class="number">52</span> <span class="number">47</span> A0 <span class="number">50</span> <span class="number">40</span> C7</span><br></pre></td></tr></table></figure>

<p>现在要做的就是查看分组加密算法了，回到当时加密的部分，一步一步的跟踪看过去，发现程序会去操作两个寄存器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">算法逻辑：</span><br><span class="line"></span><br><span class="line">ecx 给到12345678h 异或 ffffffff 与上 4C4CDB01 -&gt; 4C488901 xor ffffffff -&gt; B3B776FE</span><br><span class="line"></span><br><span class="line">eax 给到12345678h 加上 B3B324FE 异或 ffffffff -&gt; EDCFFB87</span><br><span class="line"></span><br><span class="line">ecx = ecx &amp; eax = A1877286 = B3B776FE &amp; EDCFFB87</span><br><span class="line"></span><br><span class="line">eax = ecx = ecx xor <span class="number">0xffffffff</span> = 5E788D79</span><br><span class="line"></span><br><span class="line">eax xor <span class="number">0xffffffff</span> = A1877286</span><br><span class="line"></span><br><span class="line">ecx = ecx &amp; 4CD6DA30 xor <span class="number">0xffffffff</span> = B3AF77CF -&gt; 12AE5749 -&gt; EDD9AEF6</span><br><span class="line"></span><br><span class="line">eax = eax &amp; 0B32925CF xor <span class="number">0xffffffff</span> = 5EFEDF79 xor ffff -&gt; ED51A8B6 -&gt; 8C1128B0 -&gt; 61C88646 -&gt;9E3779B9</span><br></pre></td></tr></table></figure>

<p>那最终经过一段又臭又长的小丑代码膨胀之后，你会拿到eax会变成 0x9e3779b9；</p>
<p>包是tea里面的delta，弟弟；</p>
<p>通过进一步调试我能拿到如下栈帧内容：</p>
<p>![CA_90Q9TYZ_HWLSL6`7G_P7.png](<a target="_blank" rel="noopener" href="https://s2.loli.net/2024/10/19/6YiXu1FlkUAH7Kr.png">https://s2.loli.net/2024/10/19/6YiXu1FlkUAH7Kr.png</a>)</p>
<p>能够拿到key和轮次，那么直接把三个tea都拿来试，试完可以发现是xtea（不是tea和xxtea）；</p>
<p>写逆运算，直接拿到不可见字符，太棒了，我逐渐理解一切；</p>
<p>思考是否是因为有反调试在搞我，于是尝试用ida附加进程，发现附加不上，很大可能；</p>
<p>拿CE进行附加调试，可以发现最终的比较数据发生了变化，同时我们输入计算的结果也发生了变化（千万别用其他算法搞我）：</p>
<p><img src="https://s2.loli.net/2024/10/19/CtOgy8v3PQw9LVG.png" alt="JZ81HWGQQY2TIY_OW_XVFJB.png"></p>
<p>第一个思路是找idata段（iat表）用到了反调试的哪些函数，可以找到疑似的如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.idata:<span class="number">00007F</span>F704979060 <span class="number">20</span> <span class="number">7F</span> B1 DD F8 <span class="number">7F</span> <span class="number">00</span> <span class="number">00</span>       IsDebuggerPresent </span><br><span class="line">.idata:<span class="number">00007F</span>F704979038 <span class="number">00</span> <span class="number">11</span> B1 DD F8 <span class="number">7F</span> <span class="number">00</span> <span class="number">00</span>       GetSystemTimeAsFileTime</span><br></pre></td></tr></table></figure>

<p>对其进行x引用反查并下断点，能够发现不是他们的原因（不会断下来）；</p>
<p>接着对ida里进行search，搜索字节块，直接搜索hex 60 （对于静态反调试而言，PEB结构很重要，32位是fs:30 64位是gs:60）</p>
<p>然后在搜索的结果里ctrl+f筛选gs，果然给找到了：</p>
<p><img src="https://s2.loli.net/2024/10/19/sgH7oiZNAUzGcPW.png" alt="image.png"></p>
<p>之后在这里给下个断点，ida调试一启动程序就到这里来，先把eax改成0，然后把上面一条句子改成xor eax,eax nop nop；</p>
<p>就可以不用管这个地方了；</p>
<p>之后还是一样的调试，能够发现第一轮56长度循环的时候对输入做改动了，对输入的每个字节进行加40h，第二轮循环还是老样子，分组tea也是老样子（还好没变，变了我要把出题人给草草了），然后比较的数据也变了，内容就是ce里面的，说明ce附加调试是正确的数据，用之前的方法再提一遍数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1 e3 <span class="number">51</span> <span class="number">98</span> <span class="number">86</span> <span class="number">56</span> <span class="number">76</span> <span class="number">49</span> 6f 6b 2b <span class="number">81</span> cf ce <span class="number">12</span> <span class="number">96</span> a2 <span class="number">70</span> <span class="number">35</span> 3c <span class="number">31</span> <span class="number">62</span> 5c f1 fa <span class="number">77</span> 6b aa 9e 6d 05 be e8 <span class="number">24</span> a4 f8 db <span class="number">23</span> 3a 0b <span class="number">16</span> <span class="number">20</span> cc 03 ad b5 2b a9 <span class="number">34</span> 9f <span class="number">78</span> 1d 2e b9 f9 9e</span><br></pre></td></tr></table></figure>

<p>这次数据就是正确的了；</p>
<p>反思：拿到怪玩意儿先找反调试，不然后期恶心死我；</p>
<p>之后写脚本进行flag获取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DWORD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">teaE</span><span class="params">(DWORD* EntryData, DWORD* Key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span></span><br><span class="line">    DWORD x = EntryData[<span class="number">0</span>];</span><br><span class="line">    DWORD y = EntryData[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    DWORD sum = <span class="number">0</span>;</span><br><span class="line">    DWORD delta = <span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="comment">//总共加密32轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x66</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += delta;</span><br><span class="line">        x += ((y &lt;&lt; <span class="number">4</span>) + Key[<span class="number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="number">5</span>) + Key[<span class="number">1</span>]);</span><br><span class="line">        y += ((x &lt;&lt; <span class="number">4</span>) + Key[<span class="number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="number">5</span>) + Key[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d轮：v0: %x v1: %x\n&quot;</span>, i, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后加密的结果重新写入到数组中</span></span><br><span class="line">    EntryData[<span class="number">0</span>] = x;</span><br><span class="line">    EntryData[<span class="number">1</span>] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xteaE</span><span class="params">(DWORD v[<span class="number">2</span>], DWORD <span class="keyword">const</span> key[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    DWORD v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>], sum = <span class="number">0</span>, delta = <span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x66</span>; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        <span class="comment">//if (i == 0)</span></span><br><span class="line">            <span class="comment">//printf(&quot;%d轮：v0: %x v1: %x\n&quot;, i, v0, v1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = v0; v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MX (((z&gt;&gt;5^y<span class="meta-string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(DWORD* v, <span class="keyword">int</span> n, DWORD <span class="keyword">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD y, z, sum;</span><br><span class="line">    <span class="keyword">unsigned</span> p, rounds, e;</span><br><span class="line">   </span><br><span class="line">    rounds = <span class="number">0x66</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    z = v[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += DELTA;</span><br><span class="line">        e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            y = v[p + <span class="number">1</span>];</span><br><span class="line">            z = v[p] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        z = v[n - <span class="number">1</span>] += MX;</span><br><span class="line">        <span class="keyword">if</span> (rounds == <span class="number">0x66</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d轮：v0: %x v1: %x\n&quot;</span>, rounds, y, z);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--rounds);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这三个都是在尝试</span></span><br><span class="line"><span class="comment">//比较数据</span></span><br><span class="line"><span class="comment">//unsigned int ans[14] = &#123;  假的，出生</span></span><br><span class="line"><span class="comment">//    0x027B44BE, 0x8C4B95BA, 0x90F1A8E3, 0x3CA4CDFB, 0x689EEE2F, 0xED6DAA79, 0x2F77B085, 0xFF413F27,</span></span><br><span class="line"><span class="comment">//   0x43CFC11F, 0xFAAC00AA, 0x09574371, 0xB2F7BA51, 0x47529667, 0xC74050A0</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ans[<span class="number">14</span>] = &#123;</span><br><span class="line">    <span class="number">0x9851E3A1</span>, <span class="number">0x49765686</span>, <span class="number">0x812B6B6F</span>, <span class="number">0x9612CECF</span>, <span class="number">0x3C3570A2</span>, <span class="number">0xF15C6231</span>, <span class="number">0xAA6B77FA</span>, <span class="number">0xBE056D9E</span>,</span><br><span class="line">    <span class="number">0xF8A424E8</span>, <span class="number">0x0B3A23DB</span>, <span class="number">0x03CC2016</span>, <span class="number">0xA92BB5AD</span>, <span class="number">0x1D789F34</span>, <span class="number">0x9EF9B92E</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unsigned char ans[] = &quot;\xde\xde\xde\xde\xde\xde\xde\xde&quot;;</span></span><br><span class="line"><span class="comment">//DWORD res[] = &#123; 0x027B44BE ,0x8C4B95BA &#125;;</span></span><br><span class="line"><span class="comment">//DWORD k[4] = &#123; 2,2,3,4 &#125;;</span></span><br><span class="line"></span><br><span class="line">DWORD k[<span class="number">4</span>] = &#123; <span class="number">0xEF6FD9DB</span>, <span class="number">0xD2C273D3</span>, <span class="number">0x6F97E412</span>, <span class="number">0x72BFD624</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xteaD</span><span class="params">(DWORD v[<span class="number">2</span>], DWORD <span class="keyword">const</span> key[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    DWORD v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>], delta = <span class="number">0x9E3779B9</span>, sum = delta * <span class="number">0x66</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x66</span>; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = v0; v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// printf(&quot;%x %x\n&quot;, ((DWORD*)ans)[0], ((DWORD*)ans)[1]);</span></span><br><span class="line">    <span class="comment">//xteaE((DWORD*)ans,k);</span></span><br><span class="line">    <span class="comment">//xxtea((DWORD*)datas,2, k);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;%x %x\n&quot;, ((DWORD*)ans)[0], ((DWORD*)ans)[1]);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">xteaD</span>((DWORD*)&amp;(((DWORD*)ans)[i]), k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* str = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">56</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">56</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((<span class="number">0x7f</span> - str[i])- <span class="number">0x40</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%x&quot;, ans[2]);</span></span><br><span class="line">    <span class="comment">//DWORD sum = 0;</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; 0x66; i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    sum += DELTA;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//printf(&quot;%x&quot;, sum);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后拿到flag：flag{u_ar3_re@11y_g00d_@t_011vm_de0bf_and_anti_debugger}</p>
<p>草草了，ollvm，还是第一次见混淆之后的程序，太抽象了，有一种vmp的美，给我搞了一天，难绷；</p>
<p>根据flag可以知道有一个deobf的工具应该可以有效去除ollvm的混淆，之后可以研究来看看；</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Second_BC</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://secondbc.github.io/SecondBC/2024/10/20/2024-%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81-easyre/">https://secondbc.github.io/SecondBC/2024/10/20/2024-%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81-easyre/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://secondbc.github.io/SecondBC">Second_BC の BloG</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2024/10/07/%E9%A9%B1%E5%8A%A8obcallback%E5%8F%8D%E9%99%84%E5%8A%A0%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/"><span>驱动obcallback反附加的一次尝试</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2022 ～ 2024 By Second_BC</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/copy.js"></script><!--script(src=url)--></body></html>