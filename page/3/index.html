<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords"><meta name="author" content="Second_BC,undefined"><meta name="copyright" content="Second_BC"><title>【Second_BC の BloG】</title><link rel="stylesheet" href="/SecondBC/css/fan.css"><link rel="stylesheet" href="/SecondBC/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/SecondBC/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/SecondBC/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/SecondBC/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/SecondBC/atom.xml" title="Second_BC の BloG" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/SecondBC/ss.jpg"></div><div class="author-info-name">Second_BC</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/" target="_blank">GitHub<i class="icon-dot bg-color0"></i></a><a class="links-button button-hover" href="mailto:1" target="_blank">E-Mail<i class="icon-dot bg-color10"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color7"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/SecondBC/archives"><span class="pull-top">日志</span><span class="pull-bottom">39</span></a><a class="author-info-articles-tags article-meta" href="/SecondBC/tags"><span class="pull-top">标签</span><span class="pull-bottom">10</span></a><a class="author-info-articles-categories article-meta" href="/SecondBC/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/SecondBC">首页</a><a class="menu-item" href="/SecondBC/archives">归档</a><a class="menu-item" href="/SecondBC/categories">分类</a><a class="menu-item" href="/SecondBC/tags">标签</a><a class="menu-item" href="/SecondBC/about">关于</a></nav><div class="right-info"><a class="title-name" href="/SecondBC/">Second_BC の BloG</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/11/06/2022-syc-bin%E4%BA%8C%E9%9D%A2/">2022-syc-bin二面</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-11-06</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Syc/">Syc</a></div></div><div class="post-content"><div class="main-content content"><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><blockquote>
<p>逆向一个虚拟机，编写适应于其的二进制文件，实现tea算法；</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/10/31/XlNWK2jqOH4iMDv.png" alt="main"></p>
<p>上图左侧为main函数，逻辑就是读取名称 “binary” 的内容，然后将其赋给code，之后将code扔进vm函数充当指令集；</p>
<p>每条指令分三个数值，一个指令数，两个操作数，分别给了instru和One，Two变量；</p>
<p>根据输入不同的instru变量来调用不同的函数，这些函数就是指令执行的操作了，翻译如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">code[<span class="number">8</span>] 是计数器 -&gt; i</span><br><span class="line"></span><br><span class="line">code[<span class="number">9</span>] 是flag 控制数</span><br><span class="line"></span><br><span class="line">code[<span class="number">7</span>] 是栈针</span><br><span class="line"></span><br><span class="line">code[<span class="number">6</span>] 用于实现加法</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">    </span><br><span class="line"><span class="number">0</span> code[one] = two 	++i</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = one	 ++code[<span class="number">7</span>]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = code[one]	++code[<span class="number">7</span>]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = code[<span class="number">8</span>] + <span class="number">1</span>	++code[<span class="number">7</span>]	code[<span class="number">8</span>] = one</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> code[one] = code[two]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> code[<span class="number">8</span>] = one</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> code[one + <span class="number">10</span> + code[<span class="number">6</span>]] += code[two] 	++i</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> code[one] = code[code[<span class="number">6</span>] + <span class="number">10</span> + two]	++i</span><br><span class="line"></span><br><span class="line"><span class="number">8</span> code[one] &lt; &lt; = two	++i</span><br><span class="line"></span><br><span class="line"><span class="number">9</span> code[one] &gt; &gt; = two	++i</span><br><span class="line"></span><br><span class="line">a code[one] += code[two + <span class="number">10</span> + code[<span class="number">6</span>]]	++i</span><br><span class="line"></span><br><span class="line">b code[one] ^= code[two]	++i</span><br><span class="line"></span><br><span class="line">c <span class="keyword">if</span>( !code[<span class="number">9</span>] ) -&gt; code[<span class="number">8</span>] = one ; <span class="keyword">else</span> ++i</span><br><span class="line"></span><br><span class="line">d end</span><br><span class="line"></span><br><span class="line">e <span class="keyword">if</span>(two &lt; = code[one + <span class="number">10</span> + code[<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">​	&#123;	</span><br><span class="line"></span><br><span class="line">​		<span class="keyword">if</span>(two = code[one + <span class="number">10</span> + code[<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">​				code[<span class="number">9</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">​		<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">​				code[<span class="number">9</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">else</span> -&gt; code[<span class="number">9</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">​	++i</span><br><span class="line"></span><br><span class="line">f --code[<span class="number">7</span>]	code[one] = code[code[<span class="number">7</span>] + <span class="number">10</span>] ++i</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> --code[<span class="number">7</span>]	code[<span class="number">8</span>] = code[code[<span class="number">7</span>] + <span class="number">10</span>] ++i</span><br><span class="line"></span><br><span class="line"><span class="number">11</span> code[code[<span class="number">6</span>] + <span class="number">10</span> + one] += two	++i</span><br><span class="line"></span><br><span class="line"><span class="number">12</span> code[code[<span class="number">6</span>] + <span class="number">10</span> + one] += code[code[<span class="number">6</span>] + <span class="number">10</span> + two]   ++i</span><br><span class="line"></span><br><span class="line"><span class="number">13</span> code[one] = cin	++i</span><br><span class="line"></span><br><span class="line"><span class="number">14</span> cout code[one]   ++i</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">	所以<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>都表示入栈，<span class="number">3</span>表示call因为改变了计数器；f，<span class="number">10</span>表示出栈，<span class="number">10</span>表示<span class="keyword">return</span>；</span><br></pre></td></tr></table></figure>

<p> 由此对照机械码手撸汇编：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋初值</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>	<span class="number">6</span> <span class="number">32</span>			mov reg6, <span class="number">50</span>			</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">11223344</span>		push <span class="number">11223344</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">22334455</span>		push <span class="number">22334455</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">33445566</span>		push <span class="number">33445566</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">44556677</span>		push <span class="number">44556677</span>h</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环输入</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>	<span class="number">0</span> <span class="number">0</span>				add reg60, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">tag1:</span><br><span class="line"></span><br><span class="line"><span class="number">13</span>	<span class="number">0</span>				mov reg0, cin</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>	<span class="number">0</span>				push [reg0]</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>	<span class="number">0</span> <span class="number">1</span>				add reg60, <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e	<span class="number">0</span> <span class="number">4</span>				cmp reg60, <span class="number">4</span>	</span><br><span class="line"></span><br><span class="line">c	<span class="number">43</span>				jnz	tag1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用cry以及输出</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>	<span class="number">4</span>E				call cry</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">0</span>				mov cout, reg0</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">1</span>				mov cout, reg1</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">2</span>				mov cout, reg2</span><br><span class="line"></span><br><span class="line"><span class="number">14</span>	<span class="number">3</span>				mov cout, reg3</span><br><span class="line"></span><br><span class="line">d						retn</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//cry实现</span></span><br><span class="line"></span><br><span class="line">cry:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>	<span class="number">9E3779</span><span class="function">B9		push	<span class="title">delta</span>	<span class="params">(push后code[<span class="number">7</span>] = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// v[4]</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	0 E				mov 	reg0, [esp + 6]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	1 F				mov 	reg1, [esp + 5]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	2 10			mov 	reg2, [esp + 4]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4	3 11			mov 	reg3, [esp + 3]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//循环</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">0	3C 0				mov reg60, 0	</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">11	0 0					add reg60, 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">tag2:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//sum</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">1</span> <span class="number">13</span>				add reg61, [esp + <span class="number">2</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">1</span>				mov reg62, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> A					add reg62, [esp + a]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">1</span>				mov reg63, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">1</span>				mov reg64, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> B					add reg64, [esp + <span class="number">9</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">0</span>					add reg62, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">0</span> <span class="number">3</span>E				mov reg0,  reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">0</span>				mov reg62, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> C					add reg62, [esp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">0</span>				mov reg63, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">0</span>				mov reg64, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> D					add reg64, [esp + <span class="number">7</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">1</span>					add reg62, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">1</span> <span class="number">3</span>E				mov reg1 reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">3</span>				mov reg62, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> A					add reg62, [esp + a]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">3</span>				mov reg63, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">3</span>				mov reg64, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> B					add reg64, [esp + <span class="number">9</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">2</span>					add reg62, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">2</span> <span class="number">3</span>E				mov reg2 reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span>E <span class="number">2</span>				mov reg62, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span>	<span class="number">3</span>E <span class="number">4</span>				shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> C					add reg62, [esp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3F</span> <span class="number">2</span>				mov reg63, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">3</span> <span class="number">3</span>D				add reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">40</span> <span class="number">2</span>				mov reg64, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span>	<span class="number">40</span> <span class="number">5</span>				shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">4</span> D					add reg64, [esp + <span class="number">7</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">3F</span>				xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b	<span class="number">3</span>E <span class="number">40</span>				xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span>	<span class="number">2</span> <span class="number">3</span>					add reg62, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span>	<span class="number">3</span> <span class="number">3</span>E				mov reg3,  reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">11</span>	<span class="number">0</span> <span class="number">1</span>					add reg60, <span class="number">1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">e	<span class="number">0</span> <span class="number">20</span>				cmp reg60, <span class="number">32</span>			</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">c	<span class="number">55</span>					jnz	tag2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">f	<span class="number">13</span>					pop delta</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">10</span>						retn</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>没实现栈平衡，不过芜锁胃；反正最后return回去输出就行；</p>
<p>注意：写二进制文件时用小端序，而且以DWORD为基本单位，并以3个DWORD对齐，比如 <code>c 55</code> 写成：<code>0c 00 00 00 55 00 00 00 00 00 00 00</code> ;</p>
<p>还有个问题，根据调试，每次第一条指令开始是code[8] = 3C; 所以二进制文件需要填充垃圾信息，填多少？第一幅图中instru = code[3 * code[8] + 1010], 所以 括号里的内容为 ： 1190 ；而写二进制文件需要以DWORD为单位，所以需要填充 1190 * 4 个 00 ；</p>
<p>通过：</p>
<p><img src="https://s2.loli.net/2022/10/31/p5qd2NZMrHelwa3.png" alt="pass"></p>
<h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><p>ida：</p>
<p><img src="https://s2.loli.net/2022/11/01/X83ejBp4Tx6KRGE.png" alt="main"></p>
<p>调试可以发现main挂不上，然后就发现旁边的函数长得和main都差不多，一个一个断点试，找到第三个是真正的main函数；</p>
<p>主要思路就是输入15个内容，进行异或和加运算，然后和v4开始的数据比较；</p>
<p>写出逆运算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> buf[<span class="number">15</span>] = &#123;</span><br><span class="line">    <span class="number">0x04</span>, <span class="number">0x46</span>, <span class="number">0x81</span>, <span class="number">0x63</span>, <span class="number">0x14</span>, <span class="number">0x53</span>, <span class="number">0x17</span>, <span class="number">0x6D</span>, <span class="number">0x6A</span>, <span class="number">0x67</span>, <span class="number">0x76</span>, <span class="number">0x16</span>, <span class="number">0x34</span>, <span class="number">0x14</span>, <span class="number">0x34</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> v0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; ++i)	<span class="comment">//自加v0到加密完状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            v0++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v0--;		<span class="comment">//多加一个减掉</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">14</span>; i &gt;= <span class="number">0</span>; --i)		<span class="comment">//逆</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] -= v0--;</span><br><span class="line">            buf[i] ^= i ^ j ^ <span class="number">0x32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">15</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag：<strong>SYC{0h_y0u1_finD0V0}</strong></p>
<h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><p>ida：</p>
<p><img src="https://s2.loli.net/2022/11/01/sXh8FmTYcDK6bUw.png" alt="main"></p>
<p>进去之后第一感觉会发现main是个scanf函数，但是点进去之后会发现这个东西，让调试才能查看代码；点进这个函数之后会发现是个线程创建，注意调试时改变if判断的变量值为1；</p>
<p>在线程中可以发现以下代码：</p>
<p><img src="https://s2.loli.net/2022/11/01/fKCjik9e7dcswoZ.png" alt="thread"></p>
<p>在thread main 函数里有两个函数：check() 和 encrypt() ；</p>
<p>check一开始就执行，判断长度，以及输入的内容必须为数字；</p>
<p>encrypt读入key和输入的数据，将数据前12位与key加密运算；</p>
<p>最后比较数据；</p>
<p>写出encrypt的逆向算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (key[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            v4 += <span class="number">23</span>;		<span class="comment">//无用</span></span><br><span class="line">            v3 ^= <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            us[i] ^= key[i];	<span class="comment">//不变</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">161</span>:</span><br><span class="line">            us[i] -= <span class="number">2</span> * key[i];		<span class="comment">//减等</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">196</span>:</span><br><span class="line">            us[i] -= <span class="number">10</span>;		<span class="comment">//减等</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">229</span>:</span><br><span class="line">            <span class="comment">//v3 = 8 * ((v4 + 6) &gt;&gt; (v4 &amp; 3));		无用</span></span><br><span class="line">            us[i] = <span class="built_in">inter</span>(us[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inter</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将比较数据经过以上运算得到flag：<strong>SYC{03062639056784}</strong></p>
<h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><p>ida进去可以发现是加壳了，函数很少；</p>
<p>打开二进制格式搜索upx，果然就找到了老朋友：</p>
<p><img src="https://s2.loli.net/2022/11/01/4qWFzD8ngvBEXOl.png" alt="unpack"></p>
<p>upx加壳的标识码是 UPX! 全大写，拿不准改哪个就全部 Upx 都改成 UPX；</p>
<p>改完就可以脱壳了；</p>
<p>看代码：</p>
<p><img src="https://s2.loli.net/2022/11/01/OoUJV9mjlkSLMs1.png" alt="main"></p>
<p>看不懂子进程作用，反正主要内容在父进程里：输入内容后，先进入change函数，把4个4个的char内容放到4单位的int里；然后把这个int数组放到xor函数里，把每个字节都和j做异或运算，最后和v19比较数据，v19的内容就是cpy的16长度的字符串；</p>
<p>异或的逆运算还是异或，写出复原代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i = i + <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            we[i] = we[i] ^ j;</span><br><span class="line">            we[i + <span class="number">1</span>] = we[i + <span class="number">1</span>] ^ (j + <span class="number">1</span>); </span><br><span class="line">            we[i + <span class="number">2</span>] = we[i + <span class="number">2</span>] ^ (j + <span class="number">2</span>);</span><br><span class="line">            we[i + <span class="number">3</span>] = we[i + <span class="number">3</span>] ^ (j + <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将逆向得到的cpy字符串带入we得到flag：<strong>SYC{0k_y0u_s0lv3_it_}</strong></p>
<h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><p>这道题缺库不能调，直接看静态；</p>
<p>ida:</p>
<p><img src="https://s2.loli.net/2022/11/01/JosKVDhp8uG6CzZ.png" alt="main"></p>
<p>左图main函数，右图rc4函数，将enter用rc4加密了,密钥是 <code>syclover:)</code>；</p>
<p>使用大厨把enter加密后的内容烤出来：（<a target="_blank" rel="noopener" href="https://gchq.github.io/CyberChef/">CyberChef (gchq.github.io)</a>）</p>
<p><img src="https://s2.loli.net/2022/11/01/eG14IYzog8ibysc.png" alt="chef"></p>
<p>发现开头是ELF，说明这加密出来的内容是个elf文件，将其写入二进制文件再用ida打开：</p>
<p><img src="https://s2.loli.net/2022/11/02/AUOTdGoit1JLp3c.png" alt="main"></p>
<p>属于就正常了；</p>
<p><img src="https://s2.loli.net/2022/11/02/JItDwv6UbOjHkKZ.png" alt="func"></p>
<p>如上可知，输入16长度内容，然后进行tea算法(小魔改，每次异或了i)，之后比较数据；</p>
<p>写出逆算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>  j = <span class="number">0</span>,l , r ,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">4</span>] = &#123; <span class="number">0x6A318EC6</span> , <span class="number">0x5B898EC2</span> , <span class="number">0x42FB5DD1</span> , <span class="number">0x50AC4C5F</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">4</span>] = &#123;<span class="number">0x11</span> , <span class="number">0x22</span> , <span class="number">0x33</span> , <span class="number">0x44</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">	l = v[j];</span><br><span class="line">	r = v[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">		sum += DELTA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= (k[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>] + sum) ^ (((l &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * l)) + l) ^ i;</span><br><span class="line">		sum -= DELTA;</span><br><span class="line">		l -= (k[sum &amp; <span class="number">3</span>] + sum) ^ (((r &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * r)) + r) ^ i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v[j] = l;</span><br><span class="line">	v[j + <span class="number">1</span>] = r;</span><br><span class="line"></span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	j += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">p = (<span class="keyword">char</span> *)v;</span><br><span class="line">p[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);</span><br></pre></td></tr></table></figure>

<p>得到flag：<strong>SYC{w3f-2hs-ij7-9is}</strong></p>
<h3 id="调试GLIBC-2-34小技巧"><a href="#调试GLIBC-2-34小技巧" class="headerlink" title="调试GLIBC_2.34小技巧"></a>调试GLIBC_2.34小技巧</h3><h4 id="安装glibc-all-in-one"><a href="#安装glibc-all-in-one" class="headerlink" title="安装glibc-all-in-one"></a>安装glibc-all-in-one</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone https://github.com/matrix1001/glibc-all-in-one.git </span><br><span class="line">cd glibc-all-in-one/</span><br><span class="line">sudo python3 update_list</span><br></pre></td></tr></table></figure>

<p>下载glibc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./download 2.35-0ubuntu3_amd64</span><br></pre></td></tr></table></figure>



<h4 id="安装patchelf"><a href="#安装patchelf" class="headerlink" title="安装patchelf"></a>安装patchelf</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NixOS/patchelf.git</span><br><span class="line">cd patchelf</span><br><span class="line">sudo apt-get install autoconf automake libtool</span><br><span class="line">./bootstrap.sh </span><br></pre></td></tr></table></figure>

<p>继续：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>



<h4 id="配置ld-so"><a href="#配置ld-so" class="headerlink" title="配置ld.so"></a>配置ld.so</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter path/to/.so the/elf/you/debug</span><br></pre></td></tr></table></figure>



<h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-rpath path/to/.so the/elf/you/debug</span><br></pre></td></tr></table></figure>



<h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><blockquote>
<p>逆向一个CPP服务器，得到flag，并编写socket客户端和远程服务器提交flag;</p>
</blockquote>
<h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p>ida查看服务器：</p>
<p><img src="https://s2.loli.net/2022/11/03/TcL4DovPZhJQiCK.png" alt="main"></p>
<p>这是一个服务端框架，首先创建套接字类型文件，并返回fd文件饰描述符；</p>
<p>然后和IP端口进行绑定；</p>
<p>之后一直监听这个端口，直到接收客户端请求，执行处理，并且是多线程的处理；</p>
<p>而处理的主体在 CTask_server 里可以找到：</p>
<p><img src="https://s2.loli.net/2022/11/03/5fXqzLwCBQjFG74.png" alt="true"></p>
<p>先发送 “Please …” (send) 到客户端，然后等待输入，被inside变量接收，之后进入cc加密，和tt生成的v7进行比较数据；</p>
<p>看看里面加密吧，都tea ptsd了，不想放图了；直接来吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>  j = <span class="number">0</span>, l, r, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">3</span>] = &#123; <span class="number">0xED3E9980</span> , <span class="number">0x57284856</span> ,<span class="number">0</span> &#125;;		<span class="comment">//从tt里抄的</span></span><br><span class="line"><span class="keyword">int</span> k[<span class="number">4</span>] = &#123; <span class="number">0x6C</span> , <span class="number">0x30</span> , <span class="number">0x76</span> , <span class="number">0x33</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = v[<span class="number">0</span>];</span><br><span class="line">r = v[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">	sum += DELTA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)		<span class="comment">//小魔改tea</span></span><br><span class="line">&#123;</span><br><span class="line">	r -= ((l &gt;&gt; <span class="number">5</span>) + k[<span class="number">3</span>]) ^ (l + sum) ^ (<span class="number">16</span> * l + k[<span class="number">2</span>]) ^ i;</span><br><span class="line">	l -= ((r &gt;&gt; <span class="number">5</span>) + k[<span class="number">1</span>]) ^ (r + sum) ^ (<span class="number">16</span> * r + k[<span class="number">0</span>]) ^ i;</span><br><span class="line">	sum -= DELTA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>] = l;</span><br><span class="line">v[<span class="number">1</span>] = r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span>*)v;</span><br><span class="line">p[<span class="number">9</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);</span><br></pre></td></tr></table></figure>

<p>得到flag：<strong>D0Y0uKSk</strong></p>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>如同服务端，自己写的客户端也需要一个框架，然后把发送的flag放到主体里就行；</p>
<p>根据题目中的链接，可以知道客户端只需要使用socket创建套接字后通过ip端口连接就行；</p>
<p>那么大概的框架就是： socket() -&gt; 结构地址 -&gt; connect() 连接到地址 -&gt; 读 &amp; 写 -&gt; close() 结束;</p>
<p>内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client Start\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = socket(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);               <span class="comment">//逆向得到的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> lines[] = <span class="string">&quot;D0Y0uKSk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>               <span class="comment">//套接字结构地址</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;             <span class="comment">//IPv4</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;1.14.92.115&quot;</span>);   <span class="comment">//地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);           <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connecting..\n&quot;</span>);</span><br><span class="line">    connect(fd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));   <span class="comment">//接通accept</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done !\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>];       				 	<span class="comment">//回响容器</span></span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, lines);</span><br><span class="line">    write(fd, lines, <span class="keyword">sizeof</span>(lines) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://s2.loli.net/2022/11/03/BGqOMS58xpjtnrb.png" alt="pass"></p>
<h3 id="更多socket学习"><a href="#更多socket学习" class="headerlink" title="更多socket学习"></a>更多socket学习</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37947204/article/details/80489431">https://blog.csdn.net/m0_37947204/article/details/80489431</a></p>
<h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><blockquote>
<p>给二进制加载器实现更多功能：1、转储节内容 2、输出数据符号 3、使用capstone反汇编.text段；</p>
</blockquote>
<p>称之为环境恶心人之题；</p>
<p>题不难，但在wsl上装环境会变得千奇百怪，反正就是跑不起来，只有vm搞；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo</span><br><span class="line">apt-get install binutils-dev</span><br><span class="line">apt-get install libcapstone-dev</span><br></pre></td></tr></table></figure>

<p>完成这道题需要知晓一点点bfd和capstone，以及更多的模仿；</p>
<p>注意引头 bfd.h 和 capstone/capstone.h；</p>
<p>题目已经把各种各样的代码都实现好了，只要求增添几个功能，逐一实现：</p>
<h3 id="转储节内容"><a href="#转储节内容" class="headerlink" title="转储节内容"></a>转储节内容</h3><p>这里要求命令行输入三个参数，而第三个参数为节名称，并打印节的原始字节；</p>
<p>那么可以在原来打印节的地方（main.cc）镶嵌一个东西进去：</p>
<p><img src="https://s2.loli.net/2022/11/06/FlkOx8SRGnKYqjM.png" alt="one"></p>
<p>flag一开始设置为0，找到同名节后设置为1；</p>
<p>第一个判断是否有三个参数并且调控数为0，则执行这个函数；</p>
<p>外面的判断是如果没有找到第三个参数一样的节名称，则此时flag依然是0，所以执行打印没有找到；</p>
<p>下面是函数具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_origin_bytes</span><span class="params">(Section* sec, <span class="keyword">char</span> *one)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sec-&gt;name == one)		<span class="comment">//找到同名则进入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;contents of %s section\n&quot;</span>, one);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; i++)		<span class="comment">//打印开头的 00~0f</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%02jx &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(j &lt; sec-&gt;size)    <span class="comment">//循环打印</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02jx &quot;</span>, sec-&gt;bytes[j++]);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">16</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;			<span class="comment">//设置flag为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出数据符号"><a href="#输出数据符号" class="headerlink" title="输出数据符号"></a>输出数据符号</h3><p>找到 loader.h 中的symbol类，可以发现 SymbolType 里面只有  SYM_TYPE_UKN SYM_TYPE_FUNC 两个，需要打印 DATA 符号，则添加一个 <code>SYM_TYPE_DATA = 2,</code> ;</p>
<p>之后找到 loader.cc 中的一个函数：load_symbol_bfd，可以发现其中有一步是给函数添加 FUNC项的，镶嵌如下内容：</p>
<p><img src="https://s2.loli.net/2022/11/06/8uVxkC31FnlgLrT.png" alt="two"></p>
<p>当不添加FUNC项的内容时，添加DATA就好了；</p>
<p>最后改变下main.cc里面打印符号的地方为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %-40s 0x%016jx %s\n&quot;</span>,</span><br><span class="line">                   sym-&gt;name.<span class="built_in">c_str</span>(),</span><br><span class="line">                   sym-&gt;addr,</span><br><span class="line">                   (sym-&gt;type &amp; Symbol::SYM_TYPE_FUNC) ? <span class="string">&quot;FUNC&quot;</span> : <span class="string">&quot;DATA&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="使用capstone反汇编-text段"><a href="#使用capstone反汇编-text段" class="headerlink" title="使用capstone反汇编.text段"></a>使用capstone反汇编.text段</h3><p>吐槽一下，edge搜索capstone 反汇编会出现一个博客，详细的记录了如何使用capstone；</p>
<p>具体函数实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">disass_text</span><span class="params">(Binary bin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    csh dis;</span><br><span class="line">    cs_insn *insns;</span><br><span class="line">    Section *text;</span><br><span class="line">    <span class="keyword">size_t</span> n, i;</span><br><span class="line">    Section* sec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取text节</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; bin.sections.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sec = &amp;bin.sections[i];</span><br><span class="line">        <span class="keyword">if</span>(sec-&gt;name == <span class="string">&quot;.text&quot;</span>)</span><br><span class="line">            text = sec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!text)   <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化capstone</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cs_open</span>(CS_ARCH_X86, CS_MODE_64, &amp;dis) != CS_ERR_OK)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反汇编把内容放insns里； （ 返回0就是版本问题 （（</span></span><br><span class="line">    n = <span class="built_in">cs_disasm</span>(dis, text-&gt;bytes, text-&gt;size, text-&gt;vma, <span class="number">0</span>, &amp;insns);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;disassembly of .text section:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016jx\t%s\t\t%s\n&quot;</span>, insns[i].address, insns[i].mnemonic, insns[i].op_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cs_free</span>(insns,n);</span><br><span class="line">    <span class="built_in">cs_close</span>(&amp;dis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;err\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main.cc的打印节后一部分调用就好了；</p>
<p>通过：</p>
<p><img src="https://s2.loli.net/2022/11/06/v6ESOF5znQ2khu7.png" alt="pass"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纯粹对今年的有兴趣，5和7都比较新鲜，也是第一次手撸汇编了解bfd库，还挺有意思；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/11/06/2022-syc-bin%E4%BA%8C%E9%9D%A2/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/28/C++%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/">C++学习日记</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-28</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Cpp/">Cpp</a></div></div><div class="post-content"><div class="main-content content"><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><code>namespace NameSpace&#123;&#125;</code>，为解决变量以及函数重名而出现；</p>
<p>只能在全局中声明，可以嵌套，使用<code>NameSpace::Items</code>，调用内容；</p>
<p>可以在函数开头用 <code>using NameSpace::Items</code>，来声明引用内容，或者用 <code>using namespace NameSpace</code>，来声明引用全部内容；</p>
<p>可以匿名，引用内容则为<code>::Items</code>，等效于全局内容；</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>定义的时候就需要赋值：<code>int &amp;ra = a;</code> ，前面加地址符号，意义是使得ra和a共享地址（取个别名）；</p>
<p>数组定义时记得加括号明确计算意义：<code>int (&amp;ra)[10] = a[10]</code> ；</p>
<p>类似指针，函数传参时可以间接影响外部变量，并且返回时不能返回局部变量，因为是一个地址，内容会发生改变；</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>int &amp;ra = a </code>  等价于 <code>int * const ra = &amp;a</code> ；</p>
<p>目的为了简化源码理解，不需要构造多级指针，传参时传入引用可以体现出改变外部变量的意思；</p>
<h2 id="面向对象与类"><a href="#面向对象与类" class="headerlink" title="面向对象与类"></a>面向对象与类</h2><p>特征：封装，继承，多态；</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>将一类的函数和数据装在一个类里，设置私有数据域，和公共方法称为<strong>封装</strong>；</p>
<p>结构体等同于类，类里的对象拥有<strong>属性</strong>（数据），<strong>行为</strong>（函数），以及<strong>构造函数</strong>（初始化数据的函数，与类同名无返回）；</p>
<p>初始化定义：声明同时赋值；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数后面加冒号变量为初始化，意义在于控制常量</span></span><br><span class="line"><span class="built_in">matrix</span>(<span class="keyword">int</span> input):<span class="built_in">line</span>(input)</span><br></pre></td></tr></table></figure>

<p><strong>析构函数</strong>：与类名同名，前面加~，局部变量返回时自动执行，一般做扫尾工作，如free；</p>
<p>调用类函数的时候，实际上编译器将外部变量的引用（匿名 / this ）传入了类函数中；</p>
<p>定义在类中的函数，可以使用 this 指针，这个指针用于操控类里的变量，防止同名冲突；</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>将一个类的内容添加到另一个类的起始；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span>Father <span class="comment">//继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> same;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过父类引用访问子类，但只能指到age结束，要访问子类后续可以用操作指针；</p>
<p>同样可以通过子类引用访问父类，但需要强制转换，且指针可以访问父类后面的空白区域；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Child ch;</span><br><span class="line">Father *pfa = &amp;ch;</span><br><span class="line">pfa-&gt;age; <span class="comment">//通过父类指针访问继承age；</span></span><br><span class="line">---</span><br><span class="line">Father fa;</span><br><span class="line">Child *pch = (Child *)&amp;fa;</span><br><span class="line">pch-&gt;age; <span class="comment">//通过子类指针访问父类age；</span></span><br></pre></td></tr></table></figure>

<p>若继承里有同名变量，则使用就近原则使用子类的内容；若要访问父类的同名变量，加上父类名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Child a;</span><br><span class="line">a.same = <span class="number">1</span>; <span class="comment">//改变原子类内容</span></span><br><span class="line">a.Father::same = <span class="number">2</span>; <span class="comment">//改变继承内容</span></span><br></pre></td></tr></table></figure>

<p>C++拥有多继承，按顺序排的类，哪个在前，其内容内存地址继承在最上方；</p>
<p><strong>权限继承：</strong></p>
<p>class修饰默认为private，若以public继承，则父类内容里保持不变（public还是public，private还是private）；</p>
<p>private修饰的内容继承，子类不能访问，但protected可以；（protected和private就只有这个区别）</p>
<p>构造析构函数也会继承；</p>
<h3 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new&amp;delete"></a>new&amp;delete</h3><p>创建类指针时，在堆开辟类内存空间并执行构造函数： <code>Child *pch = new Child();</code> 类似于java；</p>
<p>使用delete释放空间并执行析构函数： <code>delete pch;</code> ;</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test::<span class="built_in">Test</span>(Test &amp;testaddr)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于对象，复制属性时候执行，只是浅拷贝，值转换，指针可能出错；一般对象作为参数和返回值时就会调用；</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>用于避免多继承的多义变量产生；如：A -&gt; B，A -&gt; C；B,C -&gt; D；使得D里有两组A内容；</p>
<p>继承时，在继承类的前面用 virtual 修饰，称其为<strong>虚基类</strong>；此时，虚基类不会直接继承其内容给子类，而是会给子类一个<strong>虚基类表</strong>，这是一个指针，指向两个数据，第一个表示<strong>虚基类表位于当前所在类</strong>的偏移，第二个表示<strong>继承父类位于虚基类表</strong>的偏移；</p>
<p>一般虚继承的父类内容放在子类内存的下方；</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在类中定义，用 friend 修饰，可以为另类和函数，使其能够直接使用 private 修饰的内容；</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>类类型的对象进行运算是没有意义的，所以可以自己给运算符定义意义；</p>
<p>使用以下内容重载运算符 加号,使得当两个对象相加时执行 “+” 函数的语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A <span class="keyword">operator</span>+ (A a1, A a2)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>明确一些专有名词：</p>
<ol>
<li>重载：同一类里，同名函数，不同参数表；</li>
<li>重写：不同类，且类有继承关系，同名函数；</li>
<li>静态联编：程序编译时定死函数符号以及类指针的引用；动态联编则相反；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HaHa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;233&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HaHa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;lol&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="comment">//此为静态联编，当 *p 定为 A 类型时，默认A -&gt; HaHa() 调用 A 类里的函数；则两个都输出 233 ；</span></span><br><span class="line"><span class="comment">//当父类A里函数用 virtual 修饰时为动态联编，两个分别输出 233 和 lol；</span></span><br><span class="line">    </span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">A *p = <span class="literal">NULL</span>;</span><br><span class="line">A = &amp;a;</span><br><span class="line">A -&gt; <span class="built_in">HaHa</span>();</span><br><span class="line">A = &amp;b;</span><br><span class="line">A -&gt; <span class="built_in">HaHa</span>();</span><br></pre></td></tr></table></figure>

<p>可以抽象地将函数理解成是存在于类中（实际上并没有），继承后盖在子类头上，一共有两个HaHa函数，就近原则选择父类的函数（父类指针），而虚函数的声明免除了这个误会，就类似于虚继承了；</p>
<p>同一个指针，指向不同对象，展现出不同效果的情况，称其为多态，为了实现多态而不产生歧义，才有的<strong>虚函数</strong>；</p>
<p>定义：一个类中声明了虚函数，但是没给出实现，此称为<strong>纯虚函数</strong>，这个类叫做<strong>抽象类</strong>；抽象类不配有对象；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q:为什么这么做？</p>
<p>A:用于构造模型，用子类去实现具体内容，并由一个指向父类的指针去实现多个子类的多态；</p>
<p>如果定义了虚函数，则类里会存在虚表指针独占内存，指向<strong>虚表</strong>，虚表里包含各个虚函数的地址；</p>
<p>继承会合并父类虚表为一个，如果是多继承，则合并第一个继承的虚表，后面的会保留下来；</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>为解决多次重载不同**类型(重点)**参数的函数而出现；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DD&gt;</span></span><br><span class="line"><span class="function">DD <span class="title">func</span><span class="params">(DD a, DD b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时，直接代入函数就行，DD需同类型，但不能指针；</p>
<p>需要指针时，需要使<strong>模板特化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//紧跟上面的内容写</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">int</span> *func&lt;<span class="keyword">int</span> *&gt;(<span class="keyword">int</span> *a, <span class="keyword">int</span>*b)			<span class="comment">//尖括号内容可有可无</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *(a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有重载函数，模板特化，函数模板都满足使用的类型，则优先级由最特化到最不特化；</p>
<p>类也有模板，用 <code>template&lt;class DD&gt;</code> 声明；DD则可替换类里属性的类型；</p>
<p>使用时，用 <code>ClassName&lt;type&gt; a;</code> 来创建一个类对象；</p>
<p><strong>模板的机制：</strong></p>
<p>实际上，模板通过把一个数据类型用通用参数符号来<strong>代替</strong>，实际使用时，用某种数据类型进行替换；</p>
<p>达到处理类型不同，实现功能相同的效果；</p>
<p>模板技术成为<strong>泛型编程</strong>；</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>三个关键词：</p>
<p><strong>throw</strong> : 手动抛出异常，一般满足if关系式后执行，也一般存在try包括中；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> code;		<span class="comment">//code为之后的捕获catch返回的内容</span></span><br></pre></td></tr></table></figure>

<p><strong>try</strong> 和 <strong>catch</strong> 成对出现，前者会用大括号包住可能出现异常的<strong>语句块</strong>；后者作为函数跟随： <code>catch(type code)</code> , <strong>接收</strong>抛出的code，<strong>并执行</strong>catch函数里的内容；</p>
<p>catch里也能放 <code>...</code> ，意思是捕获<strong>任意类型</strong>(包括类)异常（接收任意类型code）;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span> code)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;异常了，且code为&quot;</span> &lt;&lt; code &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会使得打印catch中的语句，且code值为12；</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>标准模板库；</p>
<p>其部件：容器，算法，迭代器；目的是为了更好地存储数据（如排序和查找遍历）</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>顺序容器：</p>
<ul>
<li><p>Vector：向量，动态数组</p>
<p>可扩大数组，每次扩大自身2倍；</p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push_back	<span class="comment">//插入到末尾</span></span><br><span class="line">insert 		<span class="comment">//指定位置插入</span></span><br><span class="line">Pop_back	<span class="comment">//删末尾元素</span></span><br><span class="line">erase		<span class="comment">//删除指定位置</span></span><br><span class="line">Clear		<span class="comment">//清空所有</span></span><br><span class="line">Vec[i]		<span class="comment">//访问索引元素</span></span><br><span class="line">at			<span class="comment">//返回指定下标处元素</span></span><br><span class="line">begin		<span class="comment">//返回 iterator 指向第一个元素</span></span><br><span class="line">End 		<span class="comment">//返回 iterator 指向末尾下一个</span></span><br><span class="line">empty		<span class="comment">//是否为空？</span></span><br><span class="line">size		<span class="comment">//获取元素个数</span></span><br><span class="line">swap		<span class="comment">//交换两个元素</span></span><br><span class="line">  </span><br><span class="line">---</span><br><span class="line">vector&lt;type&gt; item;	<span class="comment">//创建</span></span><br><span class="line">vector::iterator it = item.<span class="built_in">begin</span>();		<span class="comment">//创建迭代器（指针）</span></span><br></pre></td></tr></table></figure></li>
<li><p>String：字符串</p>
</li>
<li><p>List：双向链表</p>
<p>不能操控下标，只能添加和删除以及遍历；</p>
<p>用法和维克托差不多，多了个对头的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Push_front		<span class="comment">//插入头部</span></span><br><span class="line">Pop_front		<span class="comment">//头部删除</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">list&lt;type&gt; item;	<span class="comment">//创建</span></span><br><span class="line">list::iterator it = item.<span class="built_in">begin</span>();		<span class="comment">//创建迭代器（指针）</span></span><br></pre></td></tr></table></figure>

<p>若要操作插入，需要创建迭代器，并且用for循环让iterator++,对list而言，迭代器不能直接加一个数；</p>
</li>
<li><p>Deque：双端队列</p>
</li>
</ul>
<p>关联容器：</p>
<ul>
<li><p>Set</p>
</li>
<li><p>Map</p>
<p>类似于python字典，有 key 和 value，其类型位pair；</p>
<p>可以用 <code>map[key] = value</code> 实现赋值；</p>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>&gt; item;</span><br><span class="line">item.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;BC&quot;</span>,<span class="number">12</span>));</span><br><span class="line">map::iterator it = item.<span class="built_in">begin</span>();</span><br><span class="line">it -&gt; first <span class="comment">//访问key值</span></span><br><span class="line">it -&gt; second<span class="comment">//访问value值</span></span><br></pre></td></tr></table></figure></li>
<li><p>Multiset</p>
</li>
<li><p>Multimap</p>
</li>
</ul>
<p>容器适配器：</p>
<ul>
<li>Stack</li>
<li>Queue</li>
<li>Prority queue</li>
</ul>
<h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>在<strong>面向对象</strong>的过程中，接口就是公共属性的函数，是类内部私有属性和用户的桥梁；</p>
<p>在<strong>多态</strong>的解释中，接口是抽象类函数，运用这个接口去实现不同子类的多态；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际学下来花了接近2个星期吧，说多不多说少不少，要真的掌握和吃牢固还是比较难受；</p>
<p>这么多内容实际上和C的差别也就是编译器，底层展现的代码其实都差不多（比如引用），按java的说法，其实对于这类语言还有更多说法，比如类里定义另类型对象这种<strong>聚集</strong>关系，以及链式异常（两种不同嵌套）；</p>
<h3 id="关于多态的思考"><a href="#关于多态的思考" class="headerlink" title="关于多态的思考"></a>关于多态的思考</h3><p>类型变量实际上也是一个引用，只不过CPP是声明即创建，只不过没赋值，而java是需要声明和创建的；所以导致一个结果：java只需要声明后创建子类类型就能实现多态，而CPP需要创建一个类指针来接收子类引用；</p>
<h3 id="关于类的思考"><a href="#关于类的思考" class="headerlink" title="关于类的思考"></a>关于类的思考</h3><p>STL的思想就很像java，感觉STL在往java和python靠，把一些容器的实现都弄成类，而且是泛型的；但是用之前记得调用头文件和std命名空间；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/10/28/C++%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/11/git%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/">git学习日记</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Git/">Git</a></div></div><div class="post-content"><div class="main-content content"><p>git是分布式版本控制系统；</p>
<h2 id="什么是版本控制系统？"><a href="#什么是版本控制系统？" class="headerlink" title="什么是版本控制系统？"></a>什么是版本控制系统？</h2><p>比如写游戏，会分版本，从一代的基础上复制并修改为二代，一代保留（类似MC的1.7.10和1.19）；</p>
<p>当出了很多个版本之后，<strong>一点</strong>是想要回去玩之前的经典版本，但在版本丛中不好找；第<strong>二点</strong>是两个部门合作一个版本时分工不同，需要对一个共享文件进行改动，但是不知道另一个部门在什么时候做了什么改动，要合并内容，会比较难顶；</p>
<p>而一个软件能解决这些毛病，<strong>记录每次文件的改动，且允许共同编辑</strong>，称其为版本控制系统，目的为了方便开发大项目；</p>
<h2 id="分布式与集中式？"><a href="#分布式与集中式？" class="headerlink" title="分布式与集中式？"></a>分布式与集中式？</h2><p>集中式：版本库集中于中央服务器，每次改动会从其中获取新版本，之后推送回去；</p>
<p>分布式：每个人的文件中都有版本库，所以工作时不需联网，合作时，只需要将改动推送给对方，多人合作时，会有一人充当中央服务器；</p>
<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p><img src="https://s2.loli.net/2022/10/11/9zTqdhYIPXAW7Ux.png" alt="do"></p>
<p>Workspace：<strong>工作区</strong>，平时存放项目代码的地方。<br>Index / Stage：<strong>暂存区</strong>，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。<br>Repository：<strong>仓库区</strong>（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本。<br>Remote：<strong>远程仓库</strong>（github） ，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</p>
<p>一个文件夹即可成为工作区，其中初始化后有一个.git后缀子目录，存放Git管理信息；.git里又有暂存区和仓库区；</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>使文件夹成为工作区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init (指定目录)</span><br></pre></td></tr></table></figure>



<p>添加文件到暂缓区：(name可以是*.加上后缀名，表示全部的一类后缀名都加入)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add (name)</span><br></pre></td></tr></table></figure>



<p>告知后提交，真正加入仓库中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;初始化项目版本&quot;</span><br></pre></td></tr></table></figure>



<p>查看仓库当前状态，显示有变更的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>



<p>回退版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset (place)</span><br></pre></td></tr></table></figure>



<p>从暂缓区和工作区中删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm</span><br></pre></td></tr></table></figure>



<p>移动或重命名工作区文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv</span><br></pre></td></tr></table></figure>



<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><p>控制远程仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote (基本操作)</span><br></pre></td></tr></table></figure>



<p>从远程获取代码库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>



<p>下载远程代码并合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>



<p>上传远程代码并合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>



<p>撤回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert</span><br></pre></td></tr></table></figure>

<p>实际上是将之前的提交记录的相同状态再提交了一遍；</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>创建分支：(不加name则是列出分支)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (name)</span><br></pre></td></tr></table></figure>

<p>带参：-d，表示delete，删除该分支；</p>
<p>​           -f，强制移动；例如：git branch -f main HEAD~3 将main分支移动到HEAD所指的提交记录上；</p>
<p>切换分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (name)</span><br></pre></td></tr></table></figure>

<p>带参：-b，意思是先branch，再checkout，可以直接切换到新创的分支里；</p>
<p>name是某个具体提交记录那么就会分离HEAD，name如果是分支名加^，就会移到前一个提交记录；</p>
<p>如果是HEAD加~x，就会移动到前x个提交记录；</p>
<p>合并分支：（当前分支上融合另一个，另一个会存在一个副本）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>



<p>合并同一分支上且不留副本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase </span><br></pre></td></tr></table></figure>

<p>带参：-i，交互式rebase；</p>
<p>将其他提交记录直接放到当前分支下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick (name1) (name2)</span><br></pre></td></tr></table></figure>



<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>更多练习：<a href="">learngitbranching.js.org</a></p>
<p>github添加一个远程库命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:XXXXX</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

</div></div><a class="button-hover more" href="/SecondBC/2022/10/11/git%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/04/0x41414141/">0x41414141 CTF</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/WriteUp/">WriteUp</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a></div></div><div class="post-content"><div class="main-content content"><h2 id="Backupkeys"><a href="#Backupkeys" class="headerlink" title="Backupkeys"></a>Backupkeys</h2><p>Can you recover my backup keys to get the flag , they probably are hardcoded ?</p>
<p>提示说明 flag 是硬编码；</p>
<p>进入IDA只有start和零散的几个函数，说明加壳了；</p>
<p>用16进制查看器搜UPX可以发现 UPX! 标志；</p>
<p>脱壳后看main函数：</p>
<p><img src="https://s2.loli.net/2022/10/03/CSgXzEMV4Z1LjYD.png" alt="main"></p>
<p>在最下方的输出 try harder的另一条线上有一个输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Phew Phew collect the keys below , don&#x27;t forget to put them in flag&#123;&#125; format&quot;</span></span><br></pre></td></tr></table></figure>

<p>消除逗号得到硬编码的flag：<strong>flag{Hardcodedpasswordsareuseless}</strong></p>
<h2 id="X-and-or"><a href="#X-and-or" class="headerlink" title="X-and-or"></a>X-and-or</h2><p>查看main：</p>
<p><img src="https://s2.loli.net/2022/10/03/9Ty1V4DXIGBQqm3.png" alt="main"></p>
<p>code是一个运行后设置的地址，跳转到主要函数；从code里的判断可得知，输入长度为38；进入运算后循环38次，内部有固定数字进行异或运算并与输入内容比较；</p>
<p><img src="https://s2.loli.net/2022/10/03/nhFodMJmyUXiKzI.png" alt="code"></p>
<p>循环的结尾是比较数据，需要使得eax最终为0；经过调试可以发现每次异或0~5的立方，满6归0；</p>
<p>写出脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">origin = [<span class="number">0x66</span>, <span class="number">0x6D</span>, <span class="number">0x69</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x48</span>, <span class="number">0x36</span>, <span class="number">0x31</span>, <span class="number">0x3E</span>, <span class="number">0x28</span>, <span class="number">0x77</span>, <span class="number">0x19</span>, <span class="number">0x63</span>, <span class="number">0x31</span>, <span class="number">0x6C</span>, <span class="number">0x78</span>, <span class="number">0x24</span>, <span class="number">0x4E</span>, <span class="number">0x33</span>, <span class="number">0x63</span>, <span class="number">0x3D</span>, <span class="number">0x7D</span>, <span class="number">0x26</span>, <span class="number">0x4E</span>, <span class="number">0x37</span>, <span class="number">0x39</span>, <span class="number">0x30</span>, <span class="number">0x2B</span>, <span class="number">0x23</span>, <span class="number">0x1C</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x6A</span>, <span class="number">0x29</span>, <span class="number">0x74</span>, <span class="number">0x1B</span>, <span class="number">0x62</span>, <span class="number">0x7C</span>]</span><br><span class="line"></span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">38</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">38</span>):</span><br><span class="line">    flag[i] = <span class="built_in">chr</span>(((k*k*k)) ^ origin[i])</span><br><span class="line">    k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">6</span>:</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))</span><br></pre></td></tr></table></figure>

<p>由此得到flag：<strong>flag{560637dc0dcd33b5ff37880ca10b24fb}</strong></p>
<p>这题最有意思的是init函数，他把code的二进制内容异或上了0x42，需要将其变回来则再异或0x42，然后写在新的txt里，用IDA反编译，设置sp值，然后就能看到伪代码了：</p>
<p><img src="https://s2.loli.net/2022/10/03/aeJj91hNIT2ozlP.png" alt="code"></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>I received a corrupted program the keys are probably lost within the game can you just find it for me to get the flag?.</p>
<p>Flag format : flag{key1+key2}</p>
<p>一开始看main觉得很奇怪，明明汇编有其他分支为什么伪代码始终显示的是 oops wrong path ？</p>
<p>结果发现是因为跳转的地方动了手脚：</p>
<p><img src="https://s2.loli.net/2022/10/03/GpBMo9VZQwleg6J.png" alt="jmp"></p>
<p>它始终都是判断必走另一条路，所以找不到正确的上下文；本来以为很难的题一下就变成了渣渣题；</p>
<p>里里外外都改一下jmp，再运行一遍，它就自己吐flag了；</p>
<p>得出：<strong>flag{456789JKLq59U1337}</strong></p>
<h2 id="Cage"><a href="#Cage" class="headerlink" title="Cage"></a>Cage</h2><p>Are you aware of the scopes yet?</p>
<p>开场patch main_one函数得到正确的上下文；</p>
<p><img src="https://s2.loli.net/2022/10/04/SprgcPE8LWuNDdn.png" alt="main"></p>
<p>发现需要输入一系列magic code，然后它会吐出已有的字符串，直接将字符串拼起来得到flag：</p>
<p><strong>flag{0xm4tr1xreal}</strong></p>
<h2 id="Ware"><a href="#Ware" class="headerlink" title="Ware"></a>Ware</h2><p>My plaintext has been encrypted by an innocent friend of mine while playing around cryptographic libraries, can you help me to recover the plaintext , remembers it’s just numbers and there’s a space between some numbers which you need to remove the space and submit the recovered plain text as a flag.</p>
<p>开始一个upx直接脱掉；</p>
<p>搜索运行时的字符串得到flag：<strong>flag{32117406899806798980909}</strong></p>
<h2 id="WrongDownload"><a href="#WrongDownload" class="headerlink" title="WrongDownload"></a>WrongDownload</h2><p>My key has been missing inside these two binaries can you help me to find it out ,as per my friend the key is divided in two parts between the two binaries so, remember you need to join them up before submitting as a flag.</p>
<p>直接反编译就能找到：<strong>flag{S6c56bnXQiBjk9mqSYE7ykVQ7NzrRy}</strong></p>
</div></div><a class="button-hover more" href="/SecondBC/2022/10/04/0x41414141/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/10/01/Proxy-lab/">Proxy_lab</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/CSAPP/">CSAPP</a></div></div><div class="post-content"><div class="main-content content"><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一个web代理，并有多线程和缓存功能，所以一一来实现；</p>
<ul>
<li>根据 write up 中所说，首先需要实现 HTTP/1.0 GET 请求的顺序代理：读取整个请求并解析请求（<strong>是否是有效HTTP请求</strong>），如果是则建立自己到适当 web服务器的连接，请求客户端指定对象，再将响应转发回客户端；注意：HTTP请求每行以\r\n结束，并以\r\n为尾行；<ul>
<li>具体要做到将url解析为三部分：host，后半url，HTTP版本；</li>
<li>请求头中包含ua，host，connection，proxy-connection；</li>
<li>请求端口无论在url中还是默认的都必须正确；</li>
<li>处理过早关闭的连接，需要捕获SIGPIPE；</li>
</ul>
</li>
<li>实现多线程工作（生产者-消费者）；</li>
<li>实现缓存最近内存中使用的web对象（LRU策略）；<ul>
<li>设置缓存的最大内存，以及单个对象的最大内存；</li>
</ul>
</li>
</ul>
<p>handout给出了tiny服务器的源码，只需要在这个基础上进行改装；</p>
<h2 id="Tiny解析"><a href="#Tiny解析" class="headerlink" title="Tiny解析"></a>Tiny解析</h2><p>main函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入端口参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听描述符</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="comment">//接受请求成为描述符</span></span><br><span class="line">	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </span><br><span class="line">        <span class="comment">//读取套接字信息，IP和端口</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="line">                    port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);</span><br><span class="line">    <span class="comment">//响应</span></span><br><span class="line">	doit(connfd); </span><br><span class="line">    <span class="comment">//关闭接受描述符</span></span><br><span class="line">	Close(connfd);                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>doit函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> is_static;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> filename[MAXLINE], cgiargs[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取请求行</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       <span class="comment">//解析请求行</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     <span class="comment">//是否为GET请求</span></span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line">    read_requesthdrs(&amp;rio);    <span class="comment">//显示请求行和头（printf）                          </span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    is_static = parse_uri(uri, filename, cgiargs);      <span class="comment">//解析uri</span></span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;sbuf) &lt; <span class="number">0</span>) &#123;                    </span><br><span class="line">	clienterror(fd, filename, <span class="string">&quot;404&quot;</span>, <span class="string">&quot;Not found&quot;</span>,</span><br><span class="line">		    <span class="string">&quot;Tiny couldn&#x27;t find this file&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_static) &#123;       </span><br><span class="line">	<span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR &amp; sbuf.st_mode)) &#123; </span><br><span class="line">	    clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Tiny couldn&#x27;t read the file&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	serve_static(fd, filename, sbuf.st_size);        <span class="comment">//静态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">	<span class="keyword">if</span> (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR &amp; sbuf.st_mode)) &#123; </span><br><span class="line">	    clienterror(fd, filename, <span class="string">&quot;403&quot;</span>, <span class="string">&quot;Forbidden&quot;</span>,</span><br><span class="line">			<span class="string">&quot;Tiny couldn&#x27;t run the CGI program&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	serve_dynamic(fd, filename, cgiargs);            <span class="comment">//动态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>serve_static函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_static</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">int</span> filesize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcfd;</span><br><span class="line">    <span class="keyword">char</span> *srcp, filetype[MAXLINE], buf[MAXBUF];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送响应行和报头</span></span><br><span class="line">    get_filetype(filename, filetype);    </span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>); </span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-length: %d\r\n&quot;</span>, filesize);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Content-type: %s\r\n\r\n&quot;</span>, filetype);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//回响载体</span></span><br><span class="line">    srcfd = Open(filename, O_RDONLY, <span class="number">0</span>); </span><br><span class="line">    srcp = Mmap(<span class="number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="number">0</span>); <span class="comment">//映射内存保证原文件纯净</span></span><br><span class="line">    Close(srcfd);                       </span><br><span class="line">    Rio_writen(fd, srcp, filesize);     </span><br><span class="line">    Munmap(srcp, filesize);             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>serve_dynamic函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serve_dynamic</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *filename, <span class="keyword">char</span> *cgiargs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], *emptylist[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行与报头</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>); </span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;Server: Tiny Web Server\r\n&quot;</span>);</span><br><span class="line">    Rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span> (Fork() == <span class="number">0</span>) &#123;</span><br><span class="line">	</span><br><span class="line">	setenv(<span class="string">&quot;QUERY_STRING&quot;</span>, cgiargs, <span class="number">1</span>);  <span class="comment">//用url参数初始化环境变量</span></span><br><span class="line">	Dup2(fd, STDOUT_FILENO);        <span class="comment">//重定向输出到fd</span></span><br><span class="line">	Execve(filename, emptylist, environ);  <span class="comment">//运行CGI程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    Wait(<span class="literal">NULL</span>); <span class="comment">//等待子进程结束回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="I-顺序代理GET请求"><a href="#I-顺序代理GET请求" class="headerlink" title="I . 顺序代理GET请求"></a>I . 顺序代理GET请求</h2><p>writeup中的要求：</p>
<ol>
<li><p>处理 HTTP/1.0 版本，如果遇到1.1，则需要将其作为1.0版本转发；</p>
</li>
<li><p>转发合法 HTTP 请求（实现中所示）；</p>
</li>
<li><p>头中的 ua 和 两个 connection 都有给定的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305Firefox/10.0.3\r\n&quot;</span></span><br><span class="line"><span class="string">&quot;Proxy-Connection: close&quot;</span> </span><br><span class="line"><span class="string">&quot;Connection: close&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>​    </li>
</ul>
<p>实际上要做的，就是将doit内的操作变为转发与回复，而不是单纯回响；</p>
<p>那么需要将发送的包<strong>改</strong>写给目标服务器，之后把目标服务器的回响写给发送者；</p>
<p>要看uri中是否有端口那就应该解析uri，但和上面解析是不一样的，上面是在看读取的文件是静态还是动态；</p>
<p>主函数和tiny一样，只是需要在 listen之前加一条：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGPIPE,SIG_IGN);</span><br></pre></td></tr></table></figure>

<p>新建三个全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//uri解析记录变量</span></span><br><span class="line"><span class="keyword">char</span> send_port[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> send_host[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> send_path[MAXLINE];</span><br></pre></td></tr></table></figure>

<p>doit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> backbuf[MAXLINE],newhd[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> *send;</span><br><span class="line">    <span class="keyword">rio_t</span> rio,serverfd_rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取请求行</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       <span class="comment">//解析请求行</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     <span class="comment">//是否为GET请求</span></span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line">    read_requesthdrs(&amp;rio);    <span class="comment">//显示请求行和头（printf）                          </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析uri为host port path</span></span><br><span class="line">    parse_uri(uri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改写</span></span><br><span class="line">    <span class="built_in">sprintf</span>(newhd, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, send_path);</span><br><span class="line">    send = built_message(newhd,&amp;rio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启远程服务器</span></span><br><span class="line">    <span class="keyword">int</span> serverfd = Open_clientfd(send_host,send_port);</span><br><span class="line">    <span class="keyword">if</span> (serverfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    Rio_readinitb(&amp;serverfd_rio, serverfd);</span><br><span class="line">    <span class="comment">//写入服务器</span></span><br><span class="line">    Rio_writen(serverfd, send, <span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回响</span></span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;serverfd_rio,backbuf,MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        Rio_writen(fd,backbuf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Close (serverfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个神奇函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_uri</span><span class="params">(<span class="keyword">char</span> *uri)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//是否有host：port，port默认80</span></span><br><span class="line">    <span class="keyword">char</span> *hostpath = <span class="built_in">strstr</span>(uri,<span class="string">&quot;//&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(hostpath != <span class="literal">NULL</span>) <span class="comment">//有</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是否有port</span></span><br><span class="line">        <span class="keyword">char</span> *portpath = <span class="built_in">strstr</span>(hostpath + <span class="number">2</span>,<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(portpath != <span class="literal">NULL</span>) <span class="comment">//有</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            <span class="built_in">sscanf</span>(portpath+<span class="number">1</span>,<span class="string">&quot;%d%s&quot;</span>,&amp;num,send_path);</span><br><span class="line">            <span class="built_in">sprintf</span>(send_port,<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">            *portpath = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//无</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">char</span> *path = <span class="built_in">strstr</span>(hostpath + <span class="number">2</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        	<span class="keyword">if</span>(path != <span class="literal">NULL</span>) </span><br><span class="line">        	&#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(send_path,path);</span><br><span class="line">        		<span class="built_in">strcpy</span>(send_port,<span class="string">&quot;80&quot;</span>);</span><br><span class="line">            	*path = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(send_host,hostpath + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//无</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *path = <span class="built_in">strstr</span>(uri,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(path != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(send_path,path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(send_port,<span class="string">&quot;80&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">built_message</span><span class="params">( <span class="keyword">char</span> *getit,<span class="keyword">rio_t</span> *rp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构造新头</span></span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> rio[MAXLINE];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s&quot;</span>,getit);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sHost: %s\r\n&quot;</span>,buf,send_host);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sUser-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sConnection: close\r\n&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%sProxy-Connection: close\r\n\r\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//补上原内容</span></span><br><span class="line">    Rio_readnb(rp,rio,MAXLINE);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s%s&quot;</span>,buf,rio);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<h2 id="II-多线程的并发"><a href="#II-多线程的并发" class="headerlink" title="II . 多线程的并发"></a>II . 多线程的并发</h2><p>实现多线程使用 消费者-生产者 模型：</p>
<p>消费者和生产者共同使用一个 n个槽的优先缓冲区，生产者产生新的项目并插入缓冲区；消费者取出这些项目并使用；</p>
<p>因此两者的访问需要互斥，并且调度地访问：空状态（消费者等待），满状态（生产者等待）；</p>
<p>在这个实验里，<strong>消费者就是服务端</strong>，接受各样的连接；<strong>生产者就是客户端</strong>，发送各样的连接；</p>
<p>实现缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *buf;          <span class="comment">// 缓冲区数组         </span></span><br><span class="line">    <span class="keyword">int</span> n;             <span class="comment">// 槽的最大数量</span></span><br><span class="line">    <span class="keyword">int</span> front;         <span class="comment">// buf[(front+1)%n] 是第一个项目</span></span><br><span class="line">    <span class="keyword">int</span> rear;          <span class="comment">// buf[rear%n] 是最后一个项目</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex;       <span class="comment">//互斥锁，初始化1</span></span><br><span class="line">    <span class="keyword">sem_t</span> slots;       <span class="comment">//记录槽，初始化n</span></span><br><span class="line">    <span class="keyword">sem_t</span> items;       <span class="comment">//记录项目，初始化0</span></span><br><span class="line">&#125; <span class="keyword">sbuf_t</span>;</span><br></pre></td></tr></table></figure>

<p>客户端插入函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(&amp;sp-&gt;slots);                          <span class="comment">// 对slots加锁，保证槽位满时，客户端挂起</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">// 对缓冲区互斥访问</span></span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)] = item;   <span class="comment">// 添加项目</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;items);                          <span class="comment">//与slots对应地调整items</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端实现后移除项目的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    P(&amp;sp-&gt;items);                          <span class="comment">// 如果项目没有，服务端挂起</span></span><br><span class="line">    P(&amp;sp-&gt;mutex);                          <span class="comment">// 加锁缓冲区</span></span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];  <span class="comment">// 移除项目</span></span><br><span class="line">    V(&amp;sp-&gt;mutex);                          <span class="comment">// 解锁</span></span><br><span class="line">    V(&amp;sp-&gt;slots);                         </span><br><span class="line">    <span class="keyword">return</span> item;							<span class="comment">//返回客户端的描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数（和tiny的main差不多）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE], port[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入端口参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//阻塞SIGPIPE信号</span></span><br><span class="line">    signal(SIGPIPE,SIG_IGN);</span><br><span class="line">    <span class="comment">//监听描述符</span></span><br><span class="line">    listenfd = Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    sbuf_init(&amp;sbuf, SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NTHREADS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Pthread_create(&amp;tid, <span class="literal">NULL</span>, thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	clientlen = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="comment">//接受请求成为描述符</span></span><br><span class="line">	connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); </span><br><span class="line">    <span class="comment">//插入描述符</span></span><br><span class="line">    sbuf_insert(&amp;sbuf, connfd);</span><br><span class="line">        <span class="comment">//读取套接字信息，IP和端口</span></span><br><span class="line">        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE, </span><br><span class="line">                    port, MAXLINE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from (%s, %s)\n&quot;</span>, hostname, port);                                       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程执行函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//从缓冲区中读出描述符</span></span><br><span class="line">    <span class="keyword">int</span> connfd = sbuf_remove(&amp;sbuf);</span><br><span class="line"></span><br><span class="line">    doit(connfd);</span><br><span class="line">    Close(connfd);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="III-缓存web对象"><a href="#III-缓存web对象" class="headerlink" title="III . 缓存web对象"></a>III . 缓存web对象</h2><p>目的是为了让多次访问的web对象不用再连接服务器，直接响应；</p>
<p>这里会使用 读者-写者 模型 ，让线程从缓存中读和写：</p>
<p>只读的线程叫读者，只写的进程叫写者，读者可以和其他读者共享只读部分，写者需要有独立的访问；</p>
<p>这个模型有两种情况：</p>
<p>读者优先，写者优先；</p>
<p>这里使用读优先：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> read_cnt;		<span class="comment">//记录读者数量</span></span><br><span class="line"><span class="keyword">sem_t</span> mutex, w;    <span class="comment">//都初始化为1，w导使有读无写，有写无读</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt++;</span><br><span class="line">        <span class="keyword">if</span>(readcnt==<span class="number">1</span>) <span class="comment">//第一个读者导致w加锁，则写者挂起；</span></span><br><span class="line">            P(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        P(&amp;mutex);</span><br><span class="line">        readcnt--;</span><br><span class="line">        <span class="keyword">if</span>(readcnt==<span class="number">0</span>) <span class="comment">//最后一个读者结束解锁w</span></span><br><span class="line">            V(&amp;w);</span><br><span class="line">        V(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(&amp;w);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        V(&amp;w)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置缓存区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> obj[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="keyword">char</span> uri[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> LRU;</span><br><span class="line">    <span class="keyword">int</span> isEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> read_cnt; <span class="comment">//读者数量</span></span><br><span class="line">    <span class="keyword">sem_t</span> w;      <span class="comment">//Cache信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> mutex;  <span class="comment">//read_cnt信号量</span></span><br><span class="line"></span><br><span class="line">&#125; block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    block data[MAX_CACHE];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125; Cache;</span><br></pre></td></tr></table></figure>

<p>修改doit函数中的内容，得到请求后，判断uri是否在缓存中，不在就添加进去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> fd)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> backbuf[MAXLINE],newhd[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> *send;</span><br><span class="line">    <span class="keyword">char</span> cache_tag[MAXLINE];</span><br><span class="line">    <span class="keyword">rio_t</span> rio,serverfd_rio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取请求行</span></span><br><span class="line">    Rio_readinitb(&amp;rio, fd);</span><br><span class="line">    <span class="keyword">if</span> (!Rio_readlineb(&amp;rio, buf, MAXLINE))  </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%s %s %s&quot;</span>, method, uri, version);       <span class="comment">//解析请求行</span></span><br><span class="line">   	<span class="built_in">strcpy</span>(cache_tag,uri);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>)) &#123;                     <span class="comment">//是否为GET请求</span></span><br><span class="line">        clienterror(fd, method, <span class="string">&quot;501&quot;</span>, <span class="string">&quot;Not Implemented&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Tiny does not implement this method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;                                                    </span><br><span class="line">    read_requesthdrs(&amp;rio);    <span class="comment">//显示请求行和头（printf）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//uri是否存在缓存中</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> ((i = get_Cache(cache_tag)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        P(&amp;cache.data[i].mutex);</span><br><span class="line">        cache.data[i].read_cnt++;</span><br><span class="line">        <span class="keyword">if</span> (cache.data[i].read_cnt == <span class="number">1</span>)</span><br><span class="line">            P(&amp;cache.data[i].w);</span><br><span class="line">        V(&amp;cache.data[i].mutex);</span><br><span class="line"></span><br><span class="line">        Rio_writen(connfd, cache.data[i].obj, <span class="built_in">strlen</span>(cache.data[i].obj));</span><br><span class="line"></span><br><span class="line">        P(&amp;cache.data[i].mutex);</span><br><span class="line">        cache.data[i].read_cnt--;</span><br><span class="line">        <span class="keyword">if</span> (cache.data[i].read_cnt == <span class="number">0</span>)</span><br><span class="line">            V(&amp;cache.data[i].w);</span><br><span class="line">        V(&amp;cache.data[i].mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析uri为host port path</span></span><br><span class="line">    parse_uri(uri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改写</span></span><br><span class="line">    <span class="built_in">sprintf</span>(newhd, <span class="string">&quot;GET %s HTTP/1.0\r\n&quot;</span>, send_path);</span><br><span class="line">    send = built_message(newhd,&amp;rio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开启远程服务器</span></span><br><span class="line">    <span class="keyword">int</span> serverfd = Open_clientfd(send_host,send_port);</span><br><span class="line">    <span class="keyword">if</span> (serverfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    Rio_readinitb(&amp;serverfd_rio, serverfd);</span><br><span class="line">    <span class="comment">//写入服务器</span></span><br><span class="line">    Rio_writen(serverfd, send, <span class="built_in">strlen</span>(send));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cache_buf[MAX_OBJECT_SIZE];</span><br><span class="line">    <span class="keyword">int</span> size_buf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回响</span></span><br><span class="line">    <span class="keyword">while</span>((n = Rio_readlineb(&amp;serverfd_rio,backbuf,MAXLINE)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        size_buf += n;</span><br><span class="line">        <span class="keyword">if</span>(size_buf &lt; MAX_OBJECT_SIZE)</span><br><span class="line">            <span class="built_in">strcat</span>(cache_buf, buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;proxy received %d bytes,then send\n&quot;</span>, (<span class="keyword">int</span>)n);</span><br><span class="line">        Rio_writen(fd,backbuf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Close (serverfd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有就写入缓存</span></span><br><span class="line">    <span class="keyword">if</span>(size_buf &lt; MAX_OBJECT_SIZE)&#123;</span><br><span class="line">        write_Cache(cache_tag, cache_buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然迷迷糊糊的，但跟着线程走了一遍，多多少少学会了更多的东西：比如信号量的运用，线程创建和运作方式，以及状态机和模型的特点；但这个lab确实感受到了难度，等往后学的深入再返回看的话应该还会有收获；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/10/01/Proxy-lab/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/09/11/Malloc-Lab/">Malloc_Lab</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/CSAPP/">CSAPP</a></div></div><div class="post-content"><div class="main-content content"><p><img src="https://s2.loli.net/2022/09/12/nTyIcwFaqgRKWh1.jpg" alt="forest"></p>
<hr>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一个动态内存申请器，能实现：malloc， free， realloc；</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>CSAPP第9章：动态内存申请器，内存中的堆，链表；</p>
<h2 id="蛋疼的检测工具"><a href="#蛋疼的检测工具" class="headerlink" title="蛋疼的检测工具"></a>蛋疼的检测工具</h2><p>首先需要；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -O2 -m32   -c -o mdriver.o mdriver.c</span><br></pre></td></tr></table></figure>

<p>然后；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make mdriver mdriver.o mm.o memlib.o fsecs.o fcyc.o clock.o ftimer.o</span><br></pre></td></tr></table></figure>

<p>以上两个出错请用下面指令解决；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure>

<p>下载出错请更新镜像，或者添加清华园下载路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure>

<p>输入以下命令打开下载源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>按 i 进入编辑模式，完成后输入 :w 保存， :q退出；之后输入一遍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade</span><br></pre></td></tr></table></figure>

<p>然后就能输入第三条指令了，接着编译就行了；</p>
<p>其次，traces是缺失的，需要下载以进行检测；地址：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Davon-Feng/CSAPP-Labs/tree/master/yzf-malloclab-handout/traces">https://github.com/Davon-Feng/CSAPP-Labs/tree/master/yzf-malloclab-handout/traces</a></p>
<p>将10个文件装入文件夹，将文件夹放到和 mdriver 同级的地方；</p>
<p>并修改config.h里第15行的内容为自己的traces文件夹目录；</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>需要内存空间模拟堆；</li>
<li>需要模拟已分配和未分配的块；</li>
<li>需要管理这个空间（开始，结束，填充）；</li>
<li>需要操控这个空间（放置，分割，合并，释放）；</li>
</ul>
<h2 id="已知内容"><a href="#已知内容" class="headerlink" title="已知内容"></a>已知内容</h2><p>mem_heap，mem_brk两个指针分别指向堆的开始和结尾，mem_sbrk函数可以调节brk并返回旧brk的值，两个指针已初始化相等；</p>
<p>堆中的最小单位为4字节（1字），第一个字是双字边界对齐不使用的填充字；后面跟着两字的序言块，分配器使用私有的全局变量 heap_listp 指向序言块的第二个字开头；以一个0内容的已分配块作为结束的一个字；</p>
<p>使用隐式空闲链表，下一次适配，边界标记的堆块格式（最小4字，开头和结尾2字是标志字），立即合并；</p>
<p>标志字由整个块的大小或上分配位组成；</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="I-操作空闲链表的常数和宏"><a href="#I-操作空闲链表的常数和宏" class="headerlink" title="I . 操作空闲链表的常数和宏"></a>I . 操作空闲链表的常数和宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4     <span class="comment">//一字的字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8     <span class="comment">//两字的字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12)       <span class="comment">//延展一次堆的字节数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(x,y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大小或上分配位打包的标志字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size,alloc) ((size) | (alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读写p指针处的一个字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int *)(p))       </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p,val) (*(unsigned int *)(p) = (val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取标志字中的大小和分配状态</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给出开头或结尾标志字的位置(bp指针指向块的有效载体)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp) - DSIZE + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//给出前一个或下一个块的bp指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * heap_listp;</span><br><span class="line"><span class="comment">//下次适配记录之前的块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * prev_listp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>p是一个void * 指针，所以强制转换是必要的；</p>
<h3 id="II-创建空闲列表（堆）"><a href="#II-创建空闲列表（堆）" class="headerlink" title="II . 创建空闲列表（堆）"></a>II . 创建空闲列表（堆）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//分配4个字(1个初始填充，2个序言，1个结尾)</span></span><br><span class="line">    <span class="keyword">if</span>((heap_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp,<span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + WSIZE,PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE),PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span>*WSIZE),PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    heap_listp += (<span class="number">2</span>*WSIZE);</span><br><span class="line">    prev_listp = heap_listp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延展空闲块</span></span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//满足2字对齐</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置填充空闲块的头和尾，以及延展一个结束字</span></span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)),PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并空闲块，如果前面是的话</span></span><br><span class="line">    prev_listp = coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mm_init函数在创建初始堆空间；extend_heap函数在延展空闲块，用在init里，当然也可以用在当申请空间不足时的地方，所以单独成为一个函数；coalesce之后会讲到，是合并空闲块的函数，在填充和释放时用到；</p>
<p>注意，首次适配所记录的当前块指针如果被向前合并，则记录指针也需要随之改变，所以最好运用合并函数的地方都使其返回的值成为prev_listp；</p>
<h3 id="III-释放和合并块"><a href="#III-释放和合并块" class="headerlink" title="III . 释放和合并块"></a>III . 释放和合并块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> * bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置头尾分配位0</span></span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    prev_listp = coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4种情况，前后块都是分配的，前后块都没分配，前后块有一者分配</span></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;	</span><br><span class="line">    	<span class="keyword">return</span> bp;</span><br><span class="line">	&#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp))) + GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第二个else if 的地方，HDRP需要写前面，因为FTRP会用HDRP处的内容；</p>
<h3 id="IV-放置和分割块"><a href="#IV-放置和分割块" class="headerlink" title="IV . 放置和分割块"></a>IV . 放置和分割块</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 调整后大小</span></span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">    <span class="comment">//延展大小</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//忽视无用请求</span></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调整对齐要求</span></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= DSIZE)</span><br><span class="line">        asize = <span class="number">2</span> * DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//向上取整</span></span><br><span class="line">        asize = ((size + DSIZE + (DSIZE - <span class="number">1</span>)) / DSIZE) * DSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放置块</span></span><br><span class="line">    <span class="keyword">if</span>((bp = find_fit(asize)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp,asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间不够延展</span></span><br><span class="line">    extendsize = MAX(asize,CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span>((bp = extend_heap(extendsize/WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    place(bp,asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * bp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化使prev_listp指向了序言块</span></span><br><span class="line">    <span class="keyword">for</span>(bp = prev_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">        &#123;</span><br><span class="line">            prev_listp = bp;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后面找没有之后从头找</span></span><br><span class="line">    <span class="keyword">for</span>(bp = heap_listp; bp != prev_listp; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">        &#123;</span><br><span class="line">            prev_listp = bp;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> * bp,<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//原块长度</span></span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分割后大小大于或等于最小块则执行分割</span></span><br><span class="line">    <span class="keyword">if</span>((csize - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp),PACK((csize - asize),<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK((csize - asize),<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(csize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="V-重分配块大小"><a href="#V-重分配块大小" class="headerlink" title="V . 重分配块大小"></a>V . 重分配块大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * old_bp = bp;</span><br><span class="line">    <span class="keyword">void</span> * new_bp;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize, newsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新的分配块</span></span><br><span class="line">    new_bp = mm_malloc(size);</span><br><span class="line">    <span class="keyword">if</span>(new_bp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    oldsize = GET_SIZE(HDRP(old_bp));</span><br><span class="line">    newsize = GET_SIZE(HDRP(new_bp));</span><br><span class="line">    <span class="comment">//比较新旧大小，如果新的更大，则复制原数据过去，如果更小，复制小的长度个原数据</span></span><br><span class="line">    <span class="keyword">if</span>(oldsize &lt; newsize)</span><br><span class="line">        newsize = oldsize;</span><br><span class="line">    <span class="comment">//取消结尾字</span></span><br><span class="line">    <span class="built_in">memcpy</span>(new_bp, old_bp, newsize-WSIZE);</span><br><span class="line">    mm_free(old_bp);</span><br><span class="line">    <span class="keyword">return</span> new_bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="VI-检测"><a href="#VI-检测" class="headerlink" title="VI . 检测"></a>VI . 检测</h3><p>将代码打包到mm.c，使用之前的编译命令，搞出有代码的 mdriver；输入以检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mdriver -V</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://s2.loli.net/2022/09/12/YFhJiKkL3Bdqbfp.jpg" alt="check"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，实现了所分析的内容：</p>
<p>模拟空间，填充——extend_heap；</p>
<p>已分配和未分配的块——有头尾的列表模式以及宏定义的操作；</p>
<p>开头结尾——mm_init；</p>
<p>以及有小标题的放置，分割，释放，合并小函数；</p>
<hr>
<p><img src="https://s2.loli.net/2022/09/12/oKRc8yNQZOGXk9Y.jpg" alt="forest"></p>
</div></div><a class="button-hover more" href="/SecondBC/2022/09/11/Malloc-Lab/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/08/18/%E5%81%87%E6%9C%9F%E5%A4%8D%E7%8E%B0/">假期复现</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/WriteUp/">WriteUp</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a></div></div><div class="post-content"><div class="main-content content"><h2 id="1-havetea"><a href="#1-havetea" class="headerlink" title="1 . havetea"></a>1 . havetea</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/1376f9c70c6ecb62.png" alt="main"></p>
<p>左边是主函数里可以找到的，可以发现首先让输入key，且为16个长度，并且把输入的key分成两段进行了两次加密；在加密函数crypto里，是一个简单<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/TEA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/9383067?fr=aladdin">TEA运算</a>，只不过IDA抽风把 +=delta 翻译成了 -=补码；crypto又把输入的数据截成两段进行运算，使用的key可以在程序里找到；之后用加密数据进行比较；</p>
<p>知晓key和加密后的数据使用对应解密方式解密：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= ((l&lt;&lt;<span class="number">4</span>) + c) ^ (l + sum) ^ ((l&gt;&gt;<span class="number">5</span>) + d);</span><br><span class="line">		l -= ((r&lt;&lt;<span class="number">4</span>) + a) ^ (r + sum) ^ ((r&gt;&gt;<span class="number">5</span>) + b);</span><br><span class="line">		sum -= delta;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>解密后得到输入为：<strong>please_drink_tea</strong></p>
<p><img src="https://i.bmp.ovh/imgs/2022/07/17/64d80edd5d6bb540.png" alt="end"></p>
<p>之后又让输入32长度的内容进行加密，并且用之前输入的16长度作为第二次加密cry的密钥；可以看出这次32长度的内容被分成了4段进行cry加密，而cry其实是和第一次的crypto差不多的TEA运算；加密完之后进行数据比较；</p>
<p>对应解密方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		r -= (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]) ^ (l + ((<span class="number">16</span> * l) ^ (l &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">		sum -= delta;</span><br><span class="line">		l -= (sum + key[sum &amp; <span class="number">3</span>]) ^ (r + ((<span class="number">16</span> * r) ^ (r &gt;&gt; <span class="number">5</span>)));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>解密后得到：<strong>flag{c616454f52a6334273b5f455a10ef818}</strong></p>
<h2 id="2-maze"><a href="#2-maze" class="headerlink" title="2.maze"></a>2.maze</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/134754dd288f1cbb.png" alt="main"></p>
<p>通过字符串搜索，找到主要函数，可以看到通过输入的v2来与v3进行 domaze 函数运算；右图为 domaze 函数，可以看出这是个三线迷宫，迷宫整体由v3控制，输入的v2代表玩家移动方向；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/8e17607d241170f1.png" alt="maze"></p>
<p>通过调试可知，这是个指针制作的迷宫，前24位每8位代表一个方向，第25位开始往后是控制数；比如地址0x112E86A 为1，对应0x112E860处的方向的控制数，当这个控制数为 1 的时候，根据 domaze 函数的计算规则可知，会触发 sub_4C6470 结束函数；而最后一个 0 是代表是否走过这个路口，走过之后会变成 1；</p>
<p>之后通过这个规则去逆推回去：（这些是地址低三位）</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/9e28b505062294f5.png" alt="test"></p>
<p>正着写回去便是：<strong>rrrrtltltlllltlltrtrrr</strong>；</p>
<p>md5之后得到：<strong>flag{988b0f23719099efcbd66586a168bab9}</strong></p>
<h2 id="3-rota"><a href="#3-rota" class="headerlink" title="3.rota"></a>3.rota</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/56ae438b00a5db8a.png" alt="main"></p>
<p>最上面图展示了最终的比较数据；中间左边的图则是一开始的base64编码，下面的图展示了base64的变种码表；中间右边的图展示了最后是生成了一个BOX，用BOX与base64编码后的内容进行加密；</p>
<p>中间有BOX的生成内容，但是无关紧要，因为生成的数据和输入的内容无关，所以是固定的，BOX也就是固定的；</p>
<p>所以只需要破解这个加密就能够得出最终结果；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/07/3a718c1a2cd93ce8.png" alt="crypto"></p>
<p>以上为crypt函数的内容；</p>
<p>调试加分析加软磨硬泡得出爆破代码的核心内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v10 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">66</span>):</span><br><span class="line">        v11 = v5</span><br><span class="line">        v12 = (v5 + BOX[(v3 + v10) &amp; <span class="number">0x3F</span>]) &amp; <span class="number">0x3F</span></span><br><span class="line">        v13 = (v3 + <span class="number">1</span>) &amp; <span class="number">0x3F</span></span><br><span class="line">        v14 = BOX[((result + BOX[v12 + <span class="number">64</span>]) &amp; <span class="number">0x3F</span>) + <span class="number">128</span>]</span><br><span class="line">        <span class="keyword">if</span>(ans[j] == b64box[v14]):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(b64box[v10]))</span><br><span class="line">            BOX[<span class="number">192</span>] = v13</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span>(v10 == <span class="number">65</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;erorr&#x27;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> v13):</span><br><span class="line">      v5 = (v5 + <span class="number">1</span>) &amp; <span class="number">0x3F</span></span><br><span class="line">      BOX[<span class="number">193</span>] = v5</span><br><span class="line">      <span class="keyword">if</span>(((v11 + <span class="number">1</span>) &amp; <span class="number">0x3F</span>) == <span class="number">0</span>):</span><br><span class="line">        result = (result + <span class="number">1</span>) &amp; <span class="number">0x3F</span></span><br><span class="line">        BOX[<span class="number">194</span>] = result</span><br></pre></td></tr></table></figure>

<p>然后和原代码一样，该循环几次循环几次，该有几个有几个；</p>
<p>得出base64编码后的内容为：cAJ7BzX+6zHrHwnTc/i7Bz6f6t6EBQDvc/xfHt9d6S9XX</p>
<p>再base64解码一遍：</p>
<p><img src="https://s2.loli.net/2022/08/07/Lm2koeIsCA3PzSx.png" alt="base64"></p>
<p>得到：<strong>flag{8cdd01062b7e90dd372c3ea9977be53e}</strong></p>
<h2 id="4-gocode"><a href="#4-gocode" class="headerlink" title="4.gocode"></a>4.gocode</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/08/be41905303bfdecf.png" alt="main"></p>
<p>gocode提示了这是go语言写的，所以搜索函数main_main找到主函数，通过右上角的图可知输入总长度为37，且是由 PCL{} 括起来的；</p>
<p>看到while（1）和switch 再根据题目名称，可知道这是个类似VM的东西，而根据docode变量可知第一站经过的便是右下角图中的函数，作用是把flag括起来的32个长度内容两两拼接成十六进制数，一共变成16个；</p>
<p>然后便是对不同指令码对应操作进行翻译：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/08/7d5ef9ba61931d33.png" alt="do"></p>
<p>逻辑就是每次经过AA开始判断，如果错误就退出程序，直到走完全部的code码就算成功；</p>
<p>把翻译的写成代码然后用z3来解：(重要代码)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s = Solver()</span><br><span class="line">flag = [BitVec(<span class="string">&#x27;flag[%d]&#x27;</span> % i,<span class="number">64</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>():</span></span><br><span class="line">    <span class="keyword">global</span> ip</span><br><span class="line">    <span class="keyword">global</span> code</span><br><span class="line">    <span class="keyword">global</span> ex</span><br><span class="line">    <span class="keyword">if</span> ip + <span class="number">2</span> &gt;= <span class="number">374</span> :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ip out of range&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    s.add(ex[code[ip+<span class="number">1</span>]] == ex[code[ip+<span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ip &gt;= <span class="number">374</span>:</span><br><span class="line">        <span class="keyword">if</span> s.check() == sat:</span><br><span class="line">            <span class="built_in">print</span>(s.model())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>解出数字后换成十六进制再拼写在一起便得到：<strong>PCL{bdcc4f46d73ec09ee628633d2f227b47}</strong></p>
<h2 id="5-analgo"><a href="#5-analgo" class="headerlink" title="5.analgo"></a>5.analgo</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/e9e40cfe728b32f2.png" alt="main"></p>
<p>第一眼看去会和上道题很像，也是类似虚拟机的构造，v23是指令，main_anal函数是虚拟机函数，下面的十六进制数是比较数据，判断输入的长度是42；</p>
<p>但是由于这个VM反编译出很多控制数不好分析各个指令码在做什么，同时发现输入是包含flag{}的，且每输入一个，比较结果也对应的变换一个，称之为一一对应；(蓝线是对应关系)</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/aa4c8dee1829543b.png" alt="company"></p>
<p>可以看到随着 flag{ 的输入，每输入一个，RCX 和 RDX 就相同一个字节；</p>
<p>那么可以使用之前hgame中 hardasm 题目的解法，将加密后的RCX值输出，与比较数据判断从而爆破；</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/802a1bcea8cfff64.png" alt="patch0"></p>
<p>先把判断搞掉，全nop，直接进入输出 wrong（SecondBC） 的地方；之后修改原程序比较的地方，改为将加密数据放到 SecondBC 这个地方：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/57ca9cd0558166a6.png" alt="patch1"></p>
<p>但因为 SecondBC 是 rdata段的，拥有只读权限，所以要修改权限：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/08/10/fb73adfe949db76d.png" alt="change"></p>
<p>搜索 .rdata，将 40 00 00 40 改为 40 00 00 C0； </p>
<p>之后写代码爆破：（使用subprocess模组）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ans = <span class="string">&#x27;this is answer&#x27;</span>        <span class="string">&#x27;&#x27;&#x27;比较数据&#x27;&#x27;&#x27;</span></span><br><span class="line">hexs = <span class="string">&#x27;0123456789abcdef-&#x27;</span>		<span class="string">&#x27;&#x27;&#x27;约束范围，输入其他的程序会提前退出&#x27;&#x27;&#x27;</span></span><br><span class="line">hexs = <span class="built_in">list</span>(hexs)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">17</span>):</span><br><span class="line">    hexs[i] = <span class="built_in">ord</span>(hexs[i])</span><br><span class="line"></span><br><span class="line">real_flag=<span class="string">&quot;flag&#123;&quot;</span></span><br><span class="line">cur_index = <span class="number">5</span>		<span class="string">&#x27;&#x27;&#x27;当前位置&#x27;&#x27;&#x27;</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cur_index &lt; <span class="number">42</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> hexs:				</span><br><span class="line">        real_flag_arr = [<span class="number">0</span>] * <span class="number">42</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_flag)):					<span class="string">&#x27;&#x27;&#x27;爆破储存位置&#x27;&#x27;&#x27;</span></span><br><span class="line">            real_flag_arr[j] = <span class="built_in">ord</span>(real_flag[j])</span><br><span class="line">        real_flag_arr[<span class="built_in">len</span>(real_flag_arr)-<span class="number">1</span>] = <span class="built_in">ord</span>(<span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_flag_arr)-<span class="number">2</span>,cur_index,-<span class="number">1</span>):</span><br><span class="line">            real_flag_arr[j] = <span class="number">48</span>				<span class="string">&#x27;&#x27;&#x27;未知位填充0&#x27;&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        real_flag_arr[cur_index] = i</span><br><span class="line">        real_flag_arr_s = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> real_flag_arr)</span><br><span class="line">        p = subprocess.Popen([<span class="string">&quot;C:\\Users\\Second_BC\\Desktop\\analgo.exe&quot;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">        p.stdin.write(real_flag_arr_s.encode())		<span class="string">&#x27;&#x27;&#x27;输入程序&#x27;&#x27;&#x27;</span></span><br><span class="line">        p.stdin.close()</span><br><span class="line">        out = p.stdout.read()		<span class="string">&#x27;&#x27;&#x27;读取输出&#x27;&#x27;&#x27;</span></span><br><span class="line">        out = <span class="built_in">list</span>(out)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out[k] == ans[k] ):</span><br><span class="line">            real_flag += <span class="built_in">chr</span>(i)</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            cur_index += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(real_flag)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>由于这个程序是 8字节 8字节来比较的，所以手动多调几次，传入之前先 add rsi 8 获取之后的加密数据；</p>
<p>然后每轮都改下cur_index += 8；</p>
<p>然后得到：<strong>flag{568a3cdd-77e1-4c42-9fee-127e27a5744e}</strong></p>
<h2 id="6-puzzle"><a href="#6-puzzle" class="headerlink" title="6.puzzle"></a>6.puzzle</h2><p>一开始发现是个加壳程序，跑一遍发现和UPX加壳很像，一开始是循环解码，然后进入原入口；用PE也显示其为UPX加壳，但是提示不能用指令脱壳；</p>
<p>使用十六进制查看器发现原UPX标记处被改为了vmp，将其改回并用指令对其脱壳；</p>
<p><img src="https://s2.loli.net/2022/08/18/iNmo4yPxY3CDvdu.png" alt="unpack"></p>
<p>之后进去过后看IDA：</p>
<p><img src="https://s2.loli.net/2022/08/18/QlHr3EZWxiqSUIa.png" alt="main"></p>
<p>在scanf之后的是一段循环，通过调试可以知道，这里允许通过 0 ~ 9 字符，并且一共输入56个，否则失败；</p>
<p>这段循环将输入的56个数字放到一些地址里，而地址原来就有些数据；填完之后一共是 9*9 = 81个数据；</p>
<p>然后来到判断 judge 函数，这里它将这81个内容作为参数传入；</p>
<p>经过调试呢，可以发现，输入的内容中，有些是不能重复的，而且不能有 0 ；这可以让想起数独游戏；</p>
<p>把里面给的数据拿出来做成 9 * 9 的数独表，然后进行求解：</p>
<p><img src="https://s2.loli.net/2022/08/18/QNplakuqID2Zjdi.png" alt="solve"></p>
<p>解出输入的56个内容为：<strong>76135283549798674164925733849217386455934161872359295314</strong></p>
<p>输入源程序之后，便得到： <strong>flag{23c3cb3aedbbfdd009d1bf52e530676a}</strong></p>
</div></div><a class="button-hover more" href="/SecondBC/2022/08/18/%E5%81%87%E6%9C%9F%E5%A4%8D%E7%8E%B0/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/04/23/Shell-Lab/">Shell_Lab</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/CSAPP/">CSAPP</a></div></div><div class="post-content"><div class="main-content content"><p>壳实验，对应于csapp第8章，异常控制流；根据其提示可知，该实验要求编写一个完整的简单的壳；</p>
<p>在完成之后，有许多的检测关卡等待壳的成果；</p>
<p>实际上，此实验已经将大部分内容编写完毕，只要求完成7个函数的构造来完整壳即可；</p>
<p>这7个函数都是有关于信号，以及异常处理的；</p>
<h2 id="现在来先说说这7个函数的大致功能以及目的："><a href="#现在来先说说这7个函数的大致功能以及目的：" class="headerlink" title="现在来先说说这7个函数的大致功能以及目的："></a>现在来先说说这7个函数的大致功能以及目的：</h2><ol>
<li><p>eval：解析和解释命令行的主例程；</p>
</li>
<li><p>builtin_cmd：识别并解释内置命令；</p>
<ul>
<li><p>内置命令：</p>
</li>
<li><p>quit：退出shell；</p>
</li>
<li><p>fg：发送 SIGCONT（继续）来重启 job，位于前台运行；（前台只允许1个job运行）</p>
</li>
<li><p>bg：发送 SIGCONT（继续）来重启 job，位于后台运行；</p>
</li>
<li><p>jobs：列出所有后台作业；</p>
</li>
</ul>
</li>
<li><p>do_bgfg：执行bg和fg指令；</p>
</li>
<li><p>waitfg：等待前台作业完成；</p>
</li>
<li><p>sigchld_handler：SIGCHLD（子程序退出）信号处理；</p>
</li>
<li><p>sigint_handler：SIGINT（中断）信号处理；</p>
</li>
<li><p>sigtstp_handler：SIGTSTP（暂停）信号处理；</p>
</li>
</ol>
<h2 id="辅助的已有函数："><a href="#辅助的已有函数：" class="headerlink" title="辅助的已有函数："></a>辅助的已有函数：</h2><ul>
<li>parseline：解析命令行构建argv列表；</li>
<li>clearjob：清除job结构体中的内容；</li>
<li>initjobs：初始化job列表；</li>
<li>maxjid：返回允许的最大job ID；</li>
<li>addjob：添加一个作业到job列表；</li>
<li>deletejob：从job列表中删除pid的作业；</li>
<li>fgpid：返回前台job的pid；</li>
<li>getjobpid：根据pid从job列表中找到作业；</li>
<li>getjobjid：根据job ID从job列表中找到作业；</li>
<li>pid2jid：根据pid返回对应jid；</li>
<li>listjobs：显示job列表；</li>
</ul>
<h2 id="之后有经典的实验约束规则："><a href="#之后有经典的实验约束规则：" class="headerlink" title="之后有经典的实验约束规则："></a>之后有经典的实验约束规则：</h2><ul>
<li>提示符为：tsh&gt;</li>
<li>用户键入的命令行应包含一个名称和零个或多个参数，所有参数均由一个或多个空格分隔。 如果名称是内置命令，则shell应该立即处理它并等待下一个命令行；否则，shell应该假定名称是可执行文件的路径，它在初始子进程的上下文中加载并运行；</li>
<li>shell不用支持管道或I/O重定向；</li>
<li>输入 ctrl-c 导致 SIGINT （输入 ctrl-z 导致 SIGTSTP）发送到当前前台作业以及该作业的任何后代，如果没有前台作业，那么信号没有效果；</li>
<li>如果命令行以 &amp; 结束，则shell应该在后台运行作业，否则它将在前台运行该作业；</li>
<li>每个作业都可以通过进程ID（PID）或作业ID（JID）进行标识，该ID是tsh分配的正整数；</li>
<li>shell支持内置命令；</li>
<li>shell应该回收所有僵死子进程，如果任何作业由于接收到未捕获到的信号而终止，则shell应该识别此事件并打印一条消息，其中包含该作业的PID和有问题的信号的描述；</li>
</ul>
<h2 id="先来看Shell的主函数："><a href="#先来看Shell的主函数：" class="headerlink" title="先来看Shell的主函数："></a>先来看Shell的主函数：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read command line */</span></span><br><span class="line">	<span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">	    app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evaluate the command line */</span></span><br><span class="line">	eval(cmdline);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个while是在选择模式；输入h参数显示提示，输入v参数发出附加诊断信息，输入p不显示命令行；</p>
<p>之后需要捕获信号，就需要通过Signal函数将信号和对应处理函数绑定，然后进入第二个while使用eval一条一条地重复解析输入的内容；</p>
<h2 id="I-Eval"><a href="#I-Eval" class="headerlink" title="I . Eval"></a>I . Eval</h2><p>第一解析命令行，可以套用parseline函数来帮忙，并根据结尾符号是否为 &amp; 来判断前后台关系；</p>
<p>第二要做到的，查看解析出的 argv[0] 是否为内置命令，是，则转交给builtin_cmd函数，不是则创建子进程来运行；之后在shell中通过 addjob 来添加作业，如果是前台作业，就等待前台作业运行完毕，如果是后台作业，就执行解析下一条命令；</p>
<p>由此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> *buf = <span class="built_in">array</span>;		<span class="comment">//cmdline容器 </span></span><br><span class="line">	<span class="keyword">char</span> *argv[MAXARGS];	<span class="comment">//命令行参数 </span></span><br><span class="line">	<span class="keyword">int</span> bg;		<span class="comment">//前后台？ </span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;		<span class="comment">//进程id </span></span><br><span class="line">	<span class="keyword">sigset_t</span> mask, prev, all;	<span class="comment">//阻塞块 </span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">strcpy</span>(buf,cmdline);</span><br><span class="line">	bg = parseline(buf,argv);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(!builtin_cmd(argv))	<span class="comment">//是否内置命令 </span></span><br><span class="line">	&#123;</span><br><span class="line">		sigemptyset(&amp;mask);		<span class="comment">//清空mask块 </span></span><br><span class="line">		sigaddset(&amp;mask,SIGCHLD);	<span class="comment">//添加SIGCHLD到mask </span></span><br><span class="line">		sigfillset(&amp;all);	<span class="comment">//所有信号进入all块 </span></span><br><span class="line">		sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev)	<span class="comment">//阻塞SIGCHLD信号，防止addjob和deletejob竞争</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)	<span class="comment">//子进程 </span></span><br><span class="line">		&#123;</span><br><span class="line">			fflush(sdout);	<span class="comment">//printf(&quot;in process:%d\n&quot;,pid);</span></span><br><span class="line">			setpgid(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//更换子进程进程组，以免和shell冲突</span></span><br><span class="line">			sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">if</span>(execve(argv[<span class="number">0</span>],agrv,environ) &lt; <span class="number">0</span>)	<span class="comment">//通过execve加载到子进程</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//printf(&quot;parent:%d\n&quot;,getpid());</span></span><br><span class="line">		sigprocmask(SIG_BLOCK,&amp;all,<span class="literal">NULL</span>) <span class="comment">//访问job列表需阻塞所有信号 </span></span><br><span class="line">		addjob(jobs,pid,bg?BG:FG,buf);</span><br><span class="line">		sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>)	<span class="comment">//解除阻塞</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(bg)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, buf);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			waitfg(pid);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的有两点：</p>
<ul>
<li>阻塞SIGCHLD信号以防止addjob与deletejob竞争；</li>
<li>访问全局数据jobs列表前阻塞所有信号；</li>
</ul>
<p>为什么要在fork创建进程之前阻塞SIGCHLD呢？因为fork的进程可能在任意时刻暂停或终止；使得Shell跳转通过对应信号去处理程序，并在信号处理中对该作业进行修改；如果在 addjob 之前跳转，则会由于未保存该作业而导致错误，所以需要在fork之前阻塞，并在子进程中取消阻塞；</p>
<p>设置独立的进程组与Shell分开，以免Shell接收到的其他例如 ctrl-c 之类的信号而导致进程受到影响；</p>
<p>其次，从安全信号处理的角度，在修改读取jobs时如果不阻塞所有信号，则会有可能中断而导致jobs的各部分状态不同；</p>
<h2 id="II-builtin-cmd"><a href="#II-builtin-cmd" class="headerlink" title="II . builtin_cmd"></a>II . builtin_cmd</h2><p>第一，前面可以知道用这个函数套用在eval里，使得分辨是否为内置命令，所以让内置命令返回1，而非内置命令返回0；</p>
<p>第二，已知这个函数会用于bg和fg的内置命令，所以可以套用do_bgfg的函数；</p>
<p>那么代码就可知了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		listjobs(jobs);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>((!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>)) || (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		do_bgfg(argv);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="III-do-bgfg"><a href="#III-do-bgfg" class="headerlink" title="III . do_bgfg"></a>III . do_bgfg</h2><p>根据之前提到的，需要用用到SIGCONT信号，那么也需要使用kill来发送给整个进程组；</p>
<p>在这之前需要修改job结构的状态；</p>
<p>而在修改前台或者后台的再之前，需要寻找到这个工作的ID或者pid；</p>
<p>由此代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> jid;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span>	<span class="comment">//单独的job指针 </span></span><br><span class="line">	<span class="keyword">sigset_t</span> mask,prev;	<span class="comment">//修改job之前阻塞所有信号</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%%%d&quot;</span>,&amp;jid) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		job = getjobjid(jobs,jid);</span><br><span class="line">		<span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%d&quot;</span>,&amp;pid) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		job = getjobpid(jobs, pid);</span><br><span class="line">		<span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%s): No such process\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面的都是在排除异常情况</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//修改job状态</span></span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))</span><br><span class="line">		job-&gt;state = FG;</span><br><span class="line">	<span class="keyword">else</span>	</span><br><span class="line">		job-&gt;state = BG;</span><br><span class="line">	</span><br><span class="line">	sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	pid = job-&gt;pid;</span><br><span class="line">	kill(-pid,SIGCONT); <span class="comment">//负的则发送给进程组</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))</span><br><span class="line">		waitfg(pid);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, pid, job-&gt;cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IV-waitfg"><a href="#IV-waitfg" class="headerlink" title="IV . waitfg"></a>IV . waitfg</h2><p>等待前台作业完成就使用sleep挂起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(pid == fgpid(jobs))</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="V-sigint-handler"><a href="#V-sigint-handler" class="headerlink" title="V . sigint_handler"></a>V . sigint_handler</h2><p>当使用 Ctrl+c ，内核发送中断信号给这个Shell程序，而Shell程序通过kill发送信号给子进程，而停止信号也同理；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">    </span><br><span class="line">	errno = old_errno; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存之前的errno并在返回时重新赋值，是为了防止它被改变；</p>
<h2 id="VI-sigstp-handler"><a href="#VI-sigstp-handler" class="headerlink" title="VI . sigstp_handler"></a>VI . sigstp_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">        </span><br><span class="line">	errno = old_errno; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="VII-sigchld-handler"><a href="#VII-sigchld-handler" class="headerlink" title="VII . sigchld_handler"></a>VII . sigchld_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line">	<span class="keyword">int</span> state;	<span class="comment">//保存waitpid的状态，用来判断子进程是终止还是停止</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">	</span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	<span class="comment">//由于信号不存在队列，而waitpid一次只会回收一个子进程，所以用while</span></span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)	<span class="comment">//要检查停止和终止的，并且不要卡在这个循环中</span></span><br><span class="line">    &#123;	</span><br><span class="line">		<span class="comment">//对全局结构变量jobs进行修改时，要阻塞所有信号</span></span><br><span class="line">		sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(state))	<span class="comment">//子进程通过调用exit或return正常终止，需要从jobs中删除该作业</span></span><br><span class="line">         &#123;	</span><br><span class="line">			deletejob(jobs, pid);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(state))	<span class="comment">//子进程因为一个未捕获的信号终止</span></span><br><span class="line">         &#123;	</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(state));		</span><br><span class="line">			deletejob(jobs, pid);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(state))	<span class="comment">//如果子进程是停止的，需要修改改作业的状态</span></span><br><span class="line">         &#123;	</span><br><span class="line">			job = getjobpid(jobs, pid);</span><br><span class="line">			job-&gt;state = ST;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, pid, WSTOPSIG(state));</span><br><span class="line">		&#125;</span><br><span class="line">		sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);	<span class="comment">//恢复信号接收</span></span><br><span class="line">	&#125;</span><br><span class="line">	errno = old_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这个实验主要是考察了安全信号处理内容，以及竞争关系；</p>
<p>帮助疏通了对Shell的理解：接受指令，处理指令，以及增加进程和如何回收进程；</p>
<p>对于小方向的话便是细节的考虑，阻塞顺序以及分类情况；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/04/23/Shell-Lab/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/03/31/Angr-Lab/">Angr.Lab</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-10-16</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Reverse/">Reverse</a></div></div><div class="post-content"><div class="main-content content"><p><img src="https://s2.loli.net/2022/03/30/hbgQv6Ia4yrLf7n.jpg" alt="EldenRing"></p>
<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>angr是一款针对于CTF的工具，说实话并不觉的它对复杂的逆向程序有什么更优的作用；</p>
<p>它的常用功能则是根据使用者自己写的求解约束，附加在程序上计算如何输入进而求出得到的效果来获取正确输入，类似一款爆破计算器；</p>
<p>如何下载呢？ 终端输入 -&gt; pip install angr；</p>
<p>具体的练习上手题则需要去GitHub上搜寻：<a target="_blank" rel="noopener" href="https://github.com/jakespringer/angr_ctf%EF%BC%9B">https://github.com/jakespringer/angr_ctf；</a></p>
<h2 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h2><p>Project -&gt; 附加的程序，在angr里叫项目；</p>
<p>State -&gt; 状态，模拟的PC所指；</p>
<p>Simulation -&gt; 模拟空间，为状态不断更新使程序执行指令，模拟运行所提供空间；</p>
<p>Explore -&gt; 模拟运行程序并附加内容；</p>
<p>这4个便是angr使用的主要内容，基本解题脚本都离不开这4个，接下来就用GitHub上的题目来一一解释使用方法，以及进阶内容；</p>
<h2 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h2><p>IDA分析：</p>
<p><img src="https://s2.loli.net/2022/03/30/8Z4CAd5jameBzDf.png" alt="main"></p>
<p>一个很简单的函数，按照介绍所说，需要让angr帮忙计算出输入的内容就是这里的比较数据：FPQPMQXT；那要怎么去写约束得到正确的输入呢？当然是要让状态走到输出’Good Job.’这一条，而不能走向’Try again.’；如此一来输入只能是比较数据；所以找到这条指令的地址：</p>
<p><img src="https://s2.loli.net/2022/03/30/T54nzFD2HIkCuKZ.png" alt="address"></p>
<p>接下来就可以写执行脚本了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    <span class="comment"># 目标文件的路径</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;../program/00_angr_find&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    print_good_addr = <span class="number">0x0804867D</span></span><br><span class="line">    simulation.explore(find=print_good_addr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果到达目标地址，打印此时的符号向量</span></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="comment"># 否者抛出失败异常</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>运用sys库是需要得到标准输入 -&gt; sys.stdin.fileno() ；</p>
<p>angr.Project(执行的二进制文件地址)  -&gt;  打开二进制文件；</p>
<p>project.factory.entry_state()  -&gt;  创建空白的执行环境；</p>
<p>project.factory.simgr(上下文对象)  -&gt;  创建模拟器；</p>
<p>simulation.explore(find = 搜索程序执行路径的地址)  -&gt;  执行路径探索；</p>
</blockquote>
<h2 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h2><p>这道题和00其实很像，只是在main函数里塞了很多大量的垃圾代码，直接用find输出正确的地址就找不到；</p>
<p>看到maybe_good函数：</p>
<p><img src="https://s2.loli.net/2022/03/30/J2PwhoM1bspqk9i.png" alt="function"></p>
<p>以及在main函数里经常出现的avoid_me函数：</p>
<p><img src="https://s2.loli.net/2022/03/30/xlSMaPVQiojsZ9E.png" alt="function"></p>
<p>可以知道，如果进入了avoid_me后，再进入maybe_good就与输出Good Job无缘了，所以在寻找怎样输入才能导致输出正确的时候，可以再加一个约束，约束状态不要进入avoid_me；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    <span class="comment"># 目标文件的路径</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;../program/01_angr_avoid&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    print_good_addr = <span class="number">0x080485E0</span></span><br><span class="line">    aovid_me_addr = <span class="number">0x080485A8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># simulation.explore(find=print_good_addr)</span></span><br><span class="line">    <span class="comment"># avoid=try_again_addr</span></span><br><span class="line">    <span class="comment"># 在这里可以添加 avoid 来约束到达的目的地址 </span></span><br><span class="line">    simulation.explore(find=print_good_addr, avoid=aovid_me_addr)</span><br><span class="line">    <span class="comment"># 如果到达目标地址，打印此时的符号向量</span></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="comment"># 否者抛出失败异常</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>simulation.explore(find = 要搜索的路径地址, avoid = 要排除执行路径地址)  -&gt;  路径探索</p>
<p>simulation.found  -&gt;  搜索结果集合,这是一个python list 对象</p>
</blockquote>
<h2 id="02-angr-find-condition"><a href="#02-angr-find-condition" class="headerlink" title="02_angr_find_condition"></a>02_angr_find_condition</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/30/Dnm1Bj4rKiChJfg.png" alt="main"></p>
<p>与00比较，在进行判断字符串的时候进行了一次运算，而在汇编层可以看到 puts(“Good Job.”) 这条指令来自很多地址，被混淆打乱了：</p>
<p><img src="https://s2.loli.net/2022/03/30/XkHdqKc9r7tuYZS.png" alt="Xrefs"></p>
<p>所以这次不能用 find=地址 来得到要找到的正确输入了；所以需要构建explore() 函数的回调函数；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到达目标地址，打印此时的符号向量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">good_job</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 否则抛出失败异常</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_again</span>(<span class="params">state</span>):</span> </span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">    path_to_binary = <span class="string">&#x27;./02_angr_find_condition&#x27;</span></span><br><span class="line">    <span class="comment"># 创建angr项目</span></span><br><span class="line">    project = angr.Project(path_to_binary)</span><br><span class="line">    <span class="comment"># 设置项目起点，entry_state代表程序的入口点，即main函数</span></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    <span class="comment"># 设置模拟器</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    <span class="comment"># 设置目标地址</span></span><br><span class="line">    simulation.explore(find=good_job, avoid=try_again) </span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>simulation.explore(find = 回调函数, avoid = 回调函数)  -&gt;  路径探索</p>
<blockquote>
<p>explore() 函数的回调函数格式为:</p>
<p>def recall_explore(state) :</p>
<p>​    …</p>
<p>​    return True / False  #  True 意思是发现了该路径,False 则是忽略</p>
</blockquote>
<p>state.posix.dumps(sys.stdout.fileno())  -&gt;  获取模拟执行的控制台输出</p>
</blockquote>
<h2 id="03-angr-symbolic-registers"><a href="#03-angr-symbolic-registers" class="headerlink" title="03_angr_symbolic_registers"></a>03_angr_symbolic_registers</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/30/RmAD4btvglsqCJf.png" alt="main"></p>
<p>这次让输入三次内容，三次经过不同的加密，最后经过 if 判断来找结果；</p>
<p>汇编层：</p>
<p><img src="https://s2.loli.net/2022/03/30/h2LQfuzHmk3GMxw.png" alt="asam"></p>
<p>虽然伪代码显示v5，v6，v8都变量都是栈里的数据，但汇编层显示出，它们是由寄存器eax，ebx，edx搬运进栈后才会是对应栈数据；</p>
<p>那么已知运算结果（怎样是正确的输出），以及运算过程由angr自己去运行；那么就需要设未知数进行求解，把寄存器设为未知数的过程，便称为符号化寄存器，也可以叫变量化寄存器；这一步就类似于Z3里的设置未知变量模型了；</p>
<p>这里需要用到一个库：claripy，下载angr自带的；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/03_angr_symbolic_registers&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 设置项目开始地址</span></span><br><span class="line">    start_addr = <span class="number">0x0804890E</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">   <span class="comment"># 将寄存器符号化</span></span><br><span class="line">    bit_length = <span class="number">32</span></span><br><span class="line">    psd0 = claripy.BVS(<span class="string">&#x27;psd0&#x27;</span>, bit_length)</span><br><span class="line">    psd1 = claripy.BVS(<span class="string">&#x27;psd1&#x27;</span>, bit_length)</span><br><span class="line">    psd2 = claripy.BVS(<span class="string">&#x27;psd2&#x27;</span>, bit_length)</span><br><span class="line">	<span class="comment"># 将符号化的寄存器对应到相应的寄存器</span></span><br><span class="line">    initial_state.regs.eax = psd0</span><br><span class="line">    initial_state.regs.ebx = psd1</span><br><span class="line">    initial_state.regs.edx = psd2</span><br><span class="line">	<span class="comment"># 设置模拟</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">good_job</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_content = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_content</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fail</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_content = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_content</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=good_job, avoid=fail)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(psd0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(psd1)</span><br><span class="line">        solution2 = solution_state.se.<span class="built_in">eval</span>(psd2)</span><br><span class="line"></span><br><span class="line">        solution = <span class="string">&#x27;%x %x %x&#x27;</span> % (solution0, solution1, solution2)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>project.factory.blank_state(addr=start_address)  -&gt;  创建自定义入口的状态上下文</p>
<p>initial_state.regs  -&gt;  操作状态上下文的寄存器</p>
<p>claripy.BVS(‘变量名’, 变量大小)  -&gt;  创建求解变量</p>
<p>solution_state.se.eval(变量)  -&gt;  求解符号变量</p>
<p>solution = ‘%x %x %x’ % (solution0, solution1, solution2) -&gt; 标准输出格式</p>
</blockquote>
<h2 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/28c8ec86fc754aea.png" alt="function"></p>
<p>这个函数是main里的唯一一个指令；查看汇编可以发现v1，v2变量不是由寄存器传到栈上，是直接输入的栈上的，那么这次做的便是符号化栈；将栈上的数据设置为未知数，所以需要去平衡栈；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./04_angr_symbolic_stack&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048697</span> <span class="comment">#scanf之后的地址</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    initial_state.regs.ebp = initial_state.regs.esp <span class="comment"># 初始化栈，令ebp等于esp</span></span><br><span class="line"></span><br><span class="line">    password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>) <span class="comment"># 初始化两个位向量</span></span><br><span class="line">    password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    padding_length_in_bytes = <span class="number">8</span> <span class="comment"># 填充栈，8字节，2个int数据</span></span><br><span class="line">    initial_state.regs.esp -= padding_length_in_bytes </span><br><span class="line"></span><br><span class="line">    initial_state.stack_push(password0) <span class="comment"># 将位向量压入栈中</span></span><br><span class="line">    initial_state.stack_push(password1)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line"></span><br><span class="line">        solution = <span class="string">&#x27;%u %u&#x27;</span> % (solution0, solution1)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h2 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/174e359750faabcd.png" alt="main"></p>
<p>发现这次输入的内容被存到了4个地方，这4个地方都是.bss段上的内存（unk开头的指针以及user_input），之后计算并比较；和之前2题一样，这次需要的是符号化内存；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./05_angr_symbolic_memory&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048601</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>) <span class="comment"># 64 = 8(8个字符) * 1(每个字符一字节) * 8(每个字节8比特)</span></span><br><span class="line">    password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    password3 = claripy.BVS(<span class="string">&#x27;password3&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    password0_addr = <span class="number">0x09FD92A0</span></span><br><span class="line">    password1_addr = <span class="number">0x09FD92A8</span></span><br><span class="line">    password2_addr = <span class="number">0x09FD92B0</span></span><br><span class="line">    password3_addr = <span class="number">0x09FD92B8</span></span><br><span class="line"></span><br><span class="line">    initial_state.memory.store(password0_addr, password0) <span class="comment"># 将位向量存入内存</span></span><br><span class="line">    initial_state.memory.store(password1_addr, password1)</span><br><span class="line">    initial_state.memory.store(password2_addr, password2)</span><br><span class="line">    initial_state.memory.store(password3_addr, password3)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line">        solution2 = solution_state.se.<span class="built_in">eval</span>(password2)</span><br><span class="line">        solution3 = solution_state.se.<span class="built_in">eval</span>(password3)</span><br><span class="line">        solution = long_to_bytes(solution0)+<span class="string">b&#x27; &#x27;</span>+long_to_bytes(solution1)+<span class="string">b&#x27; &#x27;</span>+long_to_bytes(solution2)+<span class="string">b&#x27; &#x27;</span>+long_to_bytes(solution3)</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>initial_state.memory.store(地址,数据)  -&gt;  初始化内存地址中的数据</p>
<p>long_to_byte函数 -&gt; 规范输出</p>
</blockquote>
<h2 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/4b267144916e1411.png" alt="main"></p>
<p>可以看到这次用了malloc分配了动态内存，而scanf输入则直接放到了这些内存上，下面步骤都和之前一样，所以这次要做的就是符号化动态内存；但动态内存没有固定的地址，所以需要用到buffer在.bss段上的指针；Angr可以不用创建新内存(malloc),直接指向内存中一个任意位置即可；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/06_angr_symbolic_dynamic_memory&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048699</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">    fake0_addr = <span class="number">0x09FD9160</span> <span class="comment"># 伪造malloc得来的内存</span></span><br><span class="line">    fake1_addr = <span class="number">0x09FD9180</span></span><br><span class="line"></span><br><span class="line">    buffer0_addr = <span class="number">0x09FD92AC</span> <span class="comment"># 指向伪造内存的指针</span></span><br><span class="line">    buffer1_addr = <span class="number">0x09FD92B4</span></span><br><span class="line">    initial_state.memory.store(buffer0_addr, fake0_addr, endness=project.arch.memory_endness) <span class="comment"># 将指针指向伪造的内存</span></span><br><span class="line">    initial_state.memory.store(buffer1_addr, fake1_addr, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">    initial_state.memory.store(fake0_addr, password0) <span class="comment"># 将伪造的内存符号化</span></span><br><span class="line">    initial_state.memory.store(fake1_addr, password1)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution0 = solution_state.se.<span class="built_in">eval</span>(password0)</span><br><span class="line">        solution1 = solution_state.se.<span class="built_in">eval</span>(password1)</span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution0) + <span class="string">b&#x27; &#x27;</span> + long_to_bytes(solution1)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>initial_state.memory.store(地址,数据,endness = 数据字节顺序)  -&gt;  设置初始化内存数据</p>
<p>project.arch.memory_endness  -&gt;  指的是内存字节顺序</p>
</blockquote>
<h2 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h2><p>IDA：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/a61f5ee41e1b482f.png" alt="main"></p>
<p>ignore_me函数：</p>
<p><img src="https://i.bmp.ovh/imgs/2022/03/30/101a56701648fc3c.png" alt="ignore_me"></p>
<p>输入的内容先保存到buffer里，接着用ignore_me函数将buffer里的内容存到叫做MRXJKZYR.txt的新建文件里；之后返回到主函数，初始化buffer；然后打开这个新建文件，读取里面的内容再到buffer里，最后运算比较；这次需要做的便是符号化文件；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;../program/07_angr_symbolic_file&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x080488EA</span></span><br><span class="line"></span><br><span class="line">    filename = <span class="string">&#x27;MRXJKZYR.txt&#x27;</span> <span class="comment"># 文件名称</span></span><br><span class="line">    symbolic_file_size_bytes = <span class="number">64</span> <span class="comment"># 文件大小(字节)</span></span><br><span class="line"></span><br><span class="line">    password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, symbolic_file_size_bytes * <span class="number">8</span>) <span class="comment"># 初始化位向量</span></span><br><span class="line">    password_file = angr.SimFile(filename, content=password, size=symbolic_file_size_bytes) <span class="comment"># 符号化文件</span></span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr, fs=&#123;filename: password_file&#125;) <span class="comment"># 再初始状态中添加一个虚拟的文件系统</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution_state.solver.<span class="built_in">eval</span>(password))</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find solution&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>angr.storage.SimFile(文件名,文件内容, size = 文件大小)  -&gt;  创建一个模拟文件,当有被执行的程序fopen 打开文件时,可以控制其里面的内容</p>
<p>initial_state.posix.fs  -&gt;  状态上下文的文件系统对象</p>
</blockquote>
<h2 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/PeBklpfoj2Z5TRz.png" alt="main"></p>
<p>输入字串后进行加密，之后经过检查函数判断；</p>
<p>这次可以控制输入的内容最后导致password地址的字串是否变为了正确的；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./08_angr_constraints&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    start_addr = <span class="number">0x08048625</span> <span class="comment"># 在输入函数之后</span></span><br><span class="line">    initial_state = project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">    password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">16</span>*<span class="number">8</span>)</span><br><span class="line">    password_addr = <span class="number">0x0804A050</span></span><br><span class="line">    initial_state.memory.store(password_addr, password)</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    addr_to_check_constraint = <span class="number">0x08048669</span> <span class="comment"># 在检查函数之前</span></span><br><span class="line">    simulation.explore(find=addr_to_check_constraint)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        constrained_parameter_addr = <span class="number">0x0804A050</span> <span class="comment"># 加密后的password的地址</span></span><br><span class="line">        constrained_parameter_size_bytes = <span class="number">16</span>   <span class="comment"># password的长度(字节)</span></span><br><span class="line">        constrained_parameter_bitvector = solution_state.memory.load(constrained_parameter_addr, constrained_parameter_size_bytes)  <span class="comment"># 从内存中加载password</span></span><br><span class="line"></span><br><span class="line">        constrained_parameter_desired_value = <span class="string">&#x27;MRXJKZYRKMKENFZR&#x27;</span>  <span class="comment"># reference string</span></span><br><span class="line"></span><br><span class="line">        constrained_expression = constrained_parameter_bitvector == constrained_parameter_desired_value                               <span class="comment"># 约束表达式</span></span><br><span class="line"></span><br><span class="line">        solution_state.add_constraints(constrained_expression)    <span class="comment"># 添加约束</span></span><br><span class="line"></span><br><span class="line">        solution = long_to_bytes(solution_state.se.<span class="built_in">eval</span>(password))</span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the sokution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>solution_state.memory.load(内存地址,内存大小)  -&gt;  加载内存</p>
<p>solution_state.add_constraints(约束条件)  -&gt;  添加约束条件</p>
</blockquote>
<h2 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/Dent7jbU4ZFTHyO.png" alt="main"></p>
<p>分别输入两次加密比较；</p>
<p>这题是要求注入，模拟equals函数的功能：</p>
<p><img src="https://s2.loli.net/2022/03/31/imzJ3LxMCV2qPHn.png" alt="equals"></p>
<p>注入地址当然就是调用这个函数的地址；angr里的注入类似于CE，开辟一块新区块，然后在这里写入注入内容，最后跳回注入地址的后一地址；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./09_angr_hooks&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绕过函数的地址</span></span><br><span class="line">    check_equals_caller_addr = <span class="number">0x080486A9</span></span><br><span class="line">    <span class="comment"># 通过 hook 跳过目标函数的长度</span></span><br><span class="line">    instruction_to_skip_length = <span class="number">0x080486BB</span> - <span class="number">0x080486A9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个 hook 函数</span></span><br><span class="line">    <span class="comment"># 参数为绕过函数的地址,绕过函数长度</span></span><br><span class="line"><span class="meta">    @project.hook(<span class="params">check_equals_caller_addr, length = instruction_to_skip_length</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skip_check_equals</span>(<span class="params">state</span>):</span></span><br><span class="line">        user_input_buffer_addr = <span class="number">0x0804A054</span>  <span class="comment"># 保存输入变量地址</span></span><br><span class="line">        user_input_buffer_length = <span class="number">16</span>  <span class="comment"># 第一个 scanf 的输入长度，此处为字节大小</span></span><br><span class="line">        <span class="comment"># 将输入载入内存</span></span><br><span class="line">        user_input_string = state.memory.load(</span><br><span class="line">            user_input_buffer_addr,</span><br><span class="line">            user_input_buffer_length</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 目的字符串</span></span><br><span class="line">        check_against_string = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">        <span class="comment"># 创建判断条件 -&gt; 字符串的比较</span></span><br><span class="line">        state.regs.eax = claripy.If(</span><br><span class="line">            user_input_string == check_against_string,</span><br><span class="line">            claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),  <span class="comment"># 程序的返回值是给寄存器 eax 保存</span></span><br><span class="line">            claripy.BVV(<span class="number">0</span>, <span class="number">32</span>)  <span class="comment"># eax 为 32 bit 的寄存器，所以大小设置为 32</span></span><br><span class="line">        )  <span class="comment"># claripy.BVV(返回数据,返回 bit 大小)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line">    <span class="comment"># 开始模拟</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>Hook回调函数格式:</p>
<blockquote>
<p>@project.hook(Hook地址,执行完Hook函数后指令往后跳转n字节)<br>def skip_check_equals_(state):</p>
<p>pass</p>
</blockquote>
<p>claripy.If(条件,条件为True时的返回值,条件为False时的返回值)  -&gt;  创建条件判断</p>
<p>claripy.BVV(值,值大小)  -&gt;  创建一个数值</p>
</blockquote>
<h2 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/j3Uq5rvXifYuNGa.png" alt="main"></p>
<p>相对于上一道题更简单，只用输入一次；</p>
<p>但equals函数却混淆为了多个分支，和02一样，这样就没办法在一个地址注入；</p>
<p>所以可以用Angr 的Hook Symbol 来实现对check_equals() 函数的注入；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;./09_angr_hooks&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">mySimPro</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, user_input_addr, user_input_length</span>):</span></span><br><span class="line">            <span class="comment"># angr 输入的符号向量</span></span><br><span class="line">            angr_bvs = self.state.memory.load(</span><br><span class="line">                user_input_addr,</span><br><span class="line">                user_input_length</span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># 目标字符串</span></span><br><span class="line">            desired = <span class="string">&#x27;MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> claripy.If(</span><br><span class="line">                desired == angr_bvs, <span class="comment"># 条件判断</span></span><br><span class="line">                claripy.BVV(<span class="number">1</span>,<span class="number">32</span>), <span class="comment"># 返回值设置</span></span><br><span class="line">                claripy.BVV(<span class="number">0</span>,<span class="number">32</span>)</span><br><span class="line">            )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># hook 的函数名</span></span><br><span class="line">    check_symbol = <span class="string">&#x27;check_equals_MRXJKZYRKMKENFZB&#x27;</span></span><br><span class="line">    <span class="comment"># 创建 hook</span></span><br><span class="line">    project.hook_symbol(check_symbol,mySimPro())    <span class="comment"># 创建一个类来继承 angr.SimProcedure</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(solution.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>Hook 回调函数格式:</p>
<blockquote>
<p>class ReplacementCheckEquals(angr.SimProcedure):</p>
<p>def run(self, Hook的函数参数列表):</p>
<p>​    ….</p>
<p>​    return 函数返回值   # 如果是void函数可以省略</p>
</blockquote>
<p>project.hook_symbol(要Hook的函数名,SimProcedure类实例)</p>
</blockquote>
<h2 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/fC9AO8P2ni3cz76.png" alt="main"></p>
<p>这道题是注入系统函数scanf改变符号；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, scanf0_address, scanf1_address </span>):</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(scanf1_address, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0</span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Good Job&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Try again&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    stored_solutions0 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>]</span><br><span class="line">    stored_solutions1 = solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>]</span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(stored_solutions0)</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(stored_solutions1)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solution0,solution1)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h2 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h2><p>这个示例和01 题是一样的,唯独不同的一点是这个循环比之前的要大,导致直接用01 题的解题方法不能直接计算出结果,因为循环过大导致路径爆炸,所以在执行的时候会消耗很多资源.</p>
<p>project.factory.simgr() 函数提供veritesting 参数来指定是否要自动合并路径,避免路径爆炸的问题.具体细节参考论文:<a target="_blank" rel="noopener" href="https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf">https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf</a></p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    binary_path = <span class="string">&#x27;.//12_angr_veritesting&#x27;</span></span><br><span class="line">    project = angr.Project(binary_path)</span><br><span class="line"></span><br><span class="line">    initial_state = project.factory.entry_state()</span><br><span class="line">    simulation = project.factory.simgr(initial_state, veritesting=<span class="literal">True</span>) <span class="comment"># 设置自动合并路径</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;Could not find the solution&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>project.factory.simgr(初始化状态,veritesting = True)  -&gt;  veritesting 默认为False</p>
</blockquote>
<h2 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h2><p>与01一样，唯一不同的这个程序是静态链接编译，程序中包含libc的函数实现；在CTF中，这些函数会隐藏一些出题人的坑，或者这些函数不适配当前的系统；所以需要注入这些libc函数；</p>
<p>Angr库里自带一部分打包好的libc函数，直接导入即可；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">project = angr.Project(sys.argv[<span class="number">1</span>])</span><br><span class="line">initial_state = project.factory.entry_state()</span><br><span class="line">simulation = project.factory.simgr(initial_state,veritesting = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">project.hook(<span class="number">0x804ed40</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x804ed80</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x804f350</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">project.hook(<span class="number">0x8048d10</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)  <span class="comment"># :boolean</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">should_abort</span>(<span class="params">state</span>):</span></span><br><span class="line">  stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Try again.&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(stdout_output)  <span class="comment"># :boolean</span></span><br><span class="line"></span><br><span class="line">simulation.explore(find = is_successful,avoid = should_abort)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found :</span><br><span class="line">  solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">  <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()))</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>angr.SIM_PROCEDURES[ 系统库名 ] [ 系统函数名 ] ()  -&gt;  获取Angr 内部实现的系统函数</p>
</blockquote>
<h2 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/pr89tq3JLC5ogKu.png" alt="main"></p>
<p>类似01，但validate函数是一个动态链接库的函数；</p>
<p>对动态链接库中的_validate 函数进行符号执行；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = sys.argv[<span class="number">1</span>]  <span class="comment">#  注意是要load so 库而不是执行程序</span></span><br><span class="line"></span><br><span class="line">  base = <span class="number">0x400000</span>  <span class="comment">#  base 基址是随意定的,可以随意修改</span></span><br><span class="line">  project = angr.Project(path_to_binary, load_options=&#123;</span><br><span class="line">    <span class="string">&#x27;main_opts&#x27;</span> : &#123;</span><br><span class="line">      <span class="string">&#x27;custom_base_addr&#x27;</span> : base</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  buffer_pointer = claripy.BVV(<span class="number">0x3000000</span>, <span class="number">32</span>)  <span class="comment">#  创建一个buffer 指针值</span></span><br><span class="line">  validate_function_address = base + <span class="number">0x6D7</span></span><br><span class="line">  initial_state = project.factory.call_state(validate_function_address, buffer_pointer,claripy.BVV(<span class="number">8</span>, <span class="number">32</span>))  <span class="comment">#  调用validate_function,因为函数声明validata_function(buffer_point,buffer_length) ,所以构造出调用validata_function(0x3000000,0x8) .</span></span><br><span class="line"></span><br><span class="line">  password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">8</span> * <span class="number">8</span>)  <span class="comment">#  创建一个求解对象,大小为8 字节</span></span><br><span class="line">  initial_state.memory.store(buffer_pointer, password)  <span class="comment">#  保存到0x30000000</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  simulation.explore(find = base + <span class="number">0x783</span>)  <span class="comment">#  执行到validate 函数的RETN 指令</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution_state.add_constraints(solution_state.regs.eax != <span class="number">0</span>)  <span class="comment">#  记得,要求validate 函数的返回值为1 的时候就是有解的,那么就需要在求解的时候添加上这么一个求解约束条件EAX 不能为False .</span></span><br><span class="line">    solution = solution_state.se.<span class="built_in">eval</span>(password)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br></pre></td></tr></table></figure>



<h2 id="15-angr-arbitrary-read"><a href="#15-angr-arbitrary-read" class="headerlink" title="15_angr_arbitrary_read"></a>15_angr_arbitrary_read</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/Iml48SzeWontsDP.png" alt="main"></p>
<p>控制输入；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span>  <span class="comment">#  实现Scanf Hook 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, check_key_address,input_buffer_address</span>):</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)   <span class="comment"># check_key</span></span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">20</span> * <span class="number">8</span>)  <span class="comment"># input_buffer</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)  <span class="comment">#  对input_buffer 的输入约束</span></span><br><span class="line"></span><br><span class="line">      self.state.memory.store(check_key_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(input_buffer_address, scanf1,endness=project.arch.memory_endness)  <span class="comment">#  保存求解变量到指定的内存中</span></span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0  <span class="comment">#  保存这两个变量到state 中,后续求解需要用到</span></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())  <span class="comment">#  Hook scanf 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_puts</span>(<span class="params">state</span>):</span></span><br><span class="line">    puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)  <span class="comment">#  获取puts() 函数的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(puts_parameter):  <span class="comment">#  检查这个参数是否为符号化对象</span></span><br><span class="line">      good_job_string_address = <span class="number">0x4D525854B</span></span><br><span class="line"></span><br><span class="line">      copied_state = state.copy()  <span class="comment">#  复制执行状态上下文进行约束求解,不影响原理的执行上下文</span></span><br><span class="line"></span><br><span class="line">      copied_state.add_constraints(puts_parameter == good_job_string_address)  <span class="comment">#  puts 的参数地址是否可以被指定为0x4D525854B ,如果可以的话,那就证明这个值是可控的</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> copied_state.satisfiable():  <span class="comment">#  判断添加了上面这个约束是否有解</span></span><br><span class="line">        state.add_constraints(puts_parameter == good_job_string_address)  <span class="comment">#  如果有解的话就保存到执行的那个状态对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    puts_address = <span class="number">0x8048370</span>  <span class="comment">#  当程序执行到puts() 函数时,就认为路径探索到了这里,然后再去通过check_puts() 判断这里是否存在漏洞,告诉Angr这是不是需要找的那条执行路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">      <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>])</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>],cast_to=<span class="built_in">bytes</span>)  <span class="comment">#  输出字符串序列化的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solution0,solution1)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>state.copy()  -&gt;  复制状态上下文</p>
<p>state.satisfiable()  -&gt;  判断当前的所有约束是否有解</p>
<p>solution_state.se.eval(求解变量,cast_to=bytes)  -&gt;  序列化变量内容为字符串</p>
</blockquote>
<h2 id="16-angr-arbitrary-write"><a href="#16-angr-arbitrary-write" class="headerlink" title="16_angr_arbitrary_write"></a>16_angr_arbitrary_write</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/kJgMtn8Elydj2QO.png" alt="main"></p>
<p>控制写入内存；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, check_key ,input_buffer</span>):</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">4</span> * <span class="number">8</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">20</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(check_key, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(input_buffer, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>] = scanf0</span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_strncpy</span>(<span class="params">state</span>):</span></span><br><span class="line">    strncpy_dest = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)  <span class="comment">#  获取strncpy() 的参数,strncpy_dest ..</span></span><br><span class="line">    strncpy_src  = state.memory.load(state.regs.esp + <span class="number">8</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">    strncpy_len  = state.memory.load(state.regs.esp + <span class="number">12</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">    src_contents = state.memory.load(strncpy_src, strncpy_len)  <span class="comment">#  因为参数中只保存了地址,需要根据这个地址去获取内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(strncpy_dest) <span class="keyword">and</span> state.se.symbolic(src_contents) :  <span class="comment">#  判断dest 和src 的内容是不是符号化对象</span></span><br><span class="line">      <span class="keyword">if</span> state.satisfiable(extra_constraints=(src_contents[ -<span class="number">1</span> : -<span class="number">64</span> ] == <span class="string">&#x27;KZYRKMKE&#x27;</span> ,strncpy_dest == <span class="number">0x4D52584C</span>)):  <span class="comment">#  尝试求解,其中strncpy_dest == 0x4D52584C 的意思是判断dest 是否可控为password 的地址;src_contents[ -1 : -64 ] == &#x27;KZYRKMKE&#x27; 是判断input_buffer 的内容是否可控为&#x27;KZYRKMKE&#x27; ,因为这块内存是倒序,所以需要通过[ -1 : -64 ] 倒转(contentes 的内容是比特,获取8 字节的大小为:8*8 = 64),然后判断该值是否为字符串&#x27;KZYRKMKE&#x27;</span></span><br><span class="line">        state.add_constraints(src_contents[ -<span class="number">1</span> : -<span class="number">64</span> ] == <span class="string">&#x27;KZYRKMKE&#x27;</span>,strncpy_dest == <span class="number">0x4D52584C</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span>(<span class="params">state</span>):</span></span><br><span class="line">    strncpy_address = <span class="number">0x8048410</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.addr == strncpy_address:</span><br><span class="line">      <span class="keyword">return</span> check_strncpy(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution0 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution0&#x27;</span>])</span><br><span class="line">    solution1 = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution1&#x27;</span>],cast_to=<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(solution0,solution1)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<blockquote>
<p>state.satisfiable(extra_constraints=(条件1,条件2))  -&gt;  合并多个条件计算是否存在满足约束的解(注意两个或多个条件之间是And 合并判断,不是Or )</p>
</blockquote>
<h2 id="17-angr-arbitrary-jump"><a href="#17-angr-arbitrary-jump" class="headerlink" title="17_angr_arbitrary_jump"></a>17_angr_arbitrary_jump</h2><p>IDA：</p>
<p><img src="https://s2.loli.net/2022/03/31/WPYsm7nIjMdl1BL.png" alt="main"></p>
<p>这是一个栈溢出；</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">argv</span>):</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(</span><br><span class="line">    initial_state,</span><br><span class="line">    save_unconstrained=<span class="literal">True</span>,</span><br><span class="line">    stashes=&#123;</span><br><span class="line">      <span class="string">&#x27;active&#x27;</span> : [initial_state],</span><br><span class="line">      <span class="string">&#x27;unconstrained&#x27;</span> : [],</span><br><span class="line">      <span class="string">&#x27;found&#x27;</span> : [],</span><br><span class="line">      <span class="string">&#x27;not_needed&#x27;</span> : []</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span>(<span class="params">angr.SimProcedure</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, format_string, input_buffer_address</span>):</span></span><br><span class="line">      input_buffer = claripy.BVS(<span class="string">&#x27;input_buffer&#x27;</span>, <span class="number">64</span> * <span class="number">8</span>)  <span class="comment">#  设置一个较大的input_buffer</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> input_buffer.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">&#x27;0&#x27;</span>, char &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      self.state.memory.store(input_buffer_address, input_buffer, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">      self.state.<span class="built_in">globals</span>[<span class="string">&#x27;solution&#x27;</span>] = input_buffer</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())  <span class="comment">#  对scanf() 做Hook</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (simulation.active <span class="keyword">or</span> simulation.unconstrained) <span class="keyword">and</span> (<span class="keyword">not</span> simulation.found):  <span class="comment">#  </span></span><br><span class="line">    <span class="keyword">for</span> unconstrained_state <span class="keyword">in</span> simulation.unconstrained:</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">should_move</span>(<span class="params">s</span>):</span></span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">is</span> unconstrained_state</span><br><span class="line">      </span><br><span class="line">      simulation.move(<span class="string">&#x27;unconstrained&#x27;</span>, <span class="string">&#x27;found&#x27;</span>, filter_func=should_move)  <span class="comment">#  保存</span></span><br><span class="line"></span><br><span class="line">    simulation.step()  <span class="comment">#  步进执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution_state.add_constraints(solution_state.regs.eip == <span class="number">0x4D525849</span>)  <span class="comment">#  判断EIP 地址是否可控</span></span><br><span class="line"></span><br><span class="line">    solution = solution_state.se.<span class="built_in">eval</span>(solution_state.<span class="built_in">globals</span>[<span class="string">&#x27;solution&#x27;</span>],cast_to = <span class="built_in">bytes</span>)  <span class="comment">#  生成Payload</span></span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>00<del>02讲解的是基础操作；03</del>07讲解的是符号化常见内容；08讲解的是求解内容约束；09<del>08讲解如何注入来替换函数或者增加函数；11</del>14讲解的都是进阶的内容；15~17讲解的都和控制有关，与pwn题相关；</p>
<p>真正吃透angr会花更多的时间，但真正强化二进制能力的并不是如何去使用angr，而是明白angr函数针对于汇编层的操作；</p>
</div></div><a class="button-hover more" href="/SecondBC/2022/03/31/Angr-Lab/#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/SecondBC/2022/02/24/VM%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/">VM实验复现</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2022-12-12</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Bin/">Bin</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/VM/">VM</a></div></div><div class="post-content"><div class="main-content content"><p>详细实验地址：<a target="_blank" rel="noopener" href="https://justinmeiners.github.io/lc3-vm/index.html#1:12">https://justinmeiners.github.io/lc3-vm/index.html#1:12</a></p>
<p>本质上是在用C语言描述16位机器的操作过程，因此可以以此为一个架接运行一个16位程序，因此成为虚拟机（Virtual Machine）；</p>
<p>前置要求：C语言（写出虚拟机的语言），位运算，汇编代码的运行模式（虚拟机的工作方式，不懂汇编代码的意思也没关系），丁点API知识（键盘传输和屏幕显示，以及内存收取等），LC-3指令集（模拟指令OP）；</p>
<p>指令集地址：<a target="_blank" rel="noopener" href="https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf">https://justinmeiners.github.io/lc3-vm/supplies/lc3-isa.pdf</a></p>
<p>思路：</p>
<h2 id="1-读取文件"><a href="#1-读取文件" class="headerlink" title="1.    读取文件"></a>1.    读取文件</h2><p>既然要读取其他程序和文件，那需要构造一个内存池容纳16位的程序，总大小也就是二的十六次方；</p>
<p><strong>代码1-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 65536 locations */</span></span><br><span class="line"><span class="keyword">uint16_t</span> memory[UINT16_MAX];	<span class="comment">//Memory Storage</span></span><br></pre></td></tr></table></figure>

<p>文件读入主要<strong>代码1-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* show usage string */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usage: %s [image-file1] ...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; argc; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!read_image(argv[j]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to load image: %s\n&quot;</span>, argv[j]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充说明：argc 和 argv 是 main 函数参数，第一个代表main参数个数，第二个代表为地址的参数；</p>
<p>作用：如果没有输入main函数的参数，第一个判断就会提示用法为： ./main [image-file1] ；如果输入[image-file1]这个参数，那么就会将其读入for循环中，用 read_image() 函数计算参数并判断，若返回值是0，就会说：装载映像失败；</p>
<p>这里显示出一个函数叫 read_image() ，下面说说它的作用：</p>
<p><strong>代码1-3</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_image_file</span><span class="params">(FILE* file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* the origin tells us where in memory to place the image */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> origin;</span><br><span class="line">    fread(&amp;origin, <span class="keyword">sizeof</span>(origin), <span class="number">1</span>, file);</span><br><span class="line">    origin = swap16(origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we know the maximum file size so we only need one fread */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> max_read = UINT16_MAX - origin;</span><br><span class="line">    <span class="keyword">uint16_t</span>* p = memory + origin;</span><br><span class="line">    <span class="keyword">size_t</span> read = fread(p, <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>), max_read, file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* swap to little endian */</span></span><br><span class="line">    <span class="keyword">while</span> (read-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p = swap16(*p);</span><br><span class="line">        ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_image</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* image_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE* file = fopen(image_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line">    read_image_file(file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中有两个函数，最后一个就是<strong>1-2</strong>中提到的，他的作用就是判断输入的参数地址是否为正确文件地址；如果不是就返回1，进而让<strong>1-2</strong>的判断输出错误并中断程序；如果是就执行 read_image_file() 函数；</p>
<p>read_image_file() 函数的作用便是将读取的程序内存装入之前设定好的memory数组中；首先计算的起始地址：origin，使用fread() C原装函数，读取起始地址；之后计算最大可容纳地址，并用p指针标记，最后使用循环不断缩小范围；</p>
<p>至于为什么要使用swap16()函数呢？因为LC-3程序是大端序排列，一般电脑用的都是小端序，所以要交换高低8位；</p>
<p><strong>代码1-4</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">swap16</span><span class="params">(<span class="keyword">uint16_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &lt;&lt; <span class="number">8</span>) | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-内存访问"><a href="#2-内存访问" class="headerlink" title="2.    内存访问"></a>2.    内存访问</h2><p>某些特殊寄存器无法从普通寄存器表中访问。相反，在内存中为它们保留一个特殊地址。要读取和写入这些寄存器，只需读取和写入它们的内存位置即可。这些称为<strong>内存映射寄存器</strong>。它们通常用于与特殊硬件设备进行交互（如键盘）；</p>
<p>LC-3 具有两个需要实现的内存映射寄存器。它们是键盘状态寄存器 （） 和键盘数据寄存器 （）。指示是否已按下某个键，并标识按下了哪个键；</p>
<p><strong>代码2-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>	//<span class="title">Memory</span> <span class="title">Mapped</span> <span class="title">Registers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MR_KBSR = <span class="number">0xFE00</span>, <span class="comment">/* keyboard status */</span></span><br><span class="line">    MR_KBDR = <span class="number">0xFE02</span>  <span class="comment">/* keyboard data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面是模拟LC-3 的两个内存寄存器；第一个为状态管理，第二个是数据管理；</p>
<p><strong>代码2-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">check_key</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WaitForSingleObject(hStdin, <span class="number">1000</span>) == WAIT_OBJECT_0 &amp;&amp; _kbhit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_write</span><span class="params">(<span class="keyword">uint16_t</span> address, <span class="keyword">uint16_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memory[address] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">mem_read</span><span class="params">(<span class="keyword">uint16_t</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (address == MR_KBSR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check_key())</span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">            memory[MR_KBDR] = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            memory[MR_KBSR] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memory[address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给出三个函数；第一个是设置windows终端输入的代码（调用API）；第二个是写入内存的代码；第三个是读入内存的代码；</p>
<h2 id="3-模拟寄存器"><a href="#3-模拟寄存器" class="headerlink" title="3.    模拟寄存器"></a>3.    模拟寄存器</h2><p>既然要模拟汇编代码的运行模式，那就少不掉寄存器；在汇编代码中，寄存器就相当于C的变量，保存数据用；</p>
<p>LC-3中，一共只有10个寄存器，8个通用，1个指向即将执行的代码的寄存器(PC)，1个条件控制寄存器；</p>
<p><strong>代码3-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>	//<span class="title">Registers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    R_R0 = <span class="number">0</span>,</span><br><span class="line">    R_R1,</span><br><span class="line">    R_R2,</span><br><span class="line">    R_R3,</span><br><span class="line">    R_R4,</span><br><span class="line">    R_R5,</span><br><span class="line">    R_R6,</span><br><span class="line">    R_R7,</span><br><span class="line">    R_PC, <span class="comment">/* program counter */</span></span><br><span class="line">    R_COND,</span><br><span class="line">    R_COUNT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里多设置了一个，R_COUNT不是寄存器，只是计数用的，因为是从0开始数的；</p>
<p>之后用这个来控制寄存器：</p>
<p><strong>代码3-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> reg[R_COUNT];	<span class="comment">//Register Storage</span></span><br></pre></td></tr></table></figure>

<p>而控制寄存器需要特别加一个枚举：</p>
<p><strong>代码3-3</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>	//<span class="title">condition</span> <span class="title">flags</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FL_POS = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">/* P */</span></span><br><span class="line">    FL_ZRO = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">/* Z */</span></span><br><span class="line">    FL_NEG = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">/* N */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果为正数则是P，为0则是Z，为负数则是N；它们的计算结果分别是：1，2，4；用到它们的时候，这些数字就代表它们的意义；而实际上是用移位来模拟这些条件位在寄存器中的形式；</p>
<h2 id="4-模拟指令"><a href="#4-模拟指令" class="headerlink" title="4.    模拟指令"></a>4.    模拟指令</h2><p>这里就是LC-3需要用到的指令，于是模拟出所有会用到的：</p>
<p><strong>代码4-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    OP_BR = <span class="number">0</span>, <span class="comment">/* branch */</span></span><br><span class="line">    OP_ADD,    <span class="comment">/* add  */</span></span><br><span class="line">    OP_LD,     <span class="comment">/* load */</span></span><br><span class="line">    OP_ST,     <span class="comment">/* store */</span></span><br><span class="line">    OP_JSR,    <span class="comment">/* jump register */</span></span><br><span class="line">    OP_AND,    <span class="comment">/* bitwise and */</span></span><br><span class="line">    OP_LDR,    <span class="comment">/* load register */</span></span><br><span class="line">    OP_STR,    <span class="comment">/* store register */</span></span><br><span class="line">    OP_RTI,    <span class="comment">/* unused */</span></span><br><span class="line">    OP_NOT,    <span class="comment">/* bitwise not */</span></span><br><span class="line">    OP_LDI,    <span class="comment">/* load indirect */</span></span><br><span class="line">    OP_STI,    <span class="comment">/* store indirect */</span></span><br><span class="line">    OP_JMP,    <span class="comment">/* jump */</span></span><br><span class="line">    OP_RES,    <span class="comment">/* reserved (unused) */</span></span><br><span class="line">    OP_LEA,    <span class="comment">/* load effective address */</span></span><br><span class="line">    OP_TRAP    <span class="comment">/* execute trap */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它们实现机器所需要的运算；</p>
<p>而LC-3的运算中，因为是16位，所以这些指令会放在最高的4位判断，剩下的位数就会放参数一类的东西，每个运算的参数需求位都不同，详细请看LC-3指令集；指令集中会要求使用的参数需要扩展为16位运算；所以需要接下来的函数：</p>
<p><strong>代码4-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">sign_extend</span><span class="params">(<span class="keyword">uint16_t</span> x, <span class="keyword">int</span> bit_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &gt;&gt; (bit_count - <span class="number">1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        x |= (<span class="number">0xFFFF</span> &lt;&lt; bit_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_flags</span><span class="params">(<span class="keyword">uint16_t</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (reg[r] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_ZRO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (reg[r] &gt;&gt; <span class="number">15</span>) <span class="comment">/* a 1 in the left-most bit indicates negative */</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_NEG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_COND] = FL_POS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个函数的作用便是 带符号扩展 位数；第二个函数的作用便是每次运算结束后，调整条件控制寄存器中的三个值；</p>
<h2 id="5-模拟执行过程"><a href="#5-模拟执行过程" class="headerlink" title="5.    模拟执行过程"></a>5.    模拟执行过程</h2><p>这是逆向题中的核心思想，便是C语言如何执行虚拟机模式的，如何找到flag的指令生成顺序；</p>
<p>以下是我们需要编写的过程：</p>
<ol>
<li>从寄存器地址处的内存中加载一条指令。<code>PC</code></li>
<li>递增寄存器。<code>PC</code></li>
<li>查看<em>操作码</em>以确定它应该执行哪种类型的指令。</li>
<li>使用指令中的参数执行指令。</li>
<li>返回步骤 1。</li>
</ol>
<p>这样一来，就能模拟出虚拟机的内核了；</p>
<p><strong>代码5</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;代码<span class="number">1</span><span class="number">-2</span>&#125;</span><br><span class="line">    &#123;代码<span class="number">7</span><span class="number">-3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* since exactly one condition flag should be set at any given time, set the Z flag */</span></span><br><span class="line">    reg[R_COND] = FL_ZRO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set the PC to starting position */</span></span><br><span class="line">    <span class="comment">/* 0x3000 is the default */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> PC_START = <span class="number">0x3000</span> &#125;;</span><br><span class="line">    reg[R_PC] = PC_START;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> running = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* FETCH */</span></span><br><span class="line">        <span class="keyword">uint16_t</span> instr = mem_read(reg[R_PC]++);</span><br><span class="line">        <span class="keyword">uint16_t</span> op = instr &gt;&gt; <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> OP_ADD:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-1</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_AND:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-2</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_NOT:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-3</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_BR:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-4</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JMP:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-5</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_JSR:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-6</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LD:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-7</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDI:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-8</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LDR:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-9</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_LEA:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-10</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_ST:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-11</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STI:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-12</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_STR:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-13</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_TRAP:</span><br><span class="line">                &#123;代码<span class="number">6</span><span class="number">-15</span>&#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OP_RES:</span><br><span class="line">            <span class="keyword">case</span> OP_RTI:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">abort</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;代码<span class="number">7</span><span class="number">-4</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化条件控制寄存器后，从0x3000的地址出发，并进入运行状态（ while(1) ），instr便是每次会执行的PC所指的指令内容；OP即为操作指令，因为总共16位的寄存器最高4位都是操作指令，所以只需要将instr右移12位就能得到OP；</p>
<p>之后根据switch选择OP，执行相应的指令；每执行完一条便循环回去，于是PC+1，开始执行下一条；</p>
<h2 id="6-C语言模拟指令清单"><a href="#6-C语言模拟指令清单" class="headerlink" title="6.    C语言模拟指令清单"></a>6.    C语言模拟指令清单</h2><p>核心内容，需要结合指令集理解怎么实现的；</p>
<p><strong>代码6-1</strong>：和的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* destination register (DR) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="comment">/* first operand (SR1) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="comment">/* whether we are in immediate mode */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (imm_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1F</span>, <span class="number">5</span>);</span><br><span class="line">        reg[r0] = reg[r1] + imm5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">        reg[r0] = reg[r1] + reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-2</strong>：按位和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> imm_flag = (instr &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (imm_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> imm5 = sign_extend(instr &amp; <span class="number">0x1F</span>, <span class="number">5</span>);</span><br><span class="line">        reg[r0] = reg[r1] &amp; imm5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> r2 = instr &amp; <span class="number">0x7</span>;</span><br><span class="line">        reg[r0] = reg[r1] &amp; reg[r2];</span><br><span class="line">    &#125;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-3</strong>：按位非</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line"></span><br><span class="line">    reg[r0] = ~reg[r1];</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-4</strong>：分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">uint16_t</span> cond_flag = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">if</span> (cond_flag &amp; reg[R_COND])</span><br><span class="line">    &#123;</span><br><span class="line">        reg[R_PC] += pc_offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-5</strong>：跳转</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Also handles RET */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    reg[R_PC] = reg[r1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-6</strong>：寄存器跳转</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> long_flag = (instr &gt;&gt; <span class="number">11</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    reg[R_R7] = reg[R_PC];</span><br><span class="line">    <span class="keyword">if</span> (long_flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> long_pc_offset = sign_extend(instr &amp; <span class="number">0x7FF</span>, <span class="number">11</span>);</span><br><span class="line">        reg[R_PC] += long_pc_offset;  <span class="comment">/* JSR */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">        reg[R_PC] = reg[r1]; <span class="comment">/* JSRR */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-7</strong>：加载</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    reg[r0] = mem_read(reg[R_PC] + pc_offset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-8</strong>：简介加载的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* destination register (DR) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="comment">/* PCoffset 9*/</span></span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="comment">/* add pc_offset to the current PC, look at that memory location to get the final address */</span></span><br><span class="line">    reg[r0] = mem_read(mem_read(reg[R_PC] + pc_offset));</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-9</strong>：加载寄存器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    reg[r0] = mem_read(reg[r1] + offset);</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-10</strong>：加载有效地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    reg[r0] = reg[R_PC] + pc_offset;</span><br><span class="line">    update_flags(r0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-11</strong>：存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(reg[R_PC] + pc_offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-12</strong>：间接存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> pc_offset = sign_extend(instr &amp; <span class="number">0x1FF</span>, <span class="number">9</span>);</span><br><span class="line">    mem_write(mem_read(reg[R_PC] + pc_offset), reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-13</strong>：寄存器存储</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r0 = (instr &gt;&gt; <span class="number">9</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> r1 = (instr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> offset = sign_extend(instr &amp; <span class="number">0x3F</span>, <span class="number">6</span>);</span><br><span class="line">    mem_write(reg[r1] + offset, reg[r0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>LC-3 提供了一些预定义的例程，用于执行常见任务和与 I/O 设备交互。例如，有一些例程用于从键盘获取输入以及用于向控制台显示字符串。这些称为<em>trap routines</em>，您可以将其视为LC-3的操作系统或API。每个<em>trap routines</em>都分配有一个<em>trap code</em>来标识它（类似于操作码）。要执行一个，请使用所需routine的code调用该指令；</p>
<p>枚举所有trap<strong>代码6-14</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TRAP_GETC = <span class="number">0x20</span>,  <span class="comment">/* get character from keyboard, not echoed onto the terminal */</span></span><br><span class="line">    TRAP_OUT = <span class="number">0x21</span>,   <span class="comment">/* output a character */</span></span><br><span class="line">    TRAP_PUTS = <span class="number">0x22</span>,  <span class="comment">/* output a word string */</span></span><br><span class="line">    TRAP_IN = <span class="number">0x23</span>,    <span class="comment">/* get character from keyboard, echoed onto the terminal */</span></span><br><span class="line">    TRAP_PUTSP = <span class="number">0x24</span>, <span class="comment">/* output a byte string */</span></span><br><span class="line">    TRAP_HALT = <span class="number">0x25</span>   <span class="comment">/* halt the program */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为每个trap选择<strong>代码6-15</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (instr &amp; <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> TRAP_GETC:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-16</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_OUT:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-17</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTS:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-18</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_IN:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-19</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_PUTSP:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-20</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TRAP_HALT:</span><br><span class="line">        &#123;代码<span class="number">6</span><span class="number">-21</span>&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>trap指令清单：</p>
<p><strong>代码6-16</strong>：输入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* read a single ASCII char */</span></span><br><span class="line">	reg[R_R0] = (<span class="keyword">uint16_t</span>)getchar();</span><br><span class="line">	update_flags(R_R0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-17</strong>：输出字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    putc((<span class="keyword">char</span>)reg[R_R0], <span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-18</strong>：输出字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* one char per word */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">    <span class="keyword">while</span> (*c)</span><br><span class="line">    &#123;</span><br><span class="line">        putc((<span class="keyword">char</span>)*c, <span class="built_in">stdout</span>);</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-19</strong>：准备输入字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    putc(c, <span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    reg[R_R0] = (<span class="keyword">uint16_t</span>)c;</span><br><span class="line">    update_flags(R_R0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-20</strong>：输出字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* one char per byte (two bytes per word)</span></span><br><span class="line"><span class="comment">       here we need to swap back to</span></span><br><span class="line"><span class="comment">       big endian format */</span></span><br><span class="line">    <span class="keyword">uint16_t</span>* c = memory + reg[R_R0];</span><br><span class="line">    <span class="keyword">while</span> (*c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> char1 = (*c) &amp; <span class="number">0xFF</span>;</span><br><span class="line">        putc(char1, <span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">char</span> char2 = (*c) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (char2) putc(char2, <span class="built_in">stdout</span>);</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码6-21</strong>：终止程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;HALT&quot;</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	running = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-头部添加以及windows加入API"><a href="#7-头部添加以及windows加入API" class="headerlink" title="7.    头部添加以及windows加入API"></a>7.    头部添加以及windows加入API</h2><p>加入的头部：</p>
<p><strong>代码7-1</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span> <span class="comment">// uint16_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  <span class="comment">// FILE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span> <span class="comment">// SIGINT</span></span></span><br><span class="line"><span class="comment">/* windows only */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span>  <span class="comment">// _kbhit</span></span></span><br><span class="line"></span><br><span class="line">HANDLE hStdin = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UINT16_MAX 65536</span></span><br></pre></td></tr></table></figure>

<p>加入API：</p>
<p><strong>代码7-2</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DWORD fdwMode, fdwOldMode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_input_buffering</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hStdin = GetStdHandle(STD_INPUT_HANDLE);</span><br><span class="line">    GetConsoleMode(hStdin, &amp;fdwOldMode); <span class="comment">/* save old mode */</span></span><br><span class="line">    fdwMode = fdwOldMode</span><br><span class="line">            ^ ENABLE_ECHO_INPUT  <span class="comment">/* no input echo */</span></span><br><span class="line">            ^ ENABLE_LINE_INPUT; <span class="comment">/* return when one or</span></span><br><span class="line"><span class="comment">                                    more characters are available */</span></span><br><span class="line">    SetConsoleMode(hStdin, fdwMode); <span class="comment">/* set new mode */</span></span><br><span class="line">    FlushConsoleInputBuffer(hStdin); <span class="comment">/* clear buffer */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restore_input_buffering</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SetConsoleMode(hStdin, fdwOldMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_interrupt</span><span class="params">(<span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    restore_input_buffering();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码7-3</strong>：初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, handle_interrupt);</span><br><span class="line">disable_input_buffering();</span><br></pre></td></tr></table></figure>

<p><strong>代码7-4</strong>：释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restore_input_buffering();</span><br></pre></td></tr></table></figure>

<p>之后按顺序组装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span><span class="number">-1</span></span><br><span class="line"><span class="number">3</span><span class="number">-1</span></span><br><span class="line"><span class="number">4</span><span class="number">-1</span></span><br><span class="line"><span class="number">3</span><span class="number">-3</span></span><br><span class="line"><span class="number">2</span><span class="number">-1</span></span><br><span class="line"><span class="number">6</span><span class="number">-14</span></span><br><span class="line"><span class="number">1</span><span class="number">-1</span></span><br><span class="line"><span class="number">3</span><span class="number">-2</span></span><br><span class="line"><span class="number">4</span><span class="number">-2</span></span><br><span class="line"><span class="number">1</span><span class="number">-4</span></span><br><span class="line"><span class="number">1</span><span class="number">-3</span></span><br><span class="line"><span class="number">2</span><span class="number">-2</span></span><br><span class="line"><span class="number">7</span><span class="number">-2</span></span><br><span class="line">    </span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>之后就可以得到一台16位的虚拟机；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>过了一遍VM实验过后对虚拟机有了一定理解，并且对之前所见的VM逆向题有了解题的思路，以及了解了LC-3指令集，和些许API函数的作用，由此更加理解一个源代码如何与其他文件产生共鸣；可以类比shell与程序之间的关系，更好地理解shell的作用和本质；</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/6a5abff6032048e5.png" alt="genshin"></p>
</div></div><a class="button-hover more" href="/SecondBC/2022/02/24/VM%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/SecondBC/page/2/">&lt;i class&#x3D;&quot;fas fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/SecondBC/">1</a><a class="page-number" href="/SecondBC/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/SecondBC/page/4/">4</a><a class="extend next" rel="next" href="/SecondBC/page/4/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2022 ～ 2024 By Second_BC</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/copy.js"></script><!--script(src=url)--></body></html>