<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Shell_Lab"><meta name="keywords" content="CSAPP"><meta name="author" content="Second_BC,undefined"><meta name="copyright" content="Second_BC"><title>Shell_Lab【Second_BC の BloG】</title><link rel="stylesheet" href="/SecondBC/css/fan.css"><link rel="stylesheet" href="/SecondBC/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/SecondBC/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/SecondBC/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/SecondBC/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: ,
  valine: ,
}</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/SecondBC/atom.xml" title="Second_BC の BloG" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E6%9D%A5%E5%85%88%E8%AF%B4%E8%AF%B4%E8%BF%997%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%A7%E8%87%B4%E5%8A%9F%E8%83%BD%E4%BB%A5%E5%8F%8A%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">现在来先说说这7个函数的大致功能以及目的：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%9A%84%E5%B7%B2%E6%9C%89%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">辅助的已有函数：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%8B%E5%90%8E%E6%9C%89%E7%BB%8F%E5%85%B8%E7%9A%84%E5%AE%9E%E9%AA%8C%E7%BA%A6%E6%9D%9F%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">之后有经典的实验约束规则：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E7%9C%8BShell%E7%9A%84%E4%B8%BB%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">先来看Shell的主函数：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-Eval"><span class="toc-number">5.</span> <span class="toc-text">I . Eval</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#II-builtin-cmd"><span class="toc-number">6.</span> <span class="toc-text">II . builtin_cmd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#III-do-bgfg"><span class="toc-number">7.</span> <span class="toc-text">III . do_bgfg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IV-waitfg"><span class="toc-number">8.</span> <span class="toc-text">IV . waitfg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V-sigint-handler"><span class="toc-number">9.</span> <span class="toc-text">V . sigint_handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VI-sigstp-handler"><span class="toc-number">10.</span> <span class="toc-text">VI . sigstp_handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VII-sigchld-handler"><span class="toc-number">11.</span> <span class="toc-text">VII . sigchld_handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">12.</span> <span class="toc-text">总结：</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/SecondBC/ss.jpg"></div><div class="author-info-name">Second_BC</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/" target="_blank">GitHub<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="mailto:1" target="_blank">E-Mail<i class="icon-dot bg-color4"></i></a><a class="links-button button-hover" href="tencent://message/?uin=2&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color2"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/SecondBC/archives"><span class="pull-top">日志</span><span class="pull-bottom">18</span></a><a class="author-info-articles-tags article-meta" href="/SecondBC/tags"><span class="pull-top">标签</span><span class="pull-bottom">7</span></a><a class="author-info-articles-categories article-meta" href="/SecondBC/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/SecondBC">首页</a><a class="menu-item" href="/SecondBC/archives">归档</a><a class="menu-item" href="/SecondBC/categories">分类</a><a class="menu-item" href="/SecondBC/tags">标签</a><a class="menu-item" href="/SecondBC/about">关于</a></nav><div class="right-info"><a class="title-name" href="/SecondBC/">Second_BC の BloG</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">Shell_Lab</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2022-04-23 | 更新于 2022-10-16</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/categories/Lab/">Lab</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/SecondBC/tags/CSAPP/">CSAPP</a></div></div></div><div class="main-content"><p>壳实验，对应于csapp第8章，异常控制流；根据其提示可知，该实验要求编写一个完整的简单的壳；</p>
<p>在完成之后，有许多的检测关卡等待壳的成果；</p>
<p>实际上，此实验已经将大部分内容编写完毕，只要求完成7个函数的构造来完整壳即可；</p>
<p>这7个函数都是有关于信号，以及异常处理的；</p>
<h2 id="现在来先说说这7个函数的大致功能以及目的："><a href="#现在来先说说这7个函数的大致功能以及目的：" class="headerlink" title="现在来先说说这7个函数的大致功能以及目的："></a>现在来先说说这7个函数的大致功能以及目的：</h2><ol>
<li><p>eval：解析和解释命令行的主例程；</p>
</li>
<li><p>builtin_cmd：识别并解释内置命令；</p>
<ul>
<li><p>内置命令：</p>
</li>
<li><p>quit：退出shell；</p>
</li>
<li><p>fg：发送 SIGCONT（继续）来重启 job，位于前台运行；（前台只允许1个job运行）</p>
</li>
<li><p>bg：发送 SIGCONT（继续）来重启 job，位于后台运行；</p>
</li>
<li><p>jobs：列出所有后台作业；</p>
</li>
</ul>
</li>
<li><p>do_bgfg：执行bg和fg指令；</p>
</li>
<li><p>waitfg：等待前台作业完成；</p>
</li>
<li><p>sigchld_handler：SIGCHLD（子程序退出）信号处理；</p>
</li>
<li><p>sigint_handler：SIGINT（中断）信号处理；</p>
</li>
<li><p>sigtstp_handler：SIGTSTP（暂停）信号处理；</p>
</li>
</ol>
<h2 id="辅助的已有函数："><a href="#辅助的已有函数：" class="headerlink" title="辅助的已有函数："></a>辅助的已有函数：</h2><ul>
<li>parseline：解析命令行构建argv列表；</li>
<li>clearjob：清除job结构体中的内容；</li>
<li>initjobs：初始化job列表；</li>
<li>maxjid：返回允许的最大job ID；</li>
<li>addjob：添加一个作业到job列表；</li>
<li>deletejob：从job列表中删除pid的作业；</li>
<li>fgpid：返回前台job的pid；</li>
<li>getjobpid：根据pid从job列表中找到作业；</li>
<li>getjobjid：根据job ID从job列表中找到作业；</li>
<li>pid2jid：根据pid返回对应jid；</li>
<li>listjobs：显示job列表；</li>
</ul>
<h2 id="之后有经典的实验约束规则："><a href="#之后有经典的实验约束规则：" class="headerlink" title="之后有经典的实验约束规则："></a>之后有经典的实验约束规则：</h2><ul>
<li>提示符为：tsh&gt;</li>
<li>用户键入的命令行应包含一个名称和零个或多个参数，所有参数均由一个或多个空格分隔。 如果名称是内置命令，则shell应该立即处理它并等待下一个命令行；否则，shell应该假定名称是可执行文件的路径，它在初始子进程的上下文中加载并运行；</li>
<li>shell不用支持管道或I/O重定向；</li>
<li>输入 ctrl-c 导致 SIGINT （输入 ctrl-z 导致 SIGTSTP）发送到当前前台作业以及该作业的任何后代，如果没有前台作业，那么信号没有效果；</li>
<li>如果命令行以 &amp; 结束，则shell应该在后台运行作业，否则它将在前台运行该作业；</li>
<li>每个作业都可以通过进程ID（PID）或作业ID（JID）进行标识，该ID是tsh分配的正整数；</li>
<li>shell支持内置命令；</li>
<li>shell应该回收所有僵死子进程，如果任何作业由于接收到未捕获到的信号而终止，则shell应该识别此事件并打印一条消息，其中包含该作业的PID和有问题的信号的描述；</li>
</ul>
<h2 id="先来看Shell的主函数："><a href="#先来看Shell的主函数：" class="headerlink" title="先来看Shell的主函数："></a>先来看Shell的主函数：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read command line */</span></span><br><span class="line">	<span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">	    app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evaluate the command line */</span></span><br><span class="line">	eval(cmdline);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个while是在选择模式；输入h参数显示提示，输入v参数发出附加诊断信息，输入p不显示命令行；</p>
<p>之后需要捕获信号，就需要通过Signal函数将信号和对应处理函数绑定，然后进入第二个while使用eval一条一条地重复解析输入的内容；</p>
<h2 id="I-Eval"><a href="#I-Eval" class="headerlink" title="I . Eval"></a>I . Eval</h2><p>第一解析命令行，可以套用parseline函数来帮忙，并根据结尾符号是否为 &amp; 来判断前后台关系；</p>
<p>第二要做到的，查看解析出的 argv[0] 是否为内置命令，是，则转交给builtin_cmd函数，不是则创建子进程来运行；之后在shell中通过 addjob 来添加作业，如果是前台作业，就等待前台作业运行完毕，如果是后台作业，就执行解析下一条命令；</p>
<p>由此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> *buf = <span class="built_in">array</span>;		<span class="comment">//cmdline容器 </span></span><br><span class="line">	<span class="keyword">char</span> *argv[MAXARGS];	<span class="comment">//命令行参数 </span></span><br><span class="line">	<span class="keyword">int</span> bg;		<span class="comment">//前后台？ </span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;		<span class="comment">//进程id </span></span><br><span class="line">	<span class="keyword">sigset_t</span> mask, prev, all;	<span class="comment">//阻塞块 </span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">strcpy</span>(buf,cmdline);</span><br><span class="line">	bg = parseline(buf,argv);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(!builtin_cmd(argv))	<span class="comment">//是否内置命令 </span></span><br><span class="line">	&#123;</span><br><span class="line">		sigemptyset(&amp;mask);		<span class="comment">//清空mask块 </span></span><br><span class="line">		sigaddset(&amp;mask,SIGCHLD);	<span class="comment">//添加SIGCHLD到mask </span></span><br><span class="line">		sigfillset(&amp;all);	<span class="comment">//所有信号进入all块 </span></span><br><span class="line">		sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev)	<span class="comment">//阻塞SIGCHLD信号，防止addjob和deletejob竞争</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)	<span class="comment">//子进程 </span></span><br><span class="line">		&#123;</span><br><span class="line">			fflush(sdout);	<span class="comment">//printf(&quot;in process:%d\n&quot;,pid);</span></span><br><span class="line">			setpgid(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//更换子进程进程组，以免和shell冲突</span></span><br><span class="line">			sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">if</span>(execve(argv[<span class="number">0</span>],agrv,environ) &lt; <span class="number">0</span>)	<span class="comment">//通过execve加载到子进程</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//printf(&quot;parent:%d\n&quot;,getpid());</span></span><br><span class="line">		sigprocmask(SIG_BLOCK,&amp;all,<span class="literal">NULL</span>) <span class="comment">//访问job列表需阻塞所有信号 </span></span><br><span class="line">		addjob(jobs,pid,bg?BG:FG,buf);</span><br><span class="line">		sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>)	<span class="comment">//解除阻塞</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(bg)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, buf);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			waitfg(pid);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的有两点：</p>
<ul>
<li>阻塞SIGCHLD信号以防止addjob与deletejob竞争；</li>
<li>访问全局数据jobs列表前阻塞所有信号；</li>
</ul>
<p>为什么要在fork创建进程之前阻塞SIGCHLD呢？因为fork的进程可能在任意时刻暂停或终止；使得Shell跳转通过对应信号去处理程序，并在信号处理中对该作业进行修改；如果在 addjob 之前跳转，则会由于未保存该作业而导致错误，所以需要在fork之前阻塞，并在子进程中取消阻塞；</p>
<p>设置独立的进程组与Shell分开，以免Shell接收到的其他例如 ctrl-c 之类的信号而导致进程受到影响；</p>
<p>其次，从安全信号处理的角度，在修改读取jobs时如果不阻塞所有信号，则会有可能中断而导致jobs的各部分状态不同；</p>
<h2 id="II-builtin-cmd"><a href="#II-builtin-cmd" class="headerlink" title="II . builtin_cmd"></a>II . builtin_cmd</h2><p>第一，前面可以知道用这个函数套用在eval里，使得分辨是否为内置命令，所以让内置命令返回1，而非内置命令返回0；</p>
<p>第二，已知这个函数会用于bg和fg的内置命令，所以可以套用do_bgfg的函数；</p>
<p>那么代码就可知了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		listjobs(jobs);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>((!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>)) || (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		do_bgfg(argv);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="III-do-bgfg"><a href="#III-do-bgfg" class="headerlink" title="III . do_bgfg"></a>III . do_bgfg</h2><p>根据之前提到的，需要用用到SIGCONT信号，那么也需要使用kill来发送给整个进程组；</p>
<p>在这之前需要修改job结构的状态；</p>
<p>而在修改前台或者后台的再之前，需要寻找到这个工作的ID或者pid；</p>
<p>由此代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> jid;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span>	<span class="comment">//单独的job指针 </span></span><br><span class="line">	<span class="keyword">sigset_t</span> mask,prev;	<span class="comment">//修改job之前阻塞所有信号</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%%%d&quot;</span>,&amp;jid) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		job = getjobjid(jobs,jid);</span><br><span class="line">		<span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%d&quot;</span>,&amp;pid) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		job = getjobpid(jobs, pid);</span><br><span class="line">		<span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%s): No such process\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面的都是在排除异常情况</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//修改job状态</span></span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))</span><br><span class="line">		job-&gt;state = FG;</span><br><span class="line">	<span class="keyword">else</span>	</span><br><span class="line">		job-&gt;state = BG;</span><br><span class="line">	</span><br><span class="line">	sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	pid = job-&gt;pid;</span><br><span class="line">	kill(-pid,SIGCONT); <span class="comment">//负的则发送给进程组</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))</span><br><span class="line">		waitfg(pid);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, pid, job-&gt;cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IV-waitfg"><a href="#IV-waitfg" class="headerlink" title="IV . waitfg"></a>IV . waitfg</h2><p>等待前台作业完成就使用sleep挂起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(pid == fgpid(jobs))</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="V-sigint-handler"><a href="#V-sigint-handler" class="headerlink" title="V . sigint_handler"></a>V . sigint_handler</h2><p>当使用 Ctrl+c ，内核发送中断信号给这个Shell程序，而Shell程序通过kill发送信号给子进程，而停止信号也同理；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">    </span><br><span class="line">	errno = old_errno; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存之前的errno并在返回时重新赋值，是为了防止它被改变；</p>
<h2 id="VI-sigstp-handler"><a href="#VI-sigstp-handler" class="headerlink" title="VI . sigstp_handler"></a>VI . sigstp_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">        </span><br><span class="line">	errno = old_errno; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="VII-sigchld-handler"><a href="#VII-sigchld-handler" class="headerlink" title="VII . sigchld_handler"></a>VII . sigchld_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line">	<span class="keyword">int</span> state;	<span class="comment">//保存waitpid的状态，用来判断子进程是终止还是停止</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">	</span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	<span class="comment">//由于信号不存在队列，而waitpid一次只会回收一个子进程，所以用while</span></span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)	<span class="comment">//要检查停止和终止的，并且不要卡在这个循环中</span></span><br><span class="line">    &#123;	</span><br><span class="line">		<span class="comment">//对全局结构变量jobs进行修改时，要阻塞所有信号</span></span><br><span class="line">		sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(state))	<span class="comment">//子进程通过调用exit或return正常终止，需要从jobs中删除该作业</span></span><br><span class="line">         &#123;	</span><br><span class="line">			deletejob(jobs, pid);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(state))	<span class="comment">//子进程因为一个未捕获的信号终止</span></span><br><span class="line">         &#123;	</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(state));		</span><br><span class="line">			deletejob(jobs, pid);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(state))	<span class="comment">//如果子进程是停止的，需要修改改作业的状态</span></span><br><span class="line">         &#123;	</span><br><span class="line">			job = getjobpid(jobs, pid);</span><br><span class="line">			job-&gt;state = ST;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, pid, WSTOPSIG(state));</span><br><span class="line">		&#125;</span><br><span class="line">		sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);	<span class="comment">//恢复信号接收</span></span><br><span class="line">	&#125;</span><br><span class="line">	errno = old_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这个实验主要是考察了安全信号处理内容，以及竞争关系；</p>
<p>帮助疏通了对Shell的理解：接受指令，处理指令，以及增加进程和如何回收进程；</p>
<p>对于小方向的话便是细节的考虑，阻塞顺序以及分类情况；</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Second_BC</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://secondbc.github.io/SecondBC/2022/04/23/Shell-Lab/">https://secondbc.github.io/SecondBC/2022/04/23/Shell-Lab/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://secondbc.github.io/SecondBC">Second_BC の BloG</a>！</span></div></div></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2022/08/18/%E5%81%87%E6%9C%9F%E5%A4%8D%E7%8E%B0/"><i class="fas fa-angle-left">&nbsp;</i><span>假期复现</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/SecondBC/2022/03/31/Angr-Lab/"><span>Angr.Lab</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2022 By Second_BC</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/SecondBC/js/copy.js"></script><!--script(src=url)--></body></html>