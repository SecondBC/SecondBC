<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Shell_Lab | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="壳实验，对应于csapp第8章，异常控制流；根据其提示可知，该实验要求编写一个完整的简单的壳； 在完成之后，有许多的检测关卡等待壳的成果； 实际上，此实验已经将大部分内容编写完毕，只要求完成7个函数的构造来完整壳即可； 这7个函数都是有关于信号，以及异常处理的； 现在来先说说这7个函数的大致功能以及目的： eval：解析和解释命令行的主例程；  builtin_cmd：识别并解释内置命令；  内置">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell_Lab">
<meta property="og:url" content="https://secondbc.github.io/SecondBC/2022/04/23/Shell-Lab/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="壳实验，对应于csapp第8章，异常控制流；根据其提示可知，该实验要求编写一个完整的简单的壳； 在完成之后，有许多的检测关卡等待壳的成果； 实际上，此实验已经将大部分内容编写完毕，只要求完成7个函数的构造来完整壳即可； 这7个函数都是有关于信号，以及异常处理的； 现在来先说说这7个函数的大致功能以及目的： eval：解析和解释命令行的主例程；  builtin_cmd：识别并解释内置命令；  内置">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-23T08:23:15.000Z">
<meta property="article:modified_time" content="2022-04-23T08:23:50.620Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/SecondBC/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/SecondBC/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/SecondBC/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/SecondBC/">Home</a>
        
          <a class="main-nav-link" href="/SecondBC/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/SecondBC/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://secondbc.github.io/SecondBC"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Shell-Lab" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/SecondBC/2022/04/23/Shell-Lab/" class="article-date">
  <time datetime="2022-04-23T08:23:15.000Z" itemprop="datePublished">2022-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Shell_Lab
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>壳实验，对应于csapp第8章，异常控制流；根据其提示可知，该实验要求编写一个完整的简单的壳；</p>
<p>在完成之后，有许多的检测关卡等待壳的成果；</p>
<p>实际上，此实验已经将大部分内容编写完毕，只要求完成7个函数的构造来完整壳即可；</p>
<p>这7个函数都是有关于信号，以及异常处理的；</p>
<h2 id="现在来先说说这7个函数的大致功能以及目的："><a href="#现在来先说说这7个函数的大致功能以及目的：" class="headerlink" title="现在来先说说这7个函数的大致功能以及目的："></a>现在来先说说这7个函数的大致功能以及目的：</h2><ol>
<li><p>eval：解析和解释命令行的主例程；</p>
</li>
<li><p>builtin_cmd：识别并解释内置命令；</p>
<ul>
<li><p>内置命令：</p>
</li>
<li><p>quit：退出shell；</p>
</li>
<li><p>fg：发送 SIGCONT（继续）来重启 job，位于前台运行；（前台只允许1个job运行）</p>
</li>
<li><p>bg：发送 SIGCONT（继续）来重启 job，位于后台运行；</p>
</li>
<li><p>jobs：列出所有后台作业；</p>
</li>
</ul>
</li>
<li><p>do_bgfg：执行bg和fg指令；</p>
</li>
<li><p>waitfg：等待前台作业完成；</p>
</li>
<li><p>sigchld_handler：SIGCHLD（子程序退出）信号处理；</p>
</li>
<li><p>sigint_handler：SIGINT（中断）信号处理；</p>
</li>
<li><p>sigtstp_handler：SIGTSTP（暂停）信号处理；</p>
</li>
</ol>
<h2 id="辅助的已有函数："><a href="#辅助的已有函数：" class="headerlink" title="辅助的已有函数："></a>辅助的已有函数：</h2><ul>
<li>parseline：解析命令行构建argv列表；</li>
<li>clearjob：清除job结构体中的内容；</li>
<li>initjobs：初始化job列表；</li>
<li>maxjid：返回允许的最大job ID；</li>
<li>addjob：添加一个作业到job列表；</li>
<li>deletejob：从job列表中删除pid的作业；</li>
<li>fgpid：返回前台job的pid；</li>
<li>getjobpid：根据pid从job列表中找到作业；</li>
<li>getjobjid：根据job ID从job列表中找到作业；</li>
<li>pid2jid：根据pid返回对应jid；</li>
<li>listjobs：显示job列表；</li>
</ul>
<h2 id="之后有经典的实验约束规则："><a href="#之后有经典的实验约束规则：" class="headerlink" title="之后有经典的实验约束规则："></a>之后有经典的实验约束规则：</h2><ul>
<li>提示符为：tsh&gt;</li>
<li>用户键入的命令行应包含一个名称和零个或多个参数，所有参数均由一个或多个空格分隔。 如果名称是内置命令，则shell应该立即处理它并等待下一个命令行；否则，shell应该假定名称是可执行文件的路径，它在初始子进程的上下文中加载并运行；</li>
<li>shell不用支持管道或I/O重定向；</li>
<li>输入 ctrl-c 导致 SIGINT （输入 ctrl-z 导致 SIGTSTP）发送到当前前台作业以及该作业的任何后代，如果没有前台作业，那么信号没有效果；</li>
<li>如果命令行以 &amp; 结束，则shell应该在后台运行作业，否则它将在前台运行该作业；</li>
<li>每个作业都可以通过进程ID（PID）或作业ID（JID）进行标识，该ID是tsh分配的正整数；</li>
<li>shell支持内置命令；</li>
<li>shell应该回收所有僵死子进程，如果任何作业由于接收到未捕获到的信号而终止，则shell应该识别此事件并打印一条消息，其中包含该作业的PID和有问题的信号的描述；</li>
</ul>
<h2 id="先来看Shell的主函数："><a href="#先来看Shell的主函数：" class="headerlink" title="先来看Shell的主函数："></a>先来看Shell的主函数：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">     * on the pipe connected to stdout) */</span></span><br><span class="line">    dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the command line */</span></span><br><span class="line">    <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:             <span class="comment">/* print help message */</span></span><br><span class="line">            usage();</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:             <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">            verbose = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:             <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">            emit_prompt = <span class="number">0</span>;  <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">    Signal(SIGINT,  sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">    Signal(SIGTSTP, sigtstp_handler);  <span class="comment">/* ctrl-z */</span></span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);  <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">    Signal(SIGQUIT, sigquit_handler); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the job list */</span></span><br><span class="line">    initjobs(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Read command line */</span></span><br><span class="line">	<span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">	    app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">	    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Evaluate the command line */</span></span><br><span class="line">	eval(cmdline);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个while是在选择模式；输入h参数显示提示，输入v参数发出附加诊断信息，输入p不显示命令行；</p>
<p>之后需要捕获信号，就需要通过Signal函数将信号和对应处理函数绑定，然后进入第二个while使用eval一条一条地重复解析输入的内容；</p>
<h2 id="I-Eval"><a href="#I-Eval" class="headerlink" title="I . Eval"></a>I . Eval</h2><p>第一解析命令行，可以套用parseline函数来帮忙，并根据结尾符号是否为 &amp; 来判断前后台关系；</p>
<p>第二要做到的，查看解析出的 argv[0] 是否为内置命令，是，则转交给builtin_cmd函数，不是则创建子进程来运行；之后在shell中通过 addjob 来添加作业，如果是前台作业，就等待前台作业运行完毕，如果是后台作业，就执行解析下一条命令；</p>
<p>由此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> <span class="built_in">array</span>[MAXLINE];</span><br><span class="line">	<span class="keyword">char</span> *buf = <span class="built_in">array</span>;		<span class="comment">//cmdline容器 </span></span><br><span class="line">	<span class="keyword">char</span> *argv[MAXARGS];	<span class="comment">//命令行参数 </span></span><br><span class="line">	<span class="keyword">int</span> bg;		<span class="comment">//前后台？ </span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;		<span class="comment">//进程id </span></span><br><span class="line">	<span class="keyword">sigset_t</span> mask, prev, all;	<span class="comment">//阻塞块 </span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">strcpy</span>(buf,cmdline);</span><br><span class="line">	bg = parseline(buf,argv);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(!builtin_cmd(argv))	<span class="comment">//是否内置命令 </span></span><br><span class="line">	&#123;</span><br><span class="line">		sigemptyset(&amp;mask);		<span class="comment">//清空mask块 </span></span><br><span class="line">		sigaddset(&amp;mask,SIGCHLD);	<span class="comment">//添加SIGCHLD到mask </span></span><br><span class="line">		sigfillset(&amp;all);	<span class="comment">//所有信号进入all块 </span></span><br><span class="line">		sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev)	<span class="comment">//阻塞SIGCHLD信号，防止addjob和deletejob竞争</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)	<span class="comment">//子进程 </span></span><br><span class="line">		&#123;</span><br><span class="line">			fflush(sdout);	<span class="comment">//printf(&quot;in process:%d\n&quot;,pid);</span></span><br><span class="line">			setpgid(<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//更换子进程进程组，以免和shell冲突</span></span><br><span class="line">			sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">if</span>(execve(argv[<span class="number">0</span>],agrv,environ) &lt; <span class="number">0</span>)	<span class="comment">//通过execve加载到子进程</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//printf(&quot;parent:%d\n&quot;,getpid());</span></span><br><span class="line">		sigprocmask(SIG_BLOCK,&amp;all,<span class="literal">NULL</span>) <span class="comment">//访问job列表需阻塞所有信号 </span></span><br><span class="line">		addjob(jobs,pid,bg?BG:FG,buf);</span><br><span class="line">		sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>)	<span class="comment">//解除阻塞</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(bg)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, buf);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			waitfg(pid);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的有两点：</p>
<ul>
<li>阻塞SIGCHLD信号以防止addjob与deletejob竞争；</li>
<li>访问全局数据jobs列表前阻塞所有信号；</li>
</ul>
<p>为什么要在fork创建进程之前阻塞SIGCHLD呢？因为fork的进程可能在任意时刻暂停或终止；使得Shell跳转通过对应信号去处理程序，并在信号处理中对该作业进行修改；如果在 addjob 之前跳转，则会由于未保存该作业而导致错误，所以需要在fork之前阻塞，并在子进程中取消阻塞；</p>
<p>设置独立的进程组与Shell分开，以免Shell接收到的其他例如 ctrl-c 之类的信号而导致进程受到影响；</p>
<p>其次，从安全信号处理的角度，在修改读取jobs时如果不阻塞所有信号，则会有可能中断而导致jobs的各部分状态不同；</p>
<h2 id="II-builtin-cmd"><a href="#II-builtin-cmd" class="headerlink" title="II . builtin_cmd"></a>II . builtin_cmd</h2><p>第一，前面可以知道用这个函数套用在eval里，使得分辨是否为内置命令，所以让内置命令返回1，而非内置命令返回0；</p>
<p>第二，已知这个函数会用于bg和fg的内置命令，所以可以套用do_bgfg的函数；</p>
<p>那么代码就可知了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;quit&quot;</span>))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;jobs&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		listjobs(jobs);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>((!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;bg&quot;</span>)) || (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;fg&quot;</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		do_bgfg(argv);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="III-do-bgfg"><a href="#III-do-bgfg" class="headerlink" title="III . do_bgfg"></a>III . do_bgfg</h2><p>根据之前提到的，需要用用到SIGCONT信号，那么也需要使用kill来发送给整个进程组；</p>
<p>在这之前需要修改job结构的状态；</p>
<p>而在修改前台或者后台的再之前，需要寻找到这个工作的ID或者pid；</p>
<p>由此代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> jid;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span>	<span class="comment">//单独的job指针 </span></span><br><span class="line">	<span class="keyword">sigset_t</span> mask,prev;	<span class="comment">//修改job之前阻塞所有信号</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%%%d&quot;</span>,&amp;jid) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		job = getjobjid(jobs,jid);</span><br><span class="line">		<span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>],<span class="string">&quot;%d&quot;</span>,&amp;pid) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		job = getjobpid(jobs, pid);</span><br><span class="line">		<span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(%s): No such process\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//上面的都是在排除异常情况</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//修改job状态</span></span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))</span><br><span class="line">		job-&gt;state = FG;</span><br><span class="line">	<span class="keyword">else</span>	</span><br><span class="line">		job-&gt;state = BG;</span><br><span class="line">	</span><br><span class="line">	sigprocmask(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	pid = job-&gt;pid;</span><br><span class="line">	kill(-pid,SIGCONT); <span class="comment">//负的则发送给进程组</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))</span><br><span class="line">		waitfg(pid);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, pid, job-&gt;cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IV-waitfg"><a href="#IV-waitfg" class="headerlink" title="IV . waitfg"></a>IV . waitfg</h2><p>等待前台作业完成就使用sleep挂起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(pid == fgpid(jobs))</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="V-sigint-handler"><a href="#V-sigint-handler" class="headerlink" title="V . sigint_handler"></a>V . sigint_handler</h2><p>当使用 Ctrl+c ，内核发送中断信号给这个Shell程序，而Shell程序通过kill发送信号给子进程，而停止信号也同理；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">    </span><br><span class="line">	errno = old_errno; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存之前的errno并在返回时重新赋值，是为了防止它被改变；</p>
<h2 id="VI-sigstp-handler"><a href="#VI-sigstp-handler" class="headerlink" title="VI . sigstp_handler"></a>VI . sigstp_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)</span><br><span class="line">        kill(-pid,sig);</span><br><span class="line">        </span><br><span class="line">	errno = old_errno; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="VII-sigchld-handler"><a href="#VII-sigchld-handler" class="headerlink" title="VII . sigchld_handler"></a>VII . sigchld_handler</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_errno = errno;	<span class="comment">//首先需要保存原始的errno</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">sigset_t</span> mask, prev;</span><br><span class="line">	<span class="keyword">int</span> state;	<span class="comment">//保存waitpid的状态，用来判断子进程是终止还是停止</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">	</span><br><span class="line">	sigfillset(&amp;mask);</span><br><span class="line">	<span class="comment">//由于信号不存在队列，而waitpid一次只会回收一个子进程，所以用while</span></span><br><span class="line">	<span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)	<span class="comment">//要检查停止和终止的，并且不要卡在这个循环中</span></span><br><span class="line">    &#123;	</span><br><span class="line">		<span class="comment">//对全局结构变量jobs进行修改时，要阻塞所有信号</span></span><br><span class="line">		sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">		<span class="keyword">if</span>(WIFEXITED(state))	<span class="comment">//子进程通过调用exit或return正常终止，需要从jobs中删除该作业</span></span><br><span class="line">         &#123;	</span><br><span class="line">			deletejob(jobs, pid);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(state))	<span class="comment">//子进程因为一个未捕获的信号终止</span></span><br><span class="line">         &#123;	</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(state));		</span><br><span class="line">			deletejob(jobs, pid);</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(state))	<span class="comment">//如果子进程是停止的，需要修改改作业的状态</span></span><br><span class="line">         &#123;	</span><br><span class="line">			job = getjobpid(jobs, pid);</span><br><span class="line">			job-&gt;state = ST;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, pid, WSTOPSIG(state));</span><br><span class="line">		&#125;</span><br><span class="line">		sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);	<span class="comment">//恢复信号接收</span></span><br><span class="line">	&#125;</span><br><span class="line">	errno = old_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这个实验主要是考察了安全信号处理内容，以及竞争关系；</p>
<p>帮助疏通了对Shell的理解：接受指令，处理指令，以及增加进程和如何回收进程；</p>
<p>对于小方向的话便是细节的考虑，阻塞顺序以及分类情况；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://secondbc.github.io/SecondBC/2022/04/23/Shell-Lab/" data-id="cl2bli06t00007svc3b735rrq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/SecondBC/2022/03/31/Angr-Lab/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Angr.Lab</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/SecondBC/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/SecondBC/2022/04/23/Shell-Lab/">Shell_Lab</a>
          </li>
        
          <li>
            <a href="/SecondBC/2022/03/31/Angr-Lab/">Angr.Lab</a>
          </li>
        
          <li>
            <a href="/SecondBC/2022/02/24/VM%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%8E%B0/">VM实验¤复现</a>
          </li>
        
          <li>
            <a href="/SecondBC/2022/02/22/Hgame2022-ReverseWriteUp/">Hgame2022-ReverseWriteUp</a>
          </li>
        
          <li>
            <a href="/SecondBC/2022/02/19/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%A4%8D%E7%8E%B002/">逆向工程核心原理复现02</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/SecondBC/" class="mobile-nav-link">Home</a>
  
    <a href="/SecondBC/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/SecondBC/fancybox/jquery.fancybox.css">

  
<script src="/SecondBC/fancybox/jquery.fancybox.pack.js"></script>




<script src="/SecondBC/js/script.js"></script>




  </div>
</body>
</html>